<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Advanced Cava Demo</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.min.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-floating"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.13.0+0.13.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="advanced-cava-demo">
<h1 class="title">Advanced Cava Demo</h1>

<link rel="stylesheet" href="tutorial.css" type="text/css" /><p>This set of examples goes a bit further than Cava's <a class="reference external" href="tutorial">tutorial</a> and showcases some
advanced features. For a more gentle introduction or setup instructions, the
tutorial is the best place to start.</p>
<p>Here's the high-level overview of what we'll cover:</p>
<blockquote>
<ol class="arabic simple">
<li>We'll write one circuit template to capture the logical structure of an
algorithm, and then show how to <em>instantiate it with different subcircuits
in order to perform different computations</em>.</li>
<li>We'll construct a circuit that efficiently multiplies by any fixed &quot;compile
time&quot; constant by <em>constructing the circuit dynamically according to the
constant</em>.</li>
<li>We'll prove everything correct <em>in full generality</em>, meaning the proofs
apply to any choice of subcircuits/constants/other parameters!</li>
</ol>
</blockquote>
<p>Some pieces of boilerplate code have been omitted for readability of this
page. You can view the <a class="reference external" href="https://github.com/project-oak/silveroak/blob/main/demos/ExpBySquaring.v">source</a> on our GitHub repo to see it, or to step through
the code locally.</p>
<p>In this demo, we'll define a circuit that executes a classic arithmetic
algorithm, exponentiation by squaring (<a class="reference external" href="https://en.wikipedia.org/wiki/Exponentiation_by_squaring">wikipedia</a>). The pseudocode looks like:</p>
<pre class="literal-block">
exp(x,e):
  if e = 0:
    return 1
  r = exp (x, e // 2)
  if e is even:
    return r^2
  else:
    return r^2 * x
</pre>
<p>Essentially, you can compute <tt class="docutils literal">x^e</tt> quickly by looking at the bitwise
representation of <tt class="docutils literal">e</tt> and either multiplying by <tt class="docutils literal">x</tt> or squaring. This saves
operations in comparison to the naive approach, especially for large numbers. To
compute <tt class="docutils literal">x^19</tt>, for instance, you would need only 8 multiplications instead of
the 18 you would need with a naive approach:</p>
<pre class="literal-block">
exp(x,19) = exp(x,9) ^ 2 * x
exp(x,9) = exp(x,4) ^ 2 * x
exp(x,4) = exp(x,2) ^ 2
exp(x,2) = exp(x,1) ^ 2
exp(x,1) = exp(x,0) ^ 2 * x
exp(x,0) = 1
</pre>
<p>If you substitute addition and doubling for multiplication and squaring in this
algorithm, and return 0 instead of 1 in the base case, it will compute
multiplication instead of exponentiation (&quot;multiplication by doubling&quot;). In this
case, you would compute <tt class="docutils literal">x*19</tt> as:</p>
<pre class="literal-block">
exp(x,19) = exp(x,9) * 2 + x
exp(x,9) = exp(x,4) * 2 + x
exp(x,4) = exp(x,2) * 2
exp(x,2) = exp(x,1) * 2
exp(x,1) = exp(x,0) * 2 + x
exp(x,0) = 1
</pre>
<p>For our hardware implementation, we'll assume that <tt class="docutils literal">x</tt> is a fixed constant
known before we build the circuit, and that we get the exponent as a stream of
bits (most significant bit first). As a circuit diagram, it looks like:</p>
<img alt="Diagram of the exponentiation-by-squaring circuit." src="expbysquaring.png" style="width: 90%;" />
<p>In Cava, this circuit would be defined as follows:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">  </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">exp_by_squaring</span> {<span class="nv">A</span>} (<span class="nv">identity</span> : combType A)
             (<span class="nv">square</span> : Circuit (signal A) (signal A))
             (<span class="nv">multiply</span> : Circuit (signal A) (signal A))
    : Circuit (signal Bit) (signal A) :=
    LoopInit identity
             (<span class="c">(* start: exp[i], r *)</span>
               Second (square &gt;==&gt; <span class="c">(* r^2 *)</span>
                              Comb fork2 &gt;==&gt; <span class="c">(* r^2, r^2 *)</span>
                              Second multiply <span class="c">(* r^2, r^2*x *)</span>)
                      &gt;==&gt; <span class="c">(* exp[i], (r^2, r^2*x) *)</span>
                      Comb (uncurry mux2 &gt;=&gt; fork2) <span class="c">(* r&#39;, r&#39; *)</span>).</span></span></span></pre><p>In order to support both multiplication and exponentiation with the same
definition, we haven't specified yet what exactly our &quot;square&quot; and &quot;multiply&quot;
procedures are. In Cava, you can take subcircuits as <em>arguments</em> to your circuit
definition, much like in some programming languages you can pass functions as
arguments to other functions. In pseudocode, this template would be analogous
to:</p>
<pre class="literal-block">
exp(identity, square, multiply, e):
  if e = 0:
    return identity
  r = exp(identity, square, multiply, e // 2)
  r2 = square(r)
  if e is even:
    return r2
  else:
    return multiply(r2)
</pre>
<p>Note that <tt class="docutils literal">multiply</tt> has only one operand here; since we assume <tt class="docutils literal">x</tt> is a
fixed constant, the <tt class="docutils literal">multiply</tt> is already specialized to multiply the input by
<tt class="docutils literal">x</tt>.</p>
<p>This circuit is so general that it can actually be adapted for even more
purposes than exponentiation and multiplication. By plugging in a no-op for
<tt class="docutils literal">square</tt> and an incrementer for <tt class="docutils literal">multiply</tt>, we can simply count the high
bits of the input stream:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">  <span class="c">(* count the number of high bits in the input stream *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">count_ones</span> {<span class="nv">n</span>}
    : Circuit (signal Bit) (signal (Vec Bit n)) :=
    exp_by_squaring
      (Vec.of_N <span class="mi">0</span>) (Comb ret) (Comb incrN).</span></span></span></pre><p>We can simulate the circuit to check that it has the desired behavior:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk0"><span class="highlight"><span class="kn">Compute</span> map Bv2N (simulate (count_ones (n:=<span class="mi">8</span>))
                           [true;true;true;false;false;true]).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= [<span class="mi">1</span>%N; <span class="mi">2</span>%N; <span class="mi">3</span>%N; <span class="mi">3</span>%N; <span class="mi">3</span>%N; <span class="mi">4</span>%N]
: list N</span></blockquote></div></div></small></span></pre><p>The <tt class="docutils literal">incrN</tt> subcircuit adds 1 to the input bitvector without growing the size
of the vector. This component is part of Cava's core library; check out the
<a class="reference external" href="../reference">reference</a> to browse the various verified circuit components that are included.
<tt class="docutils literal">Vec.of_N</tt> is also part of this library; it converts a number of Coq's <tt class="docutils literal">N</tt>
(binary natural numbers) type into a constant Cava bit-vector.</p>
<p>Next, let's try to define multiplication-by-doubling. We'll need to have
subcircuits for addition of a constant and for doubling. For addition, we can
use the <tt class="docutils literal">addN</tt> circuit that's included in Cava's standard library. Doubling,
however, can be treated as a bitwise operation; we can shift left by one. So
let's define a specific <tt class="docutils literal">double</tt> circuit separately:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">  <span class="c">(* double a bitvector by adding 0 and truncating *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">double</span> {<span class="nv">n</span>}
    : Circuit (signal (Vec Bit n)) (signal (Vec Bit n)) :=
    Comb (Vec.cons zero &gt;=&gt; Vec.shiftout).</span></span></span></pre><p>Now, we can write a circuit that, given a constant <tt class="docutils literal">x</tt>, computes <tt class="docutils literal">x</tt> times
the input stream:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">  <span class="c">(* multiply x by the input stream *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">stream_multiply</span> {<span class="nv">n</span>} (<span class="nv">x</span> : N)
    : Circuit (signal Bit) (signal (Vec Bit n)) :=
    <span class="c">(* Circuit that adds x to the input bitvector *)</span>
    <span class="kr">let</span> <span class="nv">addx</span> := Comb (<span class="kr">fun</span> <span class="nv">i</span> =&gt; addN (i, Vec.of_N x)) <span class="kr">in</span>
    exp_by_squaring (Vec.of_N <span class="mi">0</span>) double addx.</span></span></span></pre><p>Let's simulate it to see if it works. <tt class="docutils literal">[true;false;false;true]</tt> is an input
stream that represents the number 9, so this simulation computes <tt class="docutils literal">3*9</tt>.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight"><span class="c">(* 3 * 9 = 27 *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk1"><span class="highlight"><span class="kn">Compute</span> map Bv2N (simulate (stream_multiply (n:=<span class="mi">8</span>) <span class="mi">3</span>)
                           [true;false;false;true]).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= [<span class="mi">3</span>%N; <span class="mi">6</span>%N; <span class="mi">12</span>%N; <span class="mi">27</span>%N]
: list N</span></blockquote></div></div></small></span></pre><p>The test becomes more readable if we write a quick helper function to convert
numbers into streams:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight"><span class="c">(* Helper for simulation: convert a number into a list of bits with the most</span>
<span class="c">   signficant bit first *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">to_stream</span> (<span class="nv">x</span> : N) : list bool :=
  <span class="c">(* reverse because N2Bv puts the least significant bit first *)</span>
  rev (Vector.to_list (N2Bv x)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* 3 * 9 = 27 *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk2"><span class="highlight"><span class="kn">Compute</span> map Bv2N (simulate (stream_multiply (n:=<span class="mi">8</span>) <span class="mi">3</span>)
                           (to_stream <span class="mi">9</span>)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= [<span class="mi">3</span>%N; <span class="mi">6</span>%N; <span class="mi">12</span>%N; <span class="mi">27</span>%N]
: list N</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* 5 * 6 = 30 *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk3"><span class="highlight"><span class="kn">Compute</span> map Bv2N (simulate (stream_multiply (n:=<span class="mi">8</span>) <span class="mi">5</span>)
                           (to_stream <span class="mi">6</span>)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= [<span class="mi">5</span>%N; <span class="mi">15</span>%N; <span class="mi">30</span>%N]
: list N</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* 5 * 60 = 300 (bit vector size increased to 16) *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk4"><span class="highlight"><span class="kn">Compute</span> map Bv2N (simulate (stream_multiply (n:=<span class="mi">16</span>) <span class="mi">5</span>)
                           (to_stream <span class="mi">60</span>)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= [<span class="mi">5</span>%N; <span class="mi">15</span>%N; <span class="mi">35</span>%N; <span class="mi">75</span>%N; <span class="mi">150</span>%N; <span class="mi">300</span>%N]
: list N</span></blockquote></div></div></small></span></pre><p>So far, so good. But how about exponentiation by squaring? Now, we need one
subcircuit to multiply by a constant and one subcircuit to square the
input. Cava's core library already includes <tt class="docutils literal">squareN</tt>, which squares an input
bit-vector and truncates to the input size, so squaring is taken care of.</p>
<p>However, for multiplication, since one of the operands is a constant, it might
be efficient to construct our circuit in a way that takes advantage of that
fact. In Cava, we can actually write circuits that change structure based on
constant arguments. This circuit multiplies its input by the number <tt class="docutils literal">x</tt>, which
is expressed as Coq's strictly-positive bitvector type, <tt class="docutils literal">positive</tt>.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">  <span class="c">(* construct a circuit to multiply the input by a compile-time</span>
<span class="c">     constant (expressed as a strictly positive Coq bitvector) *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">mul_const_pos</span> {<span class="nv">n</span>} (<span class="nv">x</span> : positive)
    : Circuit (signal (Vec Bit n)) (signal (Vec Bit n)) :=
    (<span class="kr">match</span> x <span class="kr">with</span>
     | <span class="mi">1</span> =&gt; Comb ret
     | y~<span class="mi">0</span> =&gt;
       <span class="c">(* x * i = 2 * y * i *)</span>
       (mul_const_pos y) &gt;==&gt; double
     | y~<span class="mi">1</span> =&gt;
       <span class="c">(* x * i = (2 * y + 1) * i = 2 * y * i + i *)</span>
       Comb fork2 &gt;==&gt; <span class="c">(* i, i *)</span>
            First (mul_const_pos y &gt;==&gt; double) &gt;==&gt; <span class="c">(* 2*y*i, i *)</span>
            Comb addN <span class="c">(* 2*y*i + i *)</span>
     <span class="kr">end</span>)%positive.</span></span></span></pre><p>In case the syntax here is unfamiliar: the <tt class="docutils literal">match</tt> here separates three cases,
which correspond to the three constructors of <tt class="docutils literal">positive</tt>. In the first case,
<tt class="docutils literal">x = 1</tt>, in which case multiplying by <tt class="docutils literal">x</tt> is just the identity (<tt class="docutils literal">Comb ret</tt>
can be read as &quot;a wire&quot;). In the second case, <tt class="docutils literal">x</tt> is constructed from another
positive <tt class="docutils literal">y</tt> with a <tt class="docutils literal">0</tt> appended to the end, so <tt class="docutils literal">x = 2*y</tt>). In the third
case, <tt class="docutils literal">x</tt> is constructed from another positive <tt class="docutils literal">y</tt>, but this time with a
<tt class="docutils literal">1</tt> appended to the end, so <tt class="docutils literal">x = 2*y + 1</tt>.</p>
<p>We want to handle the case where <tt class="docutils literal">x = 0</tt> too, so we can define another wrapper
function on top where <tt class="docutils literal">x</tt> has the type of Coq's <em>nonnegative</em> bit-vectors,
<tt class="docutils literal">N</tt>. <tt class="docutils literal">N</tt> has two constructors; either <tt class="docutils literal">x</tt> is a zero, or <tt class="docutils literal">x</tt> is a
positive. So to define our circuit in terms of <tt class="docutils literal">N</tt>, we just produce a circuit
that always returns 0 if <tt class="docutils literal">x</tt> is zero and call <tt class="docutils literal">mul_const_pos</tt> to construct
the positive case.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">  <span class="c">(* construct a circuit to multiply the input by a compile-time</span>
<span class="c">     constant (expressed as a nonnegative Coq bitvector) *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">mul_constN</span> {<span class="nv">n</span>} (<span class="nv">x</span> : N)
    : Circuit (signal (Vec Bit n)) (signal (Vec Bit n)) :=
    <span class="kr">match</span> x <span class="kr">with</span>
    | <span class="mi">0</span>%N =&gt; Comb (<span class="kr">fun</span> <span class="nv">_</span> =&gt; ret (Vec.of_N <span class="mi">0</span>))
    | Npos p =&gt; mul_const_pos p
    <span class="kr">end</span>.</span></span></span></pre><p>We can try out constructing this circuit for different values of <tt class="docutils literal">x</tt> to see
how it behaves.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk5"><span class="highlight"><span class="kn">Eval</span> <span class="nb">cbv</span> [mul_constN mul_const_pos] <span class="kr">in</span> mul_constN <span class="mi">1</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= Comb ret
: Circuit (combType (Vec Bit <span class="nl">?n</span>))
    (combType (Vec Bit <span class="nl">?n</span>))</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk6"><span class="highlight"><span class="kn">Eval</span> <span class="nb">cbv</span> [mul_constN mul_const_pos] <span class="kr">in</span> mul_constN <span class="mi">4</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= Comb ret &gt;==&gt; double &gt;==&gt; double
: Circuit (combType (Vec Bit <span class="nl">?n</span>))
    (combType (Vec Bit <span class="nl">?n</span>))</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk7"><span class="highlight"><span class="kn">Eval</span> <span class="nb">cbv</span> [mul_constN mul_const_pos] <span class="kr">in</span> mul_constN <span class="mi">5</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= Comb fork2 &gt;==&gt;
  First (Comb ret &gt;==&gt; double &gt;==&gt; double) &gt;==&gt;
  Comb addN
: Circuit (combType (Vec Bit <span class="nl">?n</span>))
    (combType (Vec Bit <span class="nl">?n</span>))</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk8"><span class="highlight"><span class="kn">Eval</span> <span class="nb">cbv</span> [mul_constN mul_const_pos] <span class="kr">in</span> mul_constN <span class="mi">16</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= Comb ret &gt;==&gt; double &gt;==&gt; double &gt;==&gt; double &gt;==&gt;
  double
: Circuit (combType (Vec Bit <span class="nl">?n</span>))
    (combType (Vec Bit <span class="nl">?n</span>))</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk9"><span class="highlight"><span class="kn">Eval</span> <span class="nb">cbv</span> [mul_constN mul_const_pos] <span class="kr">in</span> mul_constN <span class="mi">20</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= Comb fork2 &gt;==&gt;
  First (Comb ret &gt;==&gt; double &gt;==&gt; double) &gt;==&gt;
  Comb addN &gt;==&gt; double &gt;==&gt; double
: Circuit (combType (Vec Bit <span class="nl">?n</span>))
    (combType (Vec Bit <span class="nl">?n</span>))</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chka"><span class="highlight"><span class="kn">Eval</span> <span class="nb">cbv</span> [mul_constN mul_const_pos] <span class="kr">in</span> mul_constN <span class="mi">2048</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= Comb ret &gt;==&gt; double &gt;==&gt; double &gt;==&gt; double &gt;==&gt;
  double &gt;==&gt; double &gt;==&gt; double &gt;==&gt; double &gt;==&gt;
  double &gt;==&gt; double &gt;==&gt; double &gt;==&gt; double
: Circuit (combType (Vec Bit <span class="nl">?n</span>))
    (combType (Vec Bit <span class="nl">?n</span>))</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chkb"><span class="highlight"><span class="kn">Eval</span> <span class="nb">cbv</span> [mul_constN mul_const_pos] <span class="kr">in</span> mul_constN <span class="mi">100000</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= Comb fork2 &gt;==&gt;
  First
    (Comb fork2 &gt;==&gt;
     First
       (Comb fork2 &gt;==&gt;
        First
          (Comb fork2 &gt;==&gt;
           First (... &gt;==&gt; double) &gt;==&gt; Comb addN &gt;==&gt;
           double) &gt;==&gt; Comb addN &gt;==&gt; double &gt;==&gt;
        double) &gt;==&gt; Comb addN &gt;==&gt; double &gt;==&gt;
     double) &gt;==&gt; Comb addN &gt;==&gt; double &gt;==&gt;
  double &gt;==&gt; double &gt;==&gt; double &gt;==&gt; double
: Circuit (combType (Vec Bit <span class="nl">?n</span>))
    (combType (Vec Bit <span class="nl">?n</span>))</span></blockquote></div></div></small></span></pre><p>Here are the circuit diagrams for some of the smaller ones:</p>
<div class="figure align-center">
<img alt="Diagram of a circuit that multiplies by 1" src="mul1.png" style="width: 90%;" />
</div>
<p>Above: circuit diagram for <tt class="docutils literal">mul_constN 1</tt>.</p>
<div class="figure align-center">
<img alt="Diagram of a circuit that multiplies by 4." src="mul4.png" style="width: 90%;" />
</div>
<p>Above: circuit diagram for <tt class="docutils literal">mul_constN 4</tt>.</p>
<div class="figure align-center">
<img alt="Diagram of a circuit that multiplies by 5." src="mul5.png" style="width: 90%;" />
</div>
<p>Above: circuit diagram for <tt class="docutils literal">mul_constN 5</tt>.</p>
<div class="figure align-center">
<img alt="Diagram of a circuit that multiplies by 20." src="mul20.png" style="width: 90%;" />
</div>
<p>Above: circuit diagram for <tt class="docutils literal">mul_constN 20</tt>. Note that this is the same as
composing <tt class="docutils literal">mul_constN 5</tt> and <tt class="docutils literal">mul_constN 4</tt>.</p>
<p>Now that we can multiply by constants efficiently, we can build a circuit that
implements exponentiation by squaring:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">  <span class="c">(* raise x to the power of the input stream *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">stream_exponentiate</span> {<span class="nv">n</span>} (<span class="nv">x</span> : N)
    : Circuit (signal Bit) (signal (Vec Bit n)) :=
    exp_by_squaring (Vec.of_N <span class="mi">1</span>) (Comb squareN) (mul_constN x).</span></span></span></pre><p>It works!</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight"><span class="c">(* Compute 3 ^ 5 = 243 *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chkc"><span class="highlight"><span class="kn">Compute</span> map Bv2N
        (simulate (stream_exponentiate (n:=<span class="mi">8</span>) <span class="mi">3</span>)
                  (to_stream <span class="mi">5</span>)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= [<span class="mi">3</span>%N; <span class="mi">9</span>%N; <span class="mi">243</span>%N]
: list N</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* Compute 5 ^ 6 = 15625 *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chkd"><span class="highlight"><span class="kn">Compute</span> map Bv2N
        (simulate (stream_exponentiate (n:=<span class="mi">16</span>) <span class="mi">5</span>)
                  (to_stream <span class="mi">6</span>)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= [<span class="mi">5</span>%N; <span class="mi">125</span>%N; <span class="mi">15625</span>%N]
: list N</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* Compute 3 ^ 123</span>
<span class="c">   = 48519278097689642681155855396759336072749841943521979872827 *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chke"><span class="highlight"><span class="kn">Compute</span> map Bv2N
        (simulate (stream_exponentiate (n:=<span class="mi">200</span>) <span class="mi">3</span>)
                  (to_stream <span class="mi">123</span>)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= [<span class="mi">3</span>%N; <span class="mi">27</span>%N; <span class="mi">2187</span>%N; <span class="mi">14348907</span>%N;
  <span class="mi">205891132094649</span>%N;
  <span class="mi">127173474825648610542883299603</span>%N;
  <span class="mi">48519278097689642681155855396759336072749841943521979872827</span>%N]
: list N</span></blockquote></div></div></small></span></pre><p>Now that we've defined all our circuits and tested them a little bit to make
sure they work for some inputs, it's time to prove them correct more
rigorously. The really cool thing about defining these circuits in Coq is that
now we can prove that they behave as expected for <em>all possible inputs</em>. We can
even prove that they work for all <em>constant parameters</em>, such as the bit-vector
size <tt class="docutils literal">n</tt> for <tt class="docutils literal">stream_exponentiate</tt> and the constant <tt class="docutils literal">x</tt> for
<tt class="docutils literal">mul_constN</tt>. In a sense, we're not just proving that our one single circuit
is correct; we're proving that the strategy we use to construct it is <em>always</em>
correct. This kind of reasoning is an extremely powerful tool.</p>
<p>First, we'll want to prove that <tt class="docutils literal">exp_by_squaring</tt> is correct. We'll define a
specification for it in Coq's specification language that captures the crux of
the algorithm.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">exp_by_squaring_spec</span>
           {<span class="nv">A</span>} (<span class="nv">mulx</span> <span class="nv">square</span> : A -&gt; A)
           (<span class="nv">id</span> : A) (<span class="nv">exponent</span> : list bool) : A :=
  fold_left
    (<span class="kr">fun</span> <span class="nv">r</span> (<span class="nv">bit</span> : bool) =&gt; <span class="kr">if</span> bit <span class="kr">then</span> mulx (square r) <span class="kr">else</span> square r)
    exponent id.</span></span></span></pre><p>This specification takes a stream of input and produces the output value we
expect from the circuit after that stream of input has been processed. But this
doesn't quite match our circuit's behavior; we'll get intermediate values as
well. We can define a helper function to apply our specification to each prefix
of the input:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">map_stream</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> : list A -&gt; B) (<span class="nv">input</span> : list A) : list B
  := map (<span class="kr">fun</span> <span class="nv">n</span> =&gt; f (firstn (S n) input)) (seq <span class="mi">0</span> (length input)).</span></span></span></pre><p>And now, the proof! It more or less comes down to applying a loop-invariant
lemma, using the preconditions about <tt class="docutils literal">square</tt> and <tt class="docutils literal">multiply</tt> to rewrite
those expressions, and doing some list manipulations. Just like in the tutorial,
it's our suggestion to focus more on the proof <em>statements</em> (the part between
<tt class="docutils literal">Lemma</tt> and <tt class="docutils literal">Proof</tt>) than the proof <em>bodies</em> (the part between <tt class="docutils literal">Proof</tt> and
<tt class="docutils literal">Qed</tt>). The former is intended for humans to read and reason about; the latter
is an argument to Coq that the statement is true, and if the Coq typechecker
accepts it then the argument must be valid (unless there's a bug in Coq itself).</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chkf"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">exp_by_squaring_correct</span> {<span class="nv">A</span>}
      (<span class="nv">mul_spec</span> <span class="nv">square_spec</span> : combType A -&gt; combType A)
      (<span class="nv">identity</span> : combType A)
      (<span class="nv">square</span> <span class="nv">multiply</span> : Circuit (combType A) (combType A))
      (<span class="nv">square_correct</span> :
         <span class="kr">forall</span> <span class="nv">st</span> <span class="nv">i</span>, step square st i = (square_spec i, st))
      (<span class="nv">multiply_correct</span> :
         <span class="kr">forall</span> <span class="nv">st</span> <span class="nv">i</span>, step multiply st i = (mul_spec i, st))
      (<span class="nv">input</span> : list bool) :
  simulate (exp_by_squaring identity square multiply) input
  = map_stream (exp_by_squaring_spec mul_spec square_spec identity)
               input.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SignalType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">mul_spec, square_spec</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A -&gt; combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">identity</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square, multiply</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Circuit (combType A) (combType A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : circuit_state square)
  (<span class="nv">i</span> : combType A),
step square st i =
(square_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">multiply_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span>
  (<span class="nv">st</span> : circuit_state multiply)
  (<span class="nv">i</span> : combType A),
step multiply st i =
(mul_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate (exp_by_squaring identity square multiply)
  input =
map_stream
  (exp_by_squaring_spec mul_spec square_spec identity)
  input</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk10"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SignalType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">mul_spec, square_spec</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A -&gt; combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">identity</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square, multiply</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Circuit (combType A) (combType A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : circuit_state square)
  (<span class="nv">i</span> : combType A),
step square st i =
(square_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">multiply_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span>
  (<span class="nv">st</span> : circuit_state multiply)
  (<span class="nv">i</span> : combType A),
step multiply st i =
(mul_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate (exp_by_squaring identity square multiply)
  input =
map_stream
  (exp_by_squaring_spec mul_spec square_spec identity)
  input</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk11"><span class="highlight"><span class="nb">cbv</span> [exp_by_squaring map_stream].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SignalType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">mul_spec, square_spec</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A -&gt; combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">identity</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square, multiply</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Circuit (combType A) (combType A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : circuit_state square)
  (<span class="nv">i</span> : combType A),
step square st i =
(square_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">multiply_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span>
  (<span class="nv">st</span> : circuit_state multiply)
  (<span class="nv">i</span> : combType A),
step multiply st i =
(mul_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate
  (LoopInit identity
     (Second
        (square &gt;==&gt; Comb fork2 &gt;==&gt; Second multiply) &gt;==&gt;
      Comb (uncurry mux2 &gt;=&gt; fork2))) input =
map
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   exp_by_squaring_spec mul_spec square_spec identity
     (firstn (S n) input))
  (seq <span class="mi">0</span> (Datatypes.length input))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk12"><span class="highlight"><span class="nb">eapply</span> simulate_LoopInit_invariant
    <span class="kr">with</span> (I:=<span class="kr">fun</span> <span class="nv">i</span> <span class="nv">r</span> <span class="nv">_</span> <span class="nv">out</span> =&gt;
               out = map (<span class="kr">fun</span> <span class="nv">n</span> =&gt; exp_by_squaring_spec
                                  mul_spec square_spec
                                  identity (firstn (S n) input))
                         (seq <span class="mi">0</span> i)
               /\ r = exp_by_squaring_spec
                       mul_spec square_spec identity (firstn i input)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SignalType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">mul_spec, square_spec</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A -&gt; combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">identity</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square, multiply</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Circuit (combType A) (combType A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : circuit_state square)
  (<span class="nv">i</span> : combType A),
step square st i =
(square_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">multiply_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span>
  (<span class="nv">st</span> : circuit_state multiply)
  (<span class="nv">i</span> : combType A),
step multiply st i =
(mul_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[] =
map
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   exp_by_squaring_spec mul_spec square_spec identity
     (firstn (S n) input)) 
  (seq <span class="mi">0</span> <span class="mi">0</span>) /\
identity =
exp_by_squaring_spec mul_spec square_spec identity
  (firstn <span class="mi">0</span> input)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="expbysquaring-v-chk13" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SignalType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">mul_spec, square_spec</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A -&gt; combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">identity</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square, multiply</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Circuit (combType A) (combType A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : circuit_state square)
  (<span class="nv">i</span> : combType A),
step square st i =
(square_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">multiply_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span>
  (<span class="nv">st</span> : circuit_state multiply)
  (<span class="nv">i</span> : combType A),
step multiply st i =
(mul_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="expbysquaring-v-chk13"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">t</span> : nat) (<span class="nv">acc</span> : list (combType A))
  (<span class="nv">st</span> : combType A)
  (<span class="nv">bodyst</span> : circuit_state
              (Second
                 (square &gt;==&gt; Comb fork2 &gt;==&gt;
                  Second multiply) &gt;==&gt;
               Comb (uncurry mux2 &gt;=&gt; fork2)))
  (<span class="nv">d</span> : combType Bit),
acc =
map
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   exp_by_squaring_spec mul_spec square_spec identity
     (firstn (S n) input)) 
  (seq <span class="mi">0</span> t) /\
st =
exp_by_squaring_spec mul_spec square_spec identity
  (firstn t input) -&gt;
<span class="mi">0</span> &lt;= t &lt; Datatypes.length input -&gt;
<span class="kr">let</span> <span class="nv">out_st&#39;_bodyst&#39;</span> :=
  step
    (Second
       (square &gt;==&gt; Comb fork2 &gt;==&gt; Second multiply) &gt;==&gt;
     Comb (uncurry mux2 &gt;=&gt; fork2)) bodyst
    (nth t input d, st) <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">out</span> := fst (fst out_st&#39;_bodyst&#39;) <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">st&#39;</span> := snd (fst out_st&#39;_bodyst&#39;) <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">bodyst&#39;</span> := snd out_st&#39;_bodyst&#39; <span class="kr">in</span>
acc ++ [out] =
map
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   exp_by_squaring_spec mul_spec square_spec identity
     (firstn (S n) input)) 
  (seq <span class="mi">0</span> (S t)) /\
st&#39; =
exp_by_squaring_spec mul_spec square_spec identity
  (firstn (S t) input)</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="expbysquaring-v-chk14" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SignalType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">mul_spec, square_spec</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A -&gt; combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">identity</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square, multiply</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Circuit (combType A) (combType A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : circuit_state square)
  (<span class="nv">i</span> : combType A),
step square st i =
(square_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">multiply_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span>
  (<span class="nv">st</span> : circuit_state multiply)
  (<span class="nv">i</span> : combType A),
step multiply st i =
(mul_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="expbysquaring-v-chk14"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">acc</span> : list (combType A)) (<span class="nv">st</span> : combType A),
circuit_state
  (Second
     (square &gt;==&gt; Comb fork2 &gt;==&gt; Second multiply) &gt;==&gt;
   Comb (uncurry mux2 &gt;=&gt; fork2)) -&gt;
acc =
map
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   exp_by_squaring_spec mul_spec square_spec identity
     (firstn (S n) input))
  (seq <span class="mi">0</span> (Datatypes.length input)) /\
st =
exp_by_squaring_spec mul_spec square_spec identity
  (firstn (Datatypes.length input) input) -&gt;
acc =
map
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   exp_by_squaring_spec mul_spec square_spec identity
     (firstn (S n) input))
  (seq <span class="mi">0</span> (Datatypes.length input))</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk15"><span class="highlight">{ <span class="c">(* invariant holds in reset state *)</span></span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SignalType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">mul_spec, square_spec</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A -&gt; combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">identity</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square, multiply</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Circuit (combType A) (combType A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : circuit_state square)
  (<span class="nv">i</span> : combType A),
step square st i =
(square_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">multiply_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span>
  (<span class="nv">st</span> : circuit_state multiply)
  (<span class="nv">i</span> : combType A),
step multiply st i =
(mul_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[] =
map
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   exp_by_squaring_spec mul_spec square_spec identity
     (firstn (S n) input)) 
  (seq <span class="mi">0</span> <span class="mi">0</span>) /\
identity =
exp_by_squaring_spec mul_spec square_spec identity
  (firstn <span class="mi">0</span> input)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">split</span>; <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk16"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SignalType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">mul_spec, square_spec</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A -&gt; combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">identity</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square, multiply</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Circuit (combType A) (combType A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : circuit_state square)
  (<span class="nv">i</span> : combType A),
step square st i =
(square_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">multiply_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span>
  (<span class="nv">st</span> : circuit_state multiply)
  (<span class="nv">i</span> : combType A),
step multiply st i =
(mul_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">t</span> : nat) (<span class="nv">acc</span> : list (combType A))
  (<span class="nv">st</span> : combType A)
  (<span class="nv">bodyst</span> : circuit_state
              (Second
                 (square &gt;==&gt; Comb fork2 &gt;==&gt;
                  Second multiply) &gt;==&gt;
               Comb (uncurry mux2 &gt;=&gt; fork2)))
  (<span class="nv">d</span> : combType Bit),
acc =
map
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   exp_by_squaring_spec mul_spec square_spec identity
     (firstn (S n) input)) 
  (seq <span class="mi">0</span> t) /\
st =
exp_by_squaring_spec mul_spec square_spec identity
  (firstn t input) -&gt;
<span class="mi">0</span> &lt;= t &lt; Datatypes.length input -&gt;
<span class="kr">let</span> <span class="nv">out_st&#39;_bodyst&#39;</span> :=
  step
    (Second
       (square &gt;==&gt; Comb fork2 &gt;==&gt; Second multiply) &gt;==&gt;
     Comb (uncurry mux2 &gt;=&gt; fork2)) bodyst
    (nth t input d, st) <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">out</span> := fst (fst out_st&#39;_bodyst&#39;) <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">st&#39;</span> := snd (fst out_st&#39;_bodyst&#39;) <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">bodyst&#39;</span> := snd out_st&#39;_bodyst&#39; <span class="kr">in</span>
acc ++ [out] =
map
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   exp_by_squaring_spec mul_spec square_spec identity
     (firstn (S n) input)) 
  (seq <span class="mi">0</span> (S t)) /\
st&#39; =
exp_by_squaring_spec mul_spec square_spec identity
  (firstn (S t) input)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="expbysquaring-v-chk17" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SignalType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">mul_spec, square_spec</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A -&gt; combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">identity</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square, multiply</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Circuit (combType A) (combType A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : circuit_state square)
  (<span class="nv">i</span> : combType A),
step square st i =
(square_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">multiply_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span>
  (<span class="nv">st</span> : circuit_state multiply)
  (<span class="nv">i</span> : combType A),
step multiply st i =
(mul_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="expbysquaring-v-chk17"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">acc</span> : list (combType A)) (<span class="nv">st</span> : combType A),
circuit_state
  (Second
     (square &gt;==&gt; Comb fork2 &gt;==&gt; Second multiply) &gt;==&gt;
   Comb (uncurry mux2 &gt;=&gt; fork2)) -&gt;
acc =
map
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   exp_by_squaring_spec mul_spec square_spec identity
     (firstn (S n) input))
  (seq <span class="mi">0</span> (Datatypes.length input)) /\
st =
exp_by_squaring_spec mul_spec square_spec identity
  (firstn (Datatypes.length input) input) -&gt;
acc =
map
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   exp_by_squaring_spec mul_spec square_spec identity
     (firstn (S n) input))
  (seq <span class="mi">0</span> (Datatypes.length input))</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk18"><span class="highlight">{ <span class="c">(* invariant holds through one timestep *)</span></span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SignalType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">mul_spec, square_spec</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A -&gt; combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">identity</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square, multiply</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Circuit (combType A) (combType A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : circuit_state square)
  (<span class="nv">i</span> : combType A),
step square st i =
(square_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">multiply_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span>
  (<span class="nv">st</span> : circuit_state multiply)
  (<span class="nv">i</span> : combType A),
step multiply st i =
(mul_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">t</span> : nat) (<span class="nv">acc</span> : list (combType A))
  (<span class="nv">st</span> : combType A)
  (<span class="nv">bodyst</span> : circuit_state
              (Second
                 (square &gt;==&gt; Comb fork2 &gt;==&gt;
                  Second multiply) &gt;==&gt;
               Comb (uncurry mux2 &gt;=&gt; fork2)))
  (<span class="nv">d</span> : combType Bit),
acc =
map
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   exp_by_squaring_spec mul_spec square_spec identity
     (firstn (S n) input)) 
  (seq <span class="mi">0</span> t) /\
st =
exp_by_squaring_spec mul_spec square_spec identity
  (firstn t input) -&gt;
<span class="mi">0</span> &lt;= t &lt; Datatypes.length input -&gt;
<span class="kr">let</span> <span class="nv">out_st&#39;_bodyst&#39;</span> :=
  step
    (Second
       (square &gt;==&gt; Comb fork2 &gt;==&gt; Second multiply) &gt;==&gt;
     Comb (uncurry mux2 &gt;=&gt; fork2)) bodyst
    (nth t input d, st) <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">out</span> := fst (fst out_st&#39;_bodyst&#39;) <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">st&#39;</span> := snd (fst out_st&#39;_bodyst&#39;) <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">bodyst&#39;</span> := snd out_st&#39;_bodyst&#39; <span class="kr">in</span>
acc ++ [out] =
map
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   exp_by_squaring_spec mul_spec square_spec identity
     (firstn (S n) input)) 
  (seq <span class="mi">0</span> (S t)) /\
st&#39; =
exp_by_squaring_spec mul_spec square_spec identity
  (firstn (S t) input)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk19"><span class="highlight"><span class="nb">cbv</span> zeta; <span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SignalType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">mul_spec, square_spec</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A -&gt; combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">identity</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square, multiply</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Circuit (combType A) (combType A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : circuit_state square)
  (<span class="nv">i</span> : combType A),
step square st i =
(square_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">multiply_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span>
  (<span class="nv">st</span> : circuit_state multiply)
  (<span class="nv">i</span> : combType A),
step multiply st i =
(mul_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">acc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">st</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bodyst</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state
  (Second
     (square &gt;==&gt; Comb fork2 &gt;==&gt;
      Second multiply) &gt;==&gt;
   Comb (uncurry mux2 &gt;=&gt; fork2))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType Bit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">acc =
map
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   exp_by_squaring_spec mul_spec square_spec
     identity (firstn (S n) input)) 
  (seq <span class="mi">0</span> t) /\
st =
exp_by_squaring_spec mul_spec square_spec identity
  (firstn t input)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= t &lt; Datatypes.length input</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">acc ++
[fst
   (fst
      (step
         (Second
            (square &gt;==&gt; Comb fork2 &gt;==&gt;
             Second multiply) &gt;==&gt;
          Comb (uncurry mux2 &gt;=&gt; fork2)) bodyst
         (nth t input d, st)))] =
map
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   exp_by_squaring_spec mul_spec square_spec identity
     (firstn (S n) input)) 
  (seq <span class="mi">0</span> (S t)) /\
snd
  (fst
     (step
        (Second
           (square &gt;==&gt; Comb fork2 &gt;==&gt;
            Second multiply) &gt;==&gt;
         Comb (uncurry mux2 &gt;=&gt; fork2)) bodyst
        (nth t input d, st))) =
exp_by_squaring_spec mul_spec square_spec identity
  (firstn (S t) input)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk1a"><span class="highlight">logical_simplify; <span class="nb">subst</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SignalType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">mul_spec, square_spec</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A -&gt; combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">identity</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square, multiply</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Circuit (combType A) (combType A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : circuit_state square)
  (<span class="nv">i</span> : combType A),
step square st i =
(square_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">multiply_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span>
  (<span class="nv">st</span> : circuit_state multiply)
  (<span class="nv">i</span> : combType A),
step multiply st i =
(mul_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bodyst</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state
  (Second
     (square &gt;==&gt; Comb fork2 &gt;==&gt;
      Second multiply) &gt;==&gt;
   Comb (uncurry mux2 &gt;=&gt; fork2))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType Bit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t &lt; Datatypes.length input</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   exp_by_squaring_spec mul_spec square_spec identity
     (firstn (S n) input)) 
  (seq <span class="mi">0</span> t) ++
[fst
   (fst
      (step
         (Second
            (square &gt;==&gt; Comb fork2 &gt;==&gt;
             Second multiply) &gt;==&gt;
          Comb (uncurry mux2 &gt;=&gt; fork2)) bodyst
         (nth t input d,
         exp_by_squaring_spec mul_spec square_spec
           identity (firstn t input))))] =
map
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   exp_by_squaring_spec mul_spec square_spec identity
     (firstn (S n) input)) 
  (seq <span class="mi">0</span> (S t)) /\
snd
  (fst
     (step
        (Second
           (square &gt;==&gt; Comb fork2 &gt;==&gt;
            Second multiply) &gt;==&gt;
         Comb (uncurry mux2 &gt;=&gt; fork2)) bodyst
        (nth t input d,
        exp_by_squaring_spec mul_spec square_spec
          identity (firstn t input)))) =
exp_by_squaring_spec mul_spec square_spec identity
  (firstn (S t) input)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk1b"><span class="highlight"><span class="nb">cbv</span> [mcompose uncurry].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SignalType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">mul_spec, square_spec</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A -&gt; combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">identity</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square, multiply</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Circuit (combType A) (combType A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : circuit_state square)
  (<span class="nv">i</span> : combType A),
step square st i =
(square_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">multiply_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span>
  (<span class="nv">st</span> : circuit_state multiply)
  (<span class="nv">i</span> : combType A),
step multiply st i =
(mul_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bodyst</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state
  (Second
     (square &gt;==&gt; Comb fork2 &gt;==&gt;
      Second multiply) &gt;==&gt;
   Comb (uncurry mux2 &gt;=&gt; fork2))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType Bit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t &lt; Datatypes.length input</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   exp_by_squaring_spec mul_spec square_spec identity
     (firstn (S n) input)) 
  (seq <span class="mi">0</span> t) ++
[fst
   (fst
      (step
         (Second
            (square &gt;==&gt; Comb fork2 &gt;==&gt;
             Second multiply) &gt;==&gt;
          Comb
            (<span class="kr">fun</span>
               <span class="nv">x</span> : combType Bit *
                   (combType A * combType A) =&gt;
             x &lt;- (<span class="kr">let</span> (<span class="nv">x0</span>, y) := x <span class="kr">in</span> mux2 x0 y);;
             fork2 x)) bodyst
         (nth t input d,
         exp_by_squaring_spec mul_spec square_spec
           identity (firstn t input))))] =
map
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   exp_by_squaring_spec mul_spec square_spec identity
     (firstn (S n) input)) 
  (seq <span class="mi">0</span> (S t)) /\
snd
  (fst
     (step
        (Second
           (square &gt;==&gt; Comb fork2 &gt;==&gt;
            Second multiply) &gt;==&gt;
         Comb
           (<span class="kr">fun</span>
              <span class="nv">x</span> : combType Bit *
                  (combType A * combType A) =&gt;
            x &lt;- (<span class="kr">let</span> (<span class="nv">x0</span>, y) := x <span class="kr">in</span> mux2 x0 y);;
            fork2 x)) bodyst
        (nth t input d,
        exp_by_squaring_spec mul_spec square_spec
          identity (firstn t input)))) =
exp_by_squaring_spec mul_spec square_spec identity
  (firstn (S t) input)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk1c"><span class="highlight">simpl_ident.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SignalType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">mul_spec, square_spec</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A -&gt; combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">identity</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square, multiply</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Circuit (combType A) (combType A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : circuit_state square)
  (<span class="nv">i</span> : combType A),
step square st i =
(square_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">multiply_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span>
  (<span class="nv">st</span> : circuit_state multiply)
  (<span class="nv">i</span> : combType A),
step multiply st i =
(mul_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bodyst</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state
  (Second
     (square &gt;==&gt; Comb fork2 &gt;==&gt;
      Second multiply) &gt;==&gt;
   Comb (uncurry mux2 &gt;=&gt; fork2))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType Bit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t &lt; Datatypes.length input</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   exp_by_squaring_spec mul_spec square_spec identity
     (firstn (S n) input)) 
  (seq <span class="mi">0</span> t) ++
[fst
   (fst
      (step
         (Second
            (square &gt;==&gt; Comb fork2 &gt;==&gt;
             Second multiply) &gt;==&gt;
          Comb
            (<span class="kr">fun</span>
               <span class="nv">x</span> : combType Bit *
                   (combType A * combType A) =&gt;
             fork2 (<span class="kr">let</span> (<span class="nv">x0</span>, y) := x <span class="kr">in</span> mux2 x0 y)))
         bodyst
         (nth t input d,
         exp_by_squaring_spec mul_spec square_spec
           identity (firstn t input))))] =
map
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   exp_by_squaring_spec mul_spec square_spec identity
     (firstn (S n) input)) 
  (seq <span class="mi">0</span> (S t)) /\
snd
  (fst
     (step
        (Second
           (square &gt;==&gt; Comb fork2 &gt;==&gt;
            Second multiply) &gt;==&gt;
         Comb
           (<span class="kr">fun</span>
              <span class="nv">x</span> : combType Bit *
                  (combType A * combType A) =&gt;
            fork2 (<span class="kr">let</span> (<span class="nv">x0</span>, y) := x <span class="kr">in</span> mux2 x0 y)))
        bodyst
        (nth t input d,
        exp_by_squaring_spec mul_spec square_spec
          identity (firstn t input)))) =
exp_by_squaring_spec mul_spec square_spec identity
  (firstn (S t) input)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">    <span class="c">(* simplify step, rewrite with square/multiply correctness lemmas *)</span>
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk1d"><span class="highlight"><span class="kp">repeat</span> <span class="kp">first</span> [ <span class="kp">progress</span> <span class="nb">cbn</span> [fst snd step]
                 | <span class="nb">rewrite</span> square_correct
                 | <span class="nb">rewrite</span> multiply_correct
                 | destruct_pair_let
                 | <span class="kp">progress</span> simpl_ident ].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SignalType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">mul_spec, square_spec</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A -&gt; combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">identity</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square, multiply</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Circuit (combType A) (combType A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : circuit_state square)
  (<span class="nv">i</span> : combType A),
step square st i =
(square_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">multiply_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span>
  (<span class="nv">st</span> : circuit_state multiply)
  (<span class="nv">i</span> : combType A),
step multiply st i =
(mul_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bodyst</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state
  (Second
     (square &gt;==&gt; Comb fork2 &gt;==&gt;
      Second multiply) &gt;==&gt;
   Comb (uncurry mux2 &gt;=&gt; fork2))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType Bit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t &lt; Datatypes.length input</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   exp_by_squaring_spec mul_spec square_spec identity
     (firstn (S n) input)) 
  (seq <span class="mi">0</span> t) ++
[<span class="kr">if</span> nth t input d
 <span class="kr">then</span>
  mul_spec
    (square_spec
       (exp_by_squaring_spec mul_spec square_spec
          identity (firstn t input)))
 <span class="kr">else</span>
  square_spec
    (exp_by_squaring_spec mul_spec square_spec
       identity (firstn t input))] =
map
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   exp_by_squaring_spec mul_spec square_spec identity
     (firstn (S n) input)) 
  (seq <span class="mi">0</span> (S t)) /\
(<span class="kr">if</span> nth t input d
 <span class="kr">then</span>
  mul_spec
    (square_spec
       (exp_by_squaring_spec mul_spec square_spec
          identity (firstn t input)))
 <span class="kr">else</span>
  square_spec
    (exp_by_squaring_spec mul_spec square_spec
       identity (firstn t input))) =
exp_by_squaring_spec mul_spec square_spec identity
  (firstn (S t) input)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">    <span class="c">(* separate the most recent step from previous steps *)</span>
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk1e"><span class="highlight"><span class="nb">autorewrite with</span> pull_snoc natsimpl.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SignalType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">mul_spec, square_spec</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A -&gt; combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">identity</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square, multiply</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Circuit (combType A) (combType A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : circuit_state square)
  (<span class="nv">i</span> : combType A),
step square st i =
(square_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">multiply_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span>
  (<span class="nv">st</span> : circuit_state multiply)
  (<span class="nv">i</span> : combType A),
step multiply st i =
(mul_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bodyst</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state
  (Second
     (square &gt;==&gt; Comb fork2 &gt;==&gt;
      Second multiply) &gt;==&gt;
   Comb (uncurry mux2 &gt;=&gt; fork2))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType Bit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t &lt; Datatypes.length input</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   exp_by_squaring_spec mul_spec square_spec identity
     (firstn (S n) input)) 
  (seq <span class="mi">0</span> t) ++
[<span class="kr">if</span> nth t input d
 <span class="kr">then</span>
  mul_spec
    (square_spec
       (exp_by_squaring_spec mul_spec square_spec
          identity (firstn t input)))
 <span class="kr">else</span>
  square_spec
    (exp_by_squaring_spec mul_spec square_spec
       identity (firstn t input))] =
map
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   exp_by_squaring_spec mul_spec square_spec identity
     (firstn (S n) input)) 
  (seq <span class="mi">0</span> t) ++
[exp_by_squaring_spec mul_spec square_spec identity
   (firstn (S t) input)] /\
(<span class="kr">if</span> nth t input d
 <span class="kr">then</span>
  mul_spec
    (square_spec
       (exp_by_squaring_spec mul_spec square_spec
          identity (firstn t input)))
 <span class="kr">else</span>
  square_spec
    (exp_by_squaring_spec mul_spec square_spec
       identity (firstn t input))) =
exp_by_squaring_spec mul_spec square_spec identity
  (firstn (S t) input)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk1f"><span class="highlight"><span class="nb">rewrite</span> (firstn_succ_snoc input _ <span class="kp">ltac</span>:(<span class="bp">eassumption</span>))
      <span class="bp">by</span> (<span class="nb">cbn</span> [combType] <span class="kr">in</span> *; <span class="bp">lia</span>).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SignalType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">mul_spec, square_spec</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A -&gt; combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">identity</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square, multiply</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Circuit (combType A) (combType A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : circuit_state square)
  (<span class="nv">i</span> : combType A),
step square st i =
(square_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">multiply_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span>
  (<span class="nv">st</span> : circuit_state multiply)
  (<span class="nv">i</span> : combType A),
step multiply st i =
(mul_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bodyst</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state
  (Second
     (square &gt;==&gt; Comb fork2 &gt;==&gt;
      Second multiply) &gt;==&gt;
   Comb (uncurry mux2 &gt;=&gt; fork2))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType Bit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t &lt; Datatypes.length input</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   exp_by_squaring_spec mul_spec square_spec identity
     (firstn (S n) input)) 
  (seq <span class="mi">0</span> t) ++
[<span class="kr">if</span> nth t input d
 <span class="kr">then</span>
  mul_spec
    (square_spec
       (exp_by_squaring_spec mul_spec square_spec
          identity (firstn t input)))
 <span class="kr">else</span>
  square_spec
    (exp_by_squaring_spec mul_spec square_spec
       identity (firstn t input))] =
map
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   exp_by_squaring_spec mul_spec square_spec identity
     (firstn (S n) input)) 
  (seq <span class="mi">0</span> t) ++
[exp_by_squaring_spec mul_spec square_spec identity
   (firstn t input ++ [nth t input d])] /\
(<span class="kr">if</span> nth t input d
 <span class="kr">then</span>
  mul_spec
    (square_spec
       (exp_by_squaring_spec mul_spec square_spec
          identity (firstn t input)))
 <span class="kr">else</span>
  square_spec
    (exp_by_squaring_spec mul_spec square_spec
       identity (firstn t input))) =
exp_by_squaring_spec mul_spec square_spec identity
  (firstn t input ++ [nth t input d])</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk20"><span class="highlight"><span class="nb">cbv</span> [exp_by_squaring_spec].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SignalType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">mul_spec, square_spec</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A -&gt; combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">identity</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square, multiply</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Circuit (combType A) (combType A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : circuit_state square)
  (<span class="nv">i</span> : combType A),
step square st i =
(square_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">multiply_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span>
  (<span class="nv">st</span> : circuit_state multiply)
  (<span class="nv">i</span> : combType A),
step multiply st i =
(mul_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bodyst</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state
  (Second
     (square &gt;==&gt; Comb fork2 &gt;==&gt;
      Second multiply) &gt;==&gt;
   Comb (uncurry mux2 &gt;=&gt; fork2))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType Bit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t &lt; Datatypes.length input</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   fold_left
     (<span class="kr">fun</span> (<span class="nv">r</span> : combType A) (<span class="nv">bit</span> : bool) =&gt;
      <span class="kr">if</span> bit
      <span class="kr">then</span> mul_spec (square_spec r)
      <span class="kr">else</span> square_spec r) 
     (firstn (S n) input) identity) 
  (seq <span class="mi">0</span> t) ++
[<span class="kr">if</span> nth t input d
 <span class="kr">then</span>
  mul_spec
    (square_spec
       (fold_left
          (<span class="kr">fun</span> (<span class="nv">r</span> : combType A) (<span class="nv">bit</span> : bool) =&gt;
           <span class="kr">if</span> bit
           <span class="kr">then</span> mul_spec (square_spec r)
           <span class="kr">else</span> square_spec r) 
          (firstn t input) identity))
 <span class="kr">else</span>
  square_spec
    (fold_left
       (<span class="kr">fun</span> (<span class="nv">r</span> : combType A) (<span class="nv">bit</span> : bool) =&gt;
        <span class="kr">if</span> bit
        <span class="kr">then</span> mul_spec (square_spec r)
        <span class="kr">else</span> square_spec r) 
       (firstn t input) identity)] =
map
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   fold_left
     (<span class="kr">fun</span> (<span class="nv">r</span> : combType A) (<span class="nv">bit</span> : bool) =&gt;
      <span class="kr">if</span> bit
      <span class="kr">then</span> mul_spec (square_spec r)
      <span class="kr">else</span> square_spec r) 
     (firstn (S n) input) identity) 
  (seq <span class="mi">0</span> t) ++
[fold_left
   (<span class="kr">fun</span> (<span class="nv">r</span> : combType A) (<span class="nv">bit</span> : bool) =&gt;
    <span class="kr">if</span> bit
    <span class="kr">then</span> mul_spec (square_spec r)
    <span class="kr">else</span> square_spec r)
   (firstn t input ++ [nth t input d]) identity] /\
(<span class="kr">if</span> nth t input d
 <span class="kr">then</span>
  mul_spec
    (square_spec
       (fold_left
          (<span class="kr">fun</span> (<span class="nv">r</span> : combType A) (<span class="nv">bit</span> : bool) =&gt;
           <span class="kr">if</span> bit
           <span class="kr">then</span> mul_spec (square_spec r)
           <span class="kr">else</span> square_spec r) 
          (firstn t input) identity))
 <span class="kr">else</span>
  square_spec
    (fold_left
       (<span class="kr">fun</span> (<span class="nv">r</span> : combType A) (<span class="nv">bit</span> : bool) =&gt;
        <span class="kr">if</span> bit
        <span class="kr">then</span> mul_spec (square_spec r)
        <span class="kr">else</span> square_spec r) 
       (firstn t input) identity)) =
fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType A) (<span class="nv">bit</span> : bool) =&gt;
   <span class="kr">if</span> bit
   <span class="kr">then</span> mul_spec (square_spec r)
   <span class="kr">else</span> square_spec r)
  (firstn t input ++ [nth t input d]) identity</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk21"><span class="highlight"><span class="nb">autorewrite with</span> push_list_fold.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SignalType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">mul_spec, square_spec</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A -&gt; combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">identity</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square, multiply</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Circuit (combType A) (combType A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : circuit_state square)
  (<span class="nv">i</span> : combType A),
step square st i =
(square_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">multiply_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span>
  (<span class="nv">st</span> : circuit_state multiply)
  (<span class="nv">i</span> : combType A),
step multiply st i =
(mul_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bodyst</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state
  (Second
     (square &gt;==&gt; Comb fork2 &gt;==&gt;
      Second multiply) &gt;==&gt;
   Comb (uncurry mux2 &gt;=&gt; fork2))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType Bit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t &lt; Datatypes.length input</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   fold_left
     (<span class="kr">fun</span> (<span class="nv">r</span> : combType A) (<span class="nv">bit</span> : bool) =&gt;
      <span class="kr">if</span> bit
      <span class="kr">then</span> mul_spec (square_spec r)
      <span class="kr">else</span> square_spec r) 
     (firstn (S n) input) identity) 
  (seq <span class="mi">0</span> t) ++
[<span class="kr">if</span> nth t input d
 <span class="kr">then</span>
  mul_spec
    (square_spec
       (fold_left
          (<span class="kr">fun</span> (<span class="nv">r</span> : combType A) (<span class="nv">bit</span> : bool) =&gt;
           <span class="kr">if</span> bit
           <span class="kr">then</span> mul_spec (square_spec r)
           <span class="kr">else</span> square_spec r) 
          (firstn t input) identity))
 <span class="kr">else</span>
  square_spec
    (fold_left
       (<span class="kr">fun</span> (<span class="nv">r</span> : combType A) (<span class="nv">bit</span> : bool) =&gt;
        <span class="kr">if</span> bit
        <span class="kr">then</span> mul_spec (square_spec r)
        <span class="kr">else</span> square_spec r) 
       (firstn t input) identity)] =
map
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   fold_left
     (<span class="kr">fun</span> (<span class="nv">r</span> : combType A) (<span class="nv">bit</span> : bool) =&gt;
      <span class="kr">if</span> bit
      <span class="kr">then</span> mul_spec (square_spec r)
      <span class="kr">else</span> square_spec r) 
     (firstn (S n) input) identity) 
  (seq <span class="mi">0</span> t) ++
[<span class="kr">if</span> nth t input d
 <span class="kr">then</span>
  mul_spec
    (square_spec
       (fold_left
          (<span class="kr">fun</span> (<span class="nv">r</span> : combType A) (<span class="nv">bit</span> : bool) =&gt;
           <span class="kr">if</span> bit
           <span class="kr">then</span> mul_spec (square_spec r)
           <span class="kr">else</span> square_spec r) 
          (firstn t input) identity))
 <span class="kr">else</span>
  square_spec
    (fold_left
       (<span class="kr">fun</span> (<span class="nv">r</span> : combType A) (<span class="nv">bit</span> : bool) =&gt;
        <span class="kr">if</span> bit
        <span class="kr">then</span> mul_spec (square_spec r)
        <span class="kr">else</span> square_spec r) 
       (firstn t input) identity)] /\
(<span class="kr">if</span> nth t input d
 <span class="kr">then</span>
  mul_spec
    (square_spec
       (fold_left
          (<span class="kr">fun</span> (<span class="nv">r</span> : combType A) (<span class="nv">bit</span> : bool) =&gt;
           <span class="kr">if</span> bit
           <span class="kr">then</span> mul_spec (square_spec r)
           <span class="kr">else</span> square_spec r) 
          (firstn t input) identity))
 <span class="kr">else</span>
  square_spec
    (fold_left
       (<span class="kr">fun</span> (<span class="nv">r</span> : combType A) (<span class="nv">bit</span> : bool) =&gt;
        <span class="kr">if</span> bit
        <span class="kr">then</span> mul_spec (square_spec r)
        <span class="kr">else</span> square_spec r) 
       (firstn t input) identity)) =
(<span class="kr">if</span> nth t input d
 <span class="kr">then</span>
  mul_spec
    (square_spec
       (fold_left
          (<span class="kr">fun</span> (<span class="nv">r</span> : combType A) (<span class="nv">bit</span> : bool) =&gt;
           <span class="kr">if</span> bit
           <span class="kr">then</span> mul_spec (square_spec r)
           <span class="kr">else</span> square_spec r) 
          (firstn t input) identity))
 <span class="kr">else</span>
  square_spec
    (fold_left
       (<span class="kr">fun</span> (<span class="nv">r</span> : combType A) (<span class="nv">bit</span> : bool) =&gt;
        <span class="kr">if</span> bit
        <span class="kr">then</span> mul_spec (square_spec r)
        <span class="kr">else</span> square_spec r) 
       (firstn t input) identity))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">split</span>; <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk22"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SignalType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">mul_spec, square_spec</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A -&gt; combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">identity</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square, multiply</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Circuit (combType A) (combType A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : circuit_state square)
  (<span class="nv">i</span> : combType A),
step square st i =
(square_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">multiply_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span>
  (<span class="nv">st</span> : circuit_state multiply)
  (<span class="nv">i</span> : combType A),
step multiply st i =
(mul_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">acc</span> : list (combType A)) (<span class="nv">st</span> : combType A),
circuit_state
  (Second
     (square &gt;==&gt; Comb fork2 &gt;==&gt; Second multiply) &gt;==&gt;
   Comb (uncurry mux2 &gt;=&gt; fork2)) -&gt;
acc =
map
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   exp_by_squaring_spec mul_spec square_spec identity
     (firstn (S n) input))
  (seq <span class="mi">0</span> (Datatypes.length input)) /\
st =
exp_by_squaring_spec mul_spec square_spec identity
  (firstn (Datatypes.length input) input) -&gt;
acc =
map
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   exp_by_squaring_spec mul_spec square_spec identity
     (firstn (S n) input))
  (seq <span class="mi">0</span> (Datatypes.length input))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk23"><span class="highlight">{ <span class="c">(* invariant implies postcondition *)</span></span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SignalType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">mul_spec, square_spec</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A -&gt; combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">identity</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square, multiply</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Circuit (combType A) (combType A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : circuit_state square)
  (<span class="nv">i</span> : combType A),
step square st i =
(square_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">multiply_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span>
  (<span class="nv">st</span> : circuit_state multiply)
  (<span class="nv">i</span> : combType A),
step multiply st i =
(mul_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">acc</span> : list (combType A)) (<span class="nv">st</span> : combType A),
circuit_state
  (Second
     (square &gt;==&gt; Comb fork2 &gt;==&gt; Second multiply) &gt;==&gt;
   Comb (uncurry mux2 &gt;=&gt; fork2)) -&gt;
acc =
map
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   exp_by_squaring_spec mul_spec square_spec identity
     (firstn (S n) input))
  (seq <span class="mi">0</span> (Datatypes.length input)) /\
st =
exp_by_squaring_spec mul_spec square_spec identity
  (firstn (Datatypes.length input) input) -&gt;
acc =
map
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   exp_by_squaring_spec mul_spec square_spec identity
     (firstn (S n) input))
  (seq <span class="mi">0</span> (Datatypes.length input))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk24"><span class="highlight"><span class="nb">intros</span>; logical_simplify; <span class="nb">subst</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SignalType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">mul_spec, square_spec</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A -&gt; combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">identity</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square, multiply</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Circuit (combType A) (combType A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">square_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : circuit_state square)
  (<span class="nv">i</span> : combType A),
step square st i =
(square_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">multiply_correct</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span>
  (<span class="nv">st</span> : circuit_state multiply)
  (<span class="nv">i</span> : combType A),
step multiply st i =
(mul_spec i, st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bodyst</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state
  (Second
     (square &gt;==&gt; Comb fork2 &gt;==&gt;
      Second multiply) &gt;==&gt;
   Comb (uncurry mux2 &gt;=&gt; fork2))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   exp_by_squaring_spec mul_spec square_spec identity
     (firstn (S n) input))
  (seq <span class="mi">0</span> (Datatypes.length input)) =
map
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   exp_by_squaring_spec mul_spec square_spec identity
     (firstn (S n) input))
  (seq <span class="mi">0</span> (Datatypes.length input))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">}</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>From here, we no longer have to reason about the exponentiation-by-squaring
circuit; we can use this lemma to prove all our other circuits are
correct. Instead, we can reason about <tt class="docutils literal">exp_by_squaring_spec</tt>, with no
circuit-related reasoning. For example, to prove the <tt class="docutils literal">count_ones</tt> circuit
correct, we first prove that our specification (which is based on the Coq
standard library definition <tt class="docutils literal">count_occ</tt>) matches <tt class="docutils literal">exp_by_squaring_spec</tt>.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight"><span class="c">(* helper lemma proving that count_occ is a specialization of</span>
<span class="c">   exp_by_squaring_spec *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk25"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">count_occ_is_exp_by_squaring</span> <span class="nv">n</span> <span class="nv">l</span> <span class="nv">start</span> :
  exp_by_squaring_spec
    (A:=combType (Vec Bit n))
    (<span class="kr">fun</span> <span class="nv">v</span> =&gt; N2Bv_sized n (Bv2N v + <span class="mi">1</span>)) (<span class="kr">fun</span> <span class="nv">v</span> =&gt; v)
    (N2Bv_sized n start) l
  = N2Bv_sized n (N.of_nat (count_occ bool_dec l true) + start).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">start</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">exp_by_squaring_spec
  (<span class="kr">fun</span> <span class="nv">v</span> : combType (Vec Bit n) =&gt;
   N2Bv_sized n (Bv2N v + <span class="mi">1</span>))
  (<span class="kr">fun</span> <span class="nv">v</span> : combType (Vec Bit n) =&gt; v)
  (N2Bv_sized n start) l =
N2Bv_sized n
  (N.of_nat (count_occ bool_dec l true) + start)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk26"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">start</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">exp_by_squaring_spec
  (<span class="kr">fun</span> <span class="nv">v</span> : combType (Vec Bit n) =&gt;
   N2Bv_sized n (Bv2N v + <span class="mi">1</span>))
  (<span class="kr">fun</span> <span class="nv">v</span> : combType (Vec Bit n) =&gt; v)
  (N2Bv_sized n start) l =
N2Bv_sized n
  (N.of_nat (count_occ bool_dec l true) + start)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk27"><span class="highlight"><span class="nb">cbv</span> [exp_by_squaring_spec].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">start</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool) =&gt;
   <span class="kr">if</span> bit <span class="kr">then</span> N2Bv_sized n (Bv2N r + <span class="mi">1</span>) <span class="kr">else</span> r) l
  (N2Bv_sized n start) =
N2Bv_sized n
  (N.of_nat (count_occ bool_dec l true) + start)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk28"><span class="highlight"><span class="nb">revert</span> start.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">start</span> : N,
fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool) =&gt;
   <span class="kr">if</span> bit <span class="kr">then</span> N2Bv_sized n (Bv2N r + <span class="mi">1</span>) <span class="kr">else</span> r) l
  (N2Bv_sized n start) =
N2Bv_sized n
  (N.of_nat (count_occ bool_dec l true) + start)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk29"><span class="highlight"><span class="nb">induction</span> l <span class="kr">as</span> [|bit l]; [ <span class="bp">reflexivity</span> | ].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bit</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">start</span> : N,
fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool)
   =&gt;
   <span class="kr">if</span> bit <span class="kr">then</span> N2Bv_sized n (Bv2N r + <span class="mi">1</span>) <span class="kr">else</span> r)
  l (N2Bv_sized n start) =
N2Bv_sized n
  (N.of_nat (count_occ bool_dec l true) + start)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">start</span> : N,
fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool) =&gt;
   <span class="kr">if</span> bit <span class="kr">then</span> N2Bv_sized n (Bv2N r + <span class="mi">1</span>) <span class="kr">else</span> r)
  (bit :: l) (N2Bv_sized n start) =
N2Bv_sized n
  (N.of_nat (count_occ bool_dec (bit :: l) true) +
   start)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk2a"><span class="highlight"><span class="nb">intros</span>; <span class="nb">cbn</span> [count_occ fold_left].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bit</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">start</span> : N,
fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool)
   =&gt;
   <span class="kr">if</span> bit <span class="kr">then</span> N2Bv_sized n (Bv2N r + <span class="mi">1</span>) <span class="kr">else</span> r)
  l (N2Bv_sized n start) =
N2Bv_sized n
  (N.of_nat (count_occ bool_dec l true) + start)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">start</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool) =&gt;
   <span class="kr">if</span> bit <span class="kr">then</span> N2Bv_sized n (Bv2N r + <span class="mi">1</span>) <span class="kr">else</span> r) l
  (<span class="kr">if</span> bit
   <span class="kr">then</span> N2Bv_sized n (Bv2N (N2Bv_sized n start) + <span class="mi">1</span>)
   <span class="kr">else</span> N2Bv_sized n start) =
N2Bv_sized n
  (N.of_nat
     (<span class="kr">if</span> bool_dec bit true
      <span class="kr">then</span> S (count_occ bool_dec l true)
      <span class="kr">else</span> count_occ bool_dec l true) + start)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk2b"><span class="highlight"><span class="nb">destruct</span> bit; destruct_one_match; <span class="kp">try</span> <span class="bp">congruence</span>; [ ].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">start</span> : N,
fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool)
   =&gt;
   <span class="kr">if</span> bit <span class="kr">then</span> N2Bv_sized n (Bv2N r + <span class="mi">1</span>) <span class="kr">else</span> r)
  l (N2Bv_sized n start) =
N2Bv_sized n
  (N.of_nat (count_occ bool_dec l true) + start)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">start</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">true = true</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool) =&gt;
   <span class="kr">if</span> bit <span class="kr">then</span> N2Bv_sized n (Bv2N r + <span class="mi">1</span>) <span class="kr">else</span> r) l
  (N2Bv_sized n (Bv2N (N2Bv_sized n start) + <span class="mi">1</span>)) =
N2Bv_sized n
  (N.of_nat (S (count_occ bool_dec l true)) + start)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk2c"><span class="highlight"><span class="nb">rewrite</span> N2Bv_sized_add_idemp_l.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">start</span> : N,
fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool)
   =&gt;
   <span class="kr">if</span> bit <span class="kr">then</span> N2Bv_sized n (Bv2N r + <span class="mi">1</span>) <span class="kr">else</span> r)
  l (N2Bv_sized n start) =
N2Bv_sized n
  (N.of_nat (count_occ bool_dec l true) + start)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">start</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">true = true</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool) =&gt;
   <span class="kr">if</span> bit <span class="kr">then</span> N2Bv_sized n (Bv2N r + <span class="mi">1</span>) <span class="kr">else</span> r) l
  (N2Bv_sized n (start + <span class="mi">1</span>)) =
N2Bv_sized n
  (N.of_nat (S (count_occ bool_dec l true)) + start)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk2d"><span class="highlight"><span class="nb">rewrite</span> IHl.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">start</span> : N,
fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool)
   =&gt;
   <span class="kr">if</span> bit <span class="kr">then</span> N2Bv_sized n (Bv2N r + <span class="mi">1</span>) <span class="kr">else</span> r)
  l (N2Bv_sized n start) =
N2Bv_sized n
  (N.of_nat (count_occ bool_dec l true) + start)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">start</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">true = true</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N2Bv_sized n
  (N.of_nat (count_occ bool_dec l true) + (start + <span class="mi">1</span>)) =
N2Bv_sized n
  (N.of_nat (S (count_occ bool_dec l true)) + start)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk2e"><span class="highlight"><span class="nb">f_equal</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">start</span> : N,
fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool)
   =&gt;
   <span class="kr">if</span> bit <span class="kr">then</span> N2Bv_sized n (Bv2N r + <span class="mi">1</span>) <span class="kr">else</span> r)
  l (N2Bv_sized n start) =
N2Bv_sized n
  (N.of_nat (count_occ bool_dec l true) + start)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">start</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">true = true</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(N.of_nat (count_occ bool_dec l true) + (start + <span class="mi">1</span>))%N =
(N.of_nat (S (count_occ bool_dec l true)) + start)%N</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">lia</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>We can use this lemma to prove that, no matter how many timesteps we run or how
big our bit-vector is, the nth output of <tt class="docutils literal">count_ones</tt> will be the number of
<tt class="docutils literal">true</tt> values that appear in the first n bits of input, truncated to fit the
bit-vector size. Because we're doing all of this with inductive reasoning, it's
not at all computationally intensive to write such a proof.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk2f"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">count_ones_correct</span> <span class="nv">n</span> (<span class="nv">input</span> : list bool) :
  simulate (count_ones (n:=n)) input
  = map_stream
      (<span class="kr">fun</span> <span class="nv">l</span> =&gt; <span class="kr">let</span> <span class="nv">count</span> := count_occ bool_dec l true <span class="kr">in</span>
             N2Bv_sized n (N.of_nat count))
      input.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate count_ones input =
map_stream
  (<span class="kr">fun</span> <span class="nv">l</span> : list bool =&gt;
   <span class="kr">let</span> <span class="nv">count</span> := count_occ bool_dec l true <span class="kr">in</span>
   N2Bv_sized n (N.of_nat count)) input</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk30"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate count_ones input =
map_stream
  (<span class="kr">fun</span> <span class="nv">l</span> : list bool =&gt;
   <span class="kr">let</span> <span class="nv">count</span> := count_occ bool_dec l true <span class="kr">in</span>
   N2Bv_sized n (N.of_nat count)) input</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk31"><span class="highlight"><span class="nb">intros</span>; <span class="nb">cbv</span> [count_ones].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate
  (exp_by_squaring (Vec.of_N <span class="mi">0</span>) 
     (Comb ret) (Comb incrN)) input =
map_stream
  (<span class="kr">fun</span> <span class="nv">l</span> : list bool =&gt;
   N2Bv_sized n (N.of_nat (count_occ bool_dec l true)))
  input</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk32"><span class="highlight"><span class="nb">rewrite</span> exp_by_squaring_correct
    <span class="kr">with</span> (mul_spec:=<span class="kr">fun</span> <span class="nv">v</span> =&gt; N2Bv_sized n (Bv2N v + <span class="mi">1</span>))
         (square_spec := <span class="kr">fun</span> <span class="nv">v</span> : combType (Vec Bit n) =&gt; v)
    <span class="bp">by</span> (<span class="nb">cbn</span> [circuit_state step]; <span class="nb">intros</span>;
        <span class="kr">lazymatch goal with</span> x : unit |- _ =&gt; <span class="nb">destruct</span> x <span class="kr">end</span>;
        simpl_ident; <span class="bp">reflexivity</span>).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_stream
  (exp_by_squaring_spec
     (<span class="kr">fun</span> <span class="nv">v</span> : Bvector n =&gt; N2Bv_sized n (Bv2N v + <span class="mi">1</span>))
     (<span class="kr">fun</span> <span class="nv">v</span> : combType (Vec Bit n) =&gt; v) 
     (Vec.of_N <span class="mi">0</span>)) input =
map_stream
  (<span class="kr">fun</span> <span class="nv">l</span> : list bool =&gt;
   N2Bv_sized n (N.of_nat (count_occ bool_dec l true)))
  input</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk33"><span class="highlight"><span class="nb">apply</span> map_ext; <span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">exp_by_squaring_spec
  (<span class="kr">fun</span> <span class="nv">v</span> : Bvector n =&gt; N2Bv_sized n (Bv2N v + <span class="mi">1</span>))
  (<span class="kr">fun</span> <span class="nv">v</span> : combType (Vec Bit n) =&gt; v) 
  (Vec.of_N <span class="mi">0</span>) (firstn (S a) input) =
N2Bv_sized n
  (N.of_nat
     (count_occ bool_dec (firstn (S a) input) true))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk34"><span class="highlight">simpl_ident.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">exp_by_squaring_spec
  (<span class="kr">fun</span> <span class="nv">v</span> : Bvector n =&gt; N2Bv_sized n (Bv2N v + <span class="mi">1</span>))
  (<span class="kr">fun</span> <span class="nv">v</span> : combType (Vec Bit n) =&gt; v) 
  (N2Bv_sized n <span class="mi">0</span>) (firstn (S a) input) =
N2Bv_sized n
  (N.of_nat
     (count_occ bool_dec (firstn (S a) input) true))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk35"><span class="highlight"><span class="nb">rewrite</span> count_occ_is_exp_by_squaring.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N2Bv_sized n
  (N.of_nat
     (count_occ bool_dec (firstn (S a) input) true) +
   <span class="mi">0</span>) =
N2Bv_sized n
  (N.of_nat
     (count_occ bool_dec (firstn (S a) input) true))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">f_equal</span>; <span class="bp">lia</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>To prove that <tt class="docutils literal">stream_multiply</tt> is correct, we'll first have to prove the
single-step behavior of <tt class="docutils literal">double</tt> (to satisfy the <tt class="docutils literal">square_correct</tt>
precondition of <tt class="docutils literal">exp_by_squaring_correct</tt>). That proof is pretty quick:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk36"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">double_step</span> <span class="nv">n</span> <span class="nv">st</span> <span class="nv">i</span> :
  step double st i = (N2Bv_sized n (Bv2N i + Bv2N i), st).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">st</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state double</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">step double st i =
(N2Bv_sized n (Bv2N i + Bv2N i), st)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk37"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">st</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state double</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">step double st i =
(N2Bv_sized n (Bv2N i + Bv2N i), st)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk38"><span class="highlight"><span class="nb">cbv</span> [double step mcompose].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">st</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state double</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(x &lt;- Vec.cons zero i;; Vec.shiftout x, tt) =
(N2Bv_sized n (Bv2N i + Bv2N i), st)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk39"><span class="highlight">simpl_ident.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">st</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state double</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(Vector.shiftout (false :: i), tt) =
(N2Bv_sized n (Bv2N i + Bv2N i), st)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk3a"><span class="highlight"><span class="nb">rewrite</span> shiftout_cons0.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">st</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state double</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(N2Bv_sized n (<span class="mi">2</span> * Bv2N i), tt) =
(N2Bv_sized n (Bv2N i + Bv2N i), st)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk3b"><span class="highlight"><span class="nb">apply</span> f_equal2; [ | <span class="nb">destruct</span> st; <span class="bp">reflexivity</span> ].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">st</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state double</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N2Bv_sized n (<span class="mi">2</span> * Bv2N i) =
N2Bv_sized n (Bv2N i + Bv2N i)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk3c"><span class="highlight"><span class="nb">f_equal</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">st</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state double</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="mi">2</span> * Bv2N i)%N = (Bv2N i + Bv2N i)%N</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">lia</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>It's useful to write the inverse operation of <tt class="docutils literal">to_stream</tt> so that
we can talk about the numeric value that the input represents:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">from_stream</span> (<span class="nv">l</span> : list bool) : N :=
  Bv2N (Vector.of_list (rev l)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk3d"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">from_stream_cons</span> <span class="nv">bit</span> <span class="nv">l</span> :
  from_stream (bit :: l)
  = ((<span class="kr">if</span> bit <span class="kr">then</span> <span class="mi">2</span> ^ (N.of_nat (length l)) <span class="kr">else</span> <span class="mi">0</span>)
     + from_stream l)%N.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">bit</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">from_stream (bit :: l) =
((<span class="kr">if</span> bit <span class="kr">then</span> <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) <span class="kr">else</span> <span class="mi">0</span>) +
 from_stream l)%N</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk3e"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">bit</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">from_stream (bit :: l) =
((<span class="kr">if</span> bit <span class="kr">then</span> <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) <span class="kr">else</span> <span class="mi">0</span>) +
 from_stream l)%N</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk3f"><span class="highlight"><span class="nb">cbv</span> [from_stream].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">bit</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Bv2N (Vector.of_list (rev (bit :: l))) =
((<span class="kr">if</span> bit <span class="kr">then</span> <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) <span class="kr">else</span> <span class="mi">0</span>) +
 Bv2N (Vector.of_list (rev l)))%N</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk40"><span class="highlight"><span class="nb">cbn</span> [rev].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">bit</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Bv2N (Vector.of_list (rev l ++ [bit])) =
((<span class="kr">if</span> bit <span class="kr">then</span> <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) <span class="kr">else</span> <span class="mi">0</span>) +
 Bv2N (Vector.of_list (rev l)))%N</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk41"><span class="highlight"><span class="nb">rewrite</span> of_list_snoc.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">bit</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Bv2N
  (resize_default bit
     (Datatypes.length (rev l ++ [bit]))
     (Vector.of_list (rev l) ++ [bit]%vector)) =
((<span class="kr">if</span> bit <span class="kr">then</span> <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) <span class="kr">else</span> <span class="mi">0</span>) +
 Bv2N (Vector.of_list (rev l)))%N</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk42"><span class="highlight"><span class="nb">rewrite</span> app_length; <span class="nb">cbn</span> [length].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">bit</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Bv2N
  (resize_default bit (Datatypes.length (rev l) + <span class="mi">1</span>)
     (Vector.of_list (rev l) ++ [bit]%vector)) =
((<span class="kr">if</span> bit <span class="kr">then</span> <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) <span class="kr">else</span> <span class="mi">0</span>) +
 Bv2N (Vector.of_list (rev l)))%N</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk43"><span class="highlight"><span class="nb">rewrite</span> resize_default_id.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">bit</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Bv2N (Vector.of_list (rev l) ++ [bit])%vector =
((<span class="kr">if</span> bit <span class="kr">then</span> <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) <span class="kr">else</span> <span class="mi">0</span>) +
 Bv2N (Vector.of_list (rev l)))%N</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk44"><span class="highlight"><span class="nb">rewrite</span> Bv2N_snoc.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">bit</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">((<span class="kr">if</span> bit
  <span class="kr">then</span> <span class="mi">2</span> ^ N.of_nat (Datatypes.length (rev l))
  <span class="kr">else</span> <span class="mi">0</span>) + Bv2N (Vector.of_list (rev l)))%N =
((<span class="kr">if</span> bit <span class="kr">then</span> <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) <span class="kr">else</span> <span class="mi">0</span>) +
 Bv2N (Vector.of_list (rev l)))%N</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk45"><span class="highlight"><span class="nb">f_equal</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">bit</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">if</span> bit
 <span class="kr">then</span> (<span class="mi">2</span> ^ N.of_nat (Datatypes.length (rev l)))%N
 <span class="kr">else</span> <span class="mi">0</span>%N) =
(<span class="kr">if</span> bit
 <span class="kr">then</span> (<span class="mi">2</span> ^ N.of_nat (Datatypes.length l))%N
 <span class="kr">else</span> <span class="mi">0</span>%N)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">autorewrite with</span> push_length;
    <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>Now, just like for <tt class="docutils literal">count_ones</tt>, we prove that <tt class="docutils literal">exp_by_squaring_spec</tt>
corresponds to multiplication when given the right parameters. We do it in two
steps, because for the inductive logic to work out we have to reason about the
behavior of <tt class="docutils literal">exp_by_squaring_spec</tt> for <em>any</em> starting value, not just 0.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk46"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">multiply_is_exp_by_squaring&#39;</span> <span class="nv">n</span> <span class="nv">x</span> <span class="nv">l</span> <span class="nv">start</span> :
  exp_by_squaring_spec
    (A:=combType (Vec Bit n))
    (<span class="kr">fun</span> <span class="nv">v</span> =&gt; N2Bv_sized n (Bv2N v + x))
    (<span class="kr">fun</span> <span class="nv">v</span> =&gt; N2Bv_sized n (Bv2N v + Bv2N v))
    start l
  = N2Bv_sized n (Bv2N start * <span class="mi">2</span> ^ N.of_nat (length l)
                  + x * from_stream l).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">start</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">exp_by_squaring_spec
  (<span class="kr">fun</span> <span class="nv">v</span> : combType (Vec Bit n) =&gt;
   N2Bv_sized n (Bv2N v + x))
  (<span class="kr">fun</span> <span class="nv">v</span> : combType (Vec Bit n) =&gt;
   N2Bv_sized n (Bv2N v + Bv2N v)) start l =
N2Bv_sized n
  (Bv2N start * <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) +
   x * from_stream l)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk47"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">start</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">exp_by_squaring_spec
  (<span class="kr">fun</span> <span class="nv">v</span> : combType (Vec Bit n) =&gt;
   N2Bv_sized n (Bv2N v + x))
  (<span class="kr">fun</span> <span class="nv">v</span> : combType (Vec Bit n) =&gt;
   N2Bv_sized n (Bv2N v + Bv2N v)) start l =
N2Bv_sized n
  (Bv2N start * <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) +
   x * from_stream l)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk48"><span class="highlight"><span class="nb">cbv</span> [exp_by_squaring_spec].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">start</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool) =&gt;
   <span class="kr">if</span> bit
   <span class="kr">then</span>
    N2Bv_sized n
      (Bv2N (N2Bv_sized n (Bv2N r + Bv2N r)) + x)
   <span class="kr">else</span> N2Bv_sized n (Bv2N r + Bv2N r)) l start =
N2Bv_sized n
  (Bv2N start * <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) +
   x * from_stream l)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk49"><span class="highlight"><span class="nb">revert</span> start; <span class="nb">induction</span> l.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">start</span> : combType (Vec Bit n),
fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool) =&gt;
   <span class="kr">if</span> bit
   <span class="kr">then</span>
    N2Bv_sized n
      (Bv2N (N2Bv_sized n (Bv2N r + Bv2N r)) + x)
   <span class="kr">else</span> N2Bv_sized n (Bv2N r + Bv2N r)) [] start =
N2Bv_sized n
  (Bv2N start * <span class="mi">2</span> ^ N.of_nat (Datatypes.length []) +
   x * from_stream [])</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="expbysquaring-v-chk4a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">start</span> : combType (Vec Bit n),
fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool)
   =&gt;
   <span class="kr">if</span> bit
   <span class="kr">then</span>
    N2Bv_sized n
      (Bv2N (N2Bv_sized n (Bv2N r + Bv2N r)) + x)
   <span class="kr">else</span> N2Bv_sized n (Bv2N r + Bv2N r)) l start =
N2Bv_sized n
  (Bv2N start *
   <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) +
   x * from_stream l)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="expbysquaring-v-chk4a"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">start</span> : combType (Vec Bit n),
fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool) =&gt;
   <span class="kr">if</span> bit
   <span class="kr">then</span>
    N2Bv_sized n
      (Bv2N (N2Bv_sized n (Bv2N r + Bv2N r)) + x)
   <span class="kr">else</span> N2Bv_sized n (Bv2N r + Bv2N r)) 
  (a :: l) start =
N2Bv_sized n
  (Bv2N start *
   <span class="mi">2</span> ^ N.of_nat (Datatypes.length (a :: l)) +
   x * from_stream (a :: l))</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk4b"><span class="highlight">{</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">start</span> : combType (Vec Bit n),
fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool) =&gt;
   <span class="kr">if</span> bit
   <span class="kr">then</span>
    N2Bv_sized n
      (Bv2N (N2Bv_sized n (Bv2N r + Bv2N r)) + x)
   <span class="kr">else</span> N2Bv_sized n (Bv2N r + Bv2N r)) [] start =
N2Bv_sized n
  (Bv2N start * <span class="mi">2</span> ^ N.of_nat (Datatypes.length []) +
   x * from_stream [])</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk4c"><span class="highlight"><span class="nb">intros</span>; <span class="nb">cbn</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">start</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">start = N2Bv_sized n (Bv2N start * <span class="mi">1</span> + x * <span class="mi">0</span>)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk4d"><span class="highlight"><span class="nb">rewrite</span> N.mul_0_r, N.add_0_r, N.mul_1_r.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">start</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">start = N2Bv_sized n (Bv2N start)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">rewrite</span> N2Bv_sized_Bv2N; <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk4e"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">start</span> : combType (Vec Bit n),
fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool)
   =&gt;
   <span class="kr">if</span> bit
   <span class="kr">then</span>
    N2Bv_sized n
      (Bv2N (N2Bv_sized n (Bv2N r + Bv2N r)) + x)
   <span class="kr">else</span> N2Bv_sized n (Bv2N r + Bv2N r)) l start =
N2Bv_sized n
  (Bv2N start *
   <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) +
   x * from_stream l)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">start</span> : combType (Vec Bit n),
fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool) =&gt;
   <span class="kr">if</span> bit
   <span class="kr">then</span>
    N2Bv_sized n
      (Bv2N (N2Bv_sized n (Bv2N r + Bv2N r)) + x)
   <span class="kr">else</span> N2Bv_sized n (Bv2N r + Bv2N r)) 
  (a :: l) start =
N2Bv_sized n
  (Bv2N start *
   <span class="mi">2</span> ^ N.of_nat (Datatypes.length (a :: l)) +
   x * from_stream (a :: l))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk4f"><span class="highlight">{</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">start</span> : combType (Vec Bit n),
fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool)
   =&gt;
   <span class="kr">if</span> bit
   <span class="kr">then</span>
    N2Bv_sized n
      (Bv2N (N2Bv_sized n (Bv2N r + Bv2N r)) + x)
   <span class="kr">else</span> N2Bv_sized n (Bv2N r + Bv2N r)) l start =
N2Bv_sized n
  (Bv2N start *
   <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) +
   x * from_stream l)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">start</span> : combType (Vec Bit n),
fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool) =&gt;
   <span class="kr">if</span> bit
   <span class="kr">then</span>
    N2Bv_sized n
      (Bv2N (N2Bv_sized n (Bv2N r + Bv2N r)) + x)
   <span class="kr">else</span> N2Bv_sized n (Bv2N r + Bv2N r)) 
  (a :: l) start =
N2Bv_sized n
  (Bv2N start *
   <span class="mi">2</span> ^ N.of_nat (Datatypes.length (a :: l)) +
   x * from_stream (a :: l))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk50"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">start</span> : combType (Vec Bit n),
fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool)
   =&gt;
   <span class="kr">if</span> bit
   <span class="kr">then</span>
    N2Bv_sized n
      (Bv2N (N2Bv_sized n (Bv2N r + Bv2N r)) + x)
   <span class="kr">else</span> N2Bv_sized n (Bv2N r + Bv2N r)) l start =
N2Bv_sized n
  (Bv2N start *
   <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) +
   x * from_stream l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">start</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool) =&gt;
   <span class="kr">if</span> bit
   <span class="kr">then</span>
    N2Bv_sized n
      (Bv2N (N2Bv_sized n (Bv2N r + Bv2N r)) + x)
   <span class="kr">else</span> N2Bv_sized n (Bv2N r + Bv2N r)) 
  (a :: l) start =
N2Bv_sized n
  (Bv2N start *
   <span class="mi">2</span> ^ N.of_nat (Datatypes.length (a :: l)) +
   x * from_stream (a :: l))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk51"><span class="highlight"><span class="nb">cbn</span> [fold_left].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">start</span> : combType (Vec Bit n),
fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool)
   =&gt;
   <span class="kr">if</span> bit
   <span class="kr">then</span>
    N2Bv_sized n
      (Bv2N (N2Bv_sized n (Bv2N r + Bv2N r)) + x)
   <span class="kr">else</span> N2Bv_sized n (Bv2N r + Bv2N r)) l start =
N2Bv_sized n
  (Bv2N start *
   <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) +
   x * from_stream l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">start</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool) =&gt;
   <span class="kr">if</span> bit
   <span class="kr">then</span>
    N2Bv_sized n
      (Bv2N (N2Bv_sized n (Bv2N r + Bv2N r)) + x)
   <span class="kr">else</span> N2Bv_sized n (Bv2N r + Bv2N r)) l
  (<span class="kr">if</span> a
   <span class="kr">then</span>
    N2Bv_sized n
      (Bv2N (N2Bv_sized n (Bv2N start + Bv2N start)) +
       x)
   <span class="kr">else</span> N2Bv_sized n (Bv2N start + Bv2N start)) =
N2Bv_sized n
  (Bv2N start *
   <span class="mi">2</span> ^ N.of_nat (Datatypes.length (a :: l)) +
   x * from_stream (a :: l))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk52"><span class="highlight"><span class="nb">rewrite</span> IHl.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">start</span> : combType (Vec Bit n),
fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool)
   =&gt;
   <span class="kr">if</span> bit
   <span class="kr">then</span>
    N2Bv_sized n
      (Bv2N (N2Bv_sized n (Bv2N r + Bv2N r)) + x)
   <span class="kr">else</span> N2Bv_sized n (Bv2N r + Bv2N r)) l start =
N2Bv_sized n
  (Bv2N start *
   <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) +
   x * from_stream l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">start</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N2Bv_sized n
  (Bv2N
     (<span class="kr">if</span> a
      <span class="kr">then</span>
       N2Bv_sized n
         (Bv2N
            (N2Bv_sized n (Bv2N start + Bv2N start)) +
          x)
      <span class="kr">else</span> N2Bv_sized n (Bv2N start + Bv2N start)) *
   <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) +
   x * from_stream l) =
N2Bv_sized n
  (Bv2N start *
   <span class="mi">2</span> ^ N.of_nat (Datatypes.length (a :: l)) +
   x * from_stream (a :: l))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk53"><span class="highlight"><span class="nb">rewrite</span> from_stream_cons.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">start</span> : combType (Vec Bit n),
fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool)
   =&gt;
   <span class="kr">if</span> bit
   <span class="kr">then</span>
    N2Bv_sized n
      (Bv2N (N2Bv_sized n (Bv2N r + Bv2N r)) + x)
   <span class="kr">else</span> N2Bv_sized n (Bv2N r + Bv2N r)) l start =
N2Bv_sized n
  (Bv2N start *
   <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) +
   x * from_stream l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">start</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N2Bv_sized n
  (Bv2N
     (<span class="kr">if</span> a
      <span class="kr">then</span>
       N2Bv_sized n
         (Bv2N
            (N2Bv_sized n (Bv2N start + Bv2N start)) +
          x)
      <span class="kr">else</span> N2Bv_sized n (Bv2N start + Bv2N start)) *
   <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) +
   x * from_stream l) =
N2Bv_sized n
  (Bv2N start *
   <span class="mi">2</span> ^ N.of_nat (Datatypes.length (a :: l)) +
   x *
   ((<span class="kr">if</span> a
     <span class="kr">then</span> (<span class="mi">2</span> ^ N.of_nat (Datatypes.length l))%N
     <span class="kr">else</span> <span class="mi">0</span>%N) + from_stream l))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk54"><span class="highlight"><span class="nb">cbn</span> [length].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">start</span> : combType (Vec Bit n),
fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool)
   =&gt;
   <span class="kr">if</span> bit
   <span class="kr">then</span>
    N2Bv_sized n
      (Bv2N (N2Bv_sized n (Bv2N r + Bv2N r)) + x)
   <span class="kr">else</span> N2Bv_sized n (Bv2N r + Bv2N r)) l start =
N2Bv_sized n
  (Bv2N start *
   <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) +
   x * from_stream l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">start</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N2Bv_sized n
  (Bv2N
     (<span class="kr">if</span> a
      <span class="kr">then</span>
       N2Bv_sized n
         (Bv2N
            (N2Bv_sized n (Bv2N start + Bv2N start)) +
          x)
      <span class="kr">else</span> N2Bv_sized n (Bv2N start + Bv2N start)) *
   <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) +
   x * from_stream l) =
N2Bv_sized n
  (Bv2N start * <span class="mi">2</span> ^ N.of_nat (S (Datatypes.length l)) +
   x *
   ((<span class="kr">if</span> a
     <span class="kr">then</span> (<span class="mi">2</span> ^ N.of_nat (Datatypes.length l))%N
     <span class="kr">else</span> <span class="mi">0</span>%N) + from_stream l))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk55"><span class="highlight"><span class="nb">rewrite</span> Nat2N.inj_succ, N.pow_succ_r&#39;.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">start</span> : combType (Vec Bit n),
fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool)
   =&gt;
   <span class="kr">if</span> bit
   <span class="kr">then</span>
    N2Bv_sized n
      (Bv2N (N2Bv_sized n (Bv2N r + Bv2N r)) + x)
   <span class="kr">else</span> N2Bv_sized n (Bv2N r + Bv2N r)) l start =
N2Bv_sized n
  (Bv2N start *
   <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) +
   x * from_stream l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">start</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N2Bv_sized n
  (Bv2N
     (<span class="kr">if</span> a
      <span class="kr">then</span>
       N2Bv_sized n
         (Bv2N
            (N2Bv_sized n (Bv2N start + Bv2N start)) +
          x)
      <span class="kr">else</span> N2Bv_sized n (Bv2N start + Bv2N start)) *
   <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) +
   x * from_stream l) =
N2Bv_sized n
  (Bv2N start *
   (<span class="mi">2</span> * <span class="mi">2</span> ^ N.of_nat (Datatypes.length l)) +
   x *
   ((<span class="kr">if</span> a
     <span class="kr">then</span> (<span class="mi">2</span> ^ N.of_nat (Datatypes.length l))%N
     <span class="kr">else</span> <span class="mi">0</span>%N) + from_stream l))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">destruct_one_match;
      <span class="nb">autorewrite with</span> pull_N2Bv_sized;
      <span class="kr">lazymatch goal with</span>
      | |- <span class="kp">context</span> [N2Bv_sized n (Bv2N (N2Bv_sized n <span class="nl">?x</span>) * <span class="nl">?y</span> + <span class="nl">?z</span>)] =&gt;
        <span class="nb">rewrite</span> &lt;-(N2Bv_sized_add_idemp_l _ _ z);
          <span class="nb">autorewrite with</span> pull_N2Bv_sized
      <span class="kr">end</span>;
      <span class="nb">apply</span> <span class="nb">f_equal</span>; <span class="bp">lia</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">}</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk56"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">multiply_is_exp_by_squaring</span> <span class="nv">n</span> <span class="nv">x</span> <span class="nv">l</span> :
  exp_by_squaring_spec
    (A:=combType (Vec Bit n))
    (<span class="kr">fun</span> <span class="nv">v</span> =&gt; N2Bv_sized n (Bv2N v + x))
    (<span class="kr">fun</span> <span class="nv">v</span> =&gt; N2Bv_sized n (Bv2N v + Bv2N v))
    (N2Bv_sized n <span class="mi">0</span>) l
  = N2Bv_sized n (x * from_stream l).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">exp_by_squaring_spec
  (<span class="kr">fun</span> <span class="nv">v</span> : combType (Vec Bit n) =&gt;
   N2Bv_sized n (Bv2N v + x))
  (<span class="kr">fun</span> <span class="nv">v</span> : combType (Vec Bit n) =&gt;
   N2Bv_sized n (Bv2N v + Bv2N v)) (N2Bv_sized n <span class="mi">0</span>) l =
N2Bv_sized n (x * from_stream l)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk57"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">exp_by_squaring_spec
  (<span class="kr">fun</span> <span class="nv">v</span> : combType (Vec Bit n) =&gt;
   N2Bv_sized n (Bv2N v + x))
  (<span class="kr">fun</span> <span class="nv">v</span> : combType (Vec Bit n) =&gt;
   N2Bv_sized n (Bv2N v + Bv2N v)) (N2Bv_sized n <span class="mi">0</span>) l =
N2Bv_sized n (x * from_stream l)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk58"><span class="highlight"><span class="nb">rewrite</span> multiply_is_exp_by_squaring&#39;.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N2Bv_sized n
  (Bv2N (N2Bv_sized n <span class="mi">0</span>) *
   <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) +
   x * from_stream l) =
N2Bv_sized n (x * from_stream l)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk59"><span class="highlight"><span class="nb">rewrite</span> Bv2N_N2Bv_sized_modulo, N.mod_0_l
    <span class="bp">by</span> (<span class="nb">apply</span> N.pow_nonzero; <span class="bp">lia</span>).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N2Bv_sized n
  (<span class="mi">0</span> * <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) +
   x * from_stream l) =
N2Bv_sized n (x * from_stream l)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">f_equal</span>; <span class="bp">lia</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>With that, we have all we need to prove <tt class="docutils literal">stream_multiply</tt> is always correct!</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk5a"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">stream_multiply_correct</span> <span class="nv">n</span> <span class="nv">x</span> (<span class="nv">input</span> : list bool) :
  simulate (stream_multiply (n:=n) x) input
  = map_stream
      (<span class="kr">fun</span> <span class="nv">i</span> =&gt; N2Bv_sized n (x * (from_stream i)))
      input.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate (stream_multiply x) input =
map_stream
  (<span class="kr">fun</span> <span class="nv">i</span> : list bool =&gt;
   N2Bv_sized n (x * from_stream i)) input</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk5b"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate (stream_multiply x) input =
map_stream
  (<span class="kr">fun</span> <span class="nv">i</span> : list bool =&gt;
   N2Bv_sized n (x * from_stream i)) input</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk5c"><span class="highlight"><span class="nb">intros</span>; <span class="nb">cbv</span> [stream_multiply].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate
  (exp_by_squaring (Vec.of_N <span class="mi">0</span>) double
     (Comb
        (<span class="kr">fun</span> <span class="nv">i</span> : combType (Vec Bit n) =&gt;
         addN (i, Vec.of_N x)))) input =
map_stream
  (<span class="kr">fun</span> <span class="nv">i</span> : list bool =&gt;
   N2Bv_sized n (x * from_stream i)) input</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk5d"><span class="highlight"><span class="nb">rewrite</span> @exp_by_squaring_correct
    <span class="kr">with</span> (A:=Vec Bit n)
         (mul_spec:=<span class="kr">fun</span> <span class="nv">v</span> =&gt; N2Bv_sized n (Bv2N v + x))
         (square_spec := <span class="kr">fun</span> <span class="nv">v</span> =&gt; N2Bv_sized n (Bv2N v + Bv2N v))
    <span class="bp">by</span> <span class="kp">first</span> [ <span class="kp">solve</span> [<span class="nb">apply</span> double_step]
             | <span class="nb">cbn</span> [circuit_state step]; <span class="nb">intros</span>; simpl_ident;
               <span class="kr">lazymatch goal with</span> x : unit |- _ =&gt; <span class="nb">destruct</span> x <span class="kr">end</span>;
               <span class="nb">rewrite</span> N2Bv_sized_add_idemp_r; <span class="bp">reflexivity</span> ].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_stream
  (exp_by_squaring_spec
     (<span class="kr">fun</span> <span class="nv">v</span> : Bvector n =&gt; N2Bv_sized n (Bv2N v + x))
     (<span class="kr">fun</span> <span class="nv">v</span> : Bvector n =&gt;
      N2Bv_sized n (Bv2N v + Bv2N v)) 
     (Vec.of_N <span class="mi">0</span>)) input =
map_stream
  (<span class="kr">fun</span> <span class="nv">i</span> : list bool =&gt;
   N2Bv_sized n (x * from_stream i)) input</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk5e"><span class="highlight"><span class="nb">apply</span> map_ext; <span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">exp_by_squaring_spec
  (<span class="kr">fun</span> <span class="nv">v</span> : Bvector n =&gt; N2Bv_sized n (Bv2N v + x))
  (<span class="kr">fun</span> <span class="nv">v</span> : Bvector n =&gt; N2Bv_sized n (Bv2N v + Bv2N v))
  (Vec.of_N <span class="mi">0</span>) (firstn (S a) input) =
N2Bv_sized n (x * from_stream (firstn (S a) input))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk5f"><span class="highlight">simpl_ident.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">exp_by_squaring_spec
  (<span class="kr">fun</span> <span class="nv">v</span> : Bvector n =&gt; N2Bv_sized n (Bv2N v + x))
  (<span class="kr">fun</span> <span class="nv">v</span> : Bvector n =&gt; N2Bv_sized n (Bv2N v + Bv2N v))
  (N2Bv_sized n <span class="mi">0</span>) (firstn (S a) input) =
N2Bv_sized n (x * from_stream (firstn (S a) input))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> multiply_is_exp_by_squaring.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>Now, let's move on to <tt class="docutils literal">stream_exponentiate</tt>. We'll need to prove that
<tt class="docutils literal">mul_constN</tt> is correct first, and to prove that we'll need a proof for
<tt class="docutils literal">mul_const_pos</tt>. This proof goes by induction on <tt class="docutils literal">x</tt>:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk60"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">mul_const_pos_step</span> <span class="nv">n</span> <span class="nv">x</span> <span class="nv">st</span> <span class="nv">i</span> :
  step (mul_const_pos x) st i = (N2Bv_sized n (Bv2N i * Npos x), st).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">positive</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">st</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state (mul_const_pos x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">step (mul_const_pos x) st i =
(N2Bv_sized n (Bv2N i * N.pos x), st)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk61"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">positive</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">st</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state (mul_const_pos x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">step (mul_const_pos x) st i =
(N2Bv_sized n (Bv2N i * N.pos x), st)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk62"><span class="highlight"><span class="nb">revert</span> st i.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">positive</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : circuit_state (mul_const_pos x))
  (<span class="nv">i</span> : combType (Vec Bit n)),
step (mul_const_pos x) st i =
(N2Bv_sized n (Bv2N i * N.pos x), st)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk63"><span class="highlight"><span class="nb">induction</span> x; <span class="nb">cbn</span> [mul_const_pos circuit_state];
    <span class="nb">intros</span>; destruct_products;
    <span class="kp">repeat</span> <span class="kr">lazymatch goal with</span> x : unit |- _ =&gt; <span class="nb">destruct</span> x <span class="kr">end</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">positive</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHx</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : circuit_state (mul_const_pos x)) (<span class="nv">i</span> : combType (Vec Bit n)),
step (mul_const_pos x) st i = (N2Bv_sized n (Bv2N i * N.pos x), st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state (mul_const_pos x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state double</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">step
  (Comb fork2 &gt;==&gt; First (mul_const_pos x &gt;==&gt; double) &gt;==&gt;
   Comb addN) (tt, (c, c0), tt) i =
(N2Bv_sized n (Bv2N i * N.pos x~<span class="mi">1</span>), (tt, (c, c0), tt))</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="expbysquaring-v-chk64" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">positive</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHx</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : circuit_state (mul_const_pos x)) (<span class="nv">i</span> : combType (Vec Bit n)),
step (mul_const_pos x) st i = (N2Bv_sized n (Bv2N i * N.pos x), st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state (mul_const_pos x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state double</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="expbysquaring-v-chk64"><hr></label><div class="goal-conclusion"><span class="highlight">step (mul_const_pos x &gt;==&gt; double) (c, c0) i =
(N2Bv_sized n (Bv2N i * N.pos x~<span class="mi">0</span>), (c, c0))</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="expbysquaring-v-chk65" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="expbysquaring-v-chk65"><hr></label><div class="goal-conclusion"><span class="highlight">step (Comb ret) tt i = (N2Bv_sized n (Bv2N i * <span class="mi">1</span>), tt)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk66"><span class="highlight">{ <span class="c">(* x = y~1 *)</span></span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">positive</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHx</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : circuit_state (mul_const_pos x)) (<span class="nv">i</span> : combType (Vec Bit n)),
step (mul_const_pos x) st i = (N2Bv_sized n (Bv2N i * N.pos x), st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state (mul_const_pos x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state double</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">step
  (Comb fork2 &gt;==&gt; First (mul_const_pos x &gt;==&gt; double) &gt;==&gt;
   Comb addN) (tt, (c, c0), tt) i =
(N2Bv_sized n (Bv2N i * N.pos x~<span class="mi">1</span>), (tt, (c, c0), tt))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk67"><span class="highlight"><span class="nb">cbn</span> [step].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">positive</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHx</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : circuit_state (mul_const_pos x)) (<span class="nv">i</span> : combType (Vec Bit n)),
step (mul_const_pos x) st i = (N2Bv_sized n (Bv2N i * N.pos x), st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state (mul_const_pos x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state double</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">let</span>
 &#39;(x0, cs1) :=
  <span class="kr">let</span>
  &#39;(y, cs2) :=
   <span class="kr">let</span>
   &#39;(x0, cs&#39;) :=
    <span class="kr">let</span>
    &#39;(x0, cs1) :=
     step (mul_const_pos x)
       (fst (snd (fst (tt, (c, c0), tt))))
       (fst (fork2 i)) <span class="kr">in</span>
     <span class="kr">let</span>
     &#39;(y, cs2) :=
      step double (snd (snd (fst (tt, (c, c0), tt))))
        x0 <span class="kr">in</span> (y, (cs1, cs2)) <span class="kr">in</span>
    (x0, snd (fork2 i), cs&#39;) <span class="kr">in</span> (y, (tt, cs2)) <span class="kr">in</span>
  (addN x0, (cs1, tt))) =
(N2Bv_sized n (Bv2N i * N.pos x~<span class="mi">1</span>), (tt, (c, c0), tt))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk68"><span class="highlight"><span class="kp">repeat</span> (destruct_pair_let; <span class="nb">cbn</span> [fst snd]).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">positive</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHx</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : circuit_state (mul_const_pos x)) (<span class="nv">i</span> : combType (Vec Bit n)),
step (mul_const_pos x) st i = (N2Bv_sized n (Bv2N i * N.pos x), st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state (mul_const_pos x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state double</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(addN
   (fst
      (step double c0
         (fst
            (step (mul_const_pos x) c (fst (fork2 i))))),
   snd (fork2 i)),
(tt,
(snd (step (mul_const_pos x) c (fst (fork2 i))),
snd
  (step double c0
     (fst (step (mul_const_pos x) c (fst (fork2 i)))))),
tt)) =
(N2Bv_sized n (Bv2N i * N.pos x~<span class="mi">1</span>), (tt, (c, c0), tt))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk69"><span class="highlight">simpl_ident.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">positive</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHx</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : circuit_state (mul_const_pos x)) (<span class="nv">i</span> : combType (Vec Bit n)),
step (mul_const_pos x) st i = (N2Bv_sized n (Bv2N i * N.pos x), st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state (mul_const_pos x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state double</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(N2Bv_sized n
   (Bv2N
      (fst
         (step double c0
            (fst (step (mul_const_pos x) c i)))) +
    Bv2N i),
(tt,
(snd (step (mul_const_pos x) c i),
snd
  (step double c0 (fst (step (mul_const_pos x) c i)))),
tt)) =
(N2Bv_sized n (Bv2N i * N.pos x~<span class="mi">1</span>), (tt, (c, c0), tt))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk6a"><span class="highlight"><span class="nb">rewrite</span> double_step, IHx.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">positive</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHx</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : circuit_state (mul_const_pos x)) (<span class="nv">i</span> : combType (Vec Bit n)),
step (mul_const_pos x) st i = (N2Bv_sized n (Bv2N i * N.pos x), st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state (mul_const_pos x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state double</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(N2Bv_sized n
   (Bv2N
      (fst
         (N2Bv_sized n
            (Bv2N
               (fst
                  (N2Bv_sized n (Bv2N i * N.pos x), c)) +
             Bv2N
               (fst
                  (N2Bv_sized n (Bv2N i * N.pos x), c))),
         c0)) + Bv2N i),
(tt,
(snd (N2Bv_sized n (Bv2N i * N.pos x), c),
snd
  (N2Bv_sized n
     (Bv2N (fst (N2Bv_sized n (Bv2N i * N.pos x), c)) +
      Bv2N (fst (N2Bv_sized n (Bv2N i * N.pos x), c))),
  c0)), tt)) =
(N2Bv_sized n (Bv2N i * N.pos x~<span class="mi">1</span>), (tt, (c, c0), tt))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk6b"><span class="highlight"><span class="nb">cbn</span> [fst snd].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">positive</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHx</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : circuit_state (mul_const_pos x)) (<span class="nv">i</span> : combType (Vec Bit n)),
step (mul_const_pos x) st i = (N2Bv_sized n (Bv2N i * N.pos x), st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state (mul_const_pos x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state double</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(N2Bv_sized n
   (Bv2N
      (N2Bv_sized n
         (Bv2N (N2Bv_sized n (Bv2N i * N.pos x)) +
          Bv2N (N2Bv_sized n (Bv2N i * N.pos x)))) +
    Bv2N i), (tt, (c, c0), tt)) =
(N2Bv_sized n (Bv2N i * N.pos x~<span class="mi">1</span>), (tt, (c, c0), tt))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk6c"><span class="highlight"><span class="nb">f_equal</span>; [ ].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">positive</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHx</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : circuit_state (mul_const_pos x)) (<span class="nv">i</span> : combType (Vec Bit n)),
step (mul_const_pos x) st i = (N2Bv_sized n (Bv2N i * N.pos x), st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state (mul_const_pos x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state double</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N2Bv_sized n
  (Bv2N
     (N2Bv_sized n
        (Bv2N (N2Bv_sized n (Bv2N i * N.pos x)) +
         Bv2N (N2Bv_sized n (Bv2N i * N.pos x)))) +
   Bv2N i) = N2Bv_sized n (Bv2N i * N.pos x~<span class="mi">1</span>)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk6d"><span class="highlight"><span class="nb">autorewrite with</span> pull_N2Bv_sized.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">positive</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHx</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : circuit_state (mul_const_pos x)) (<span class="nv">i</span> : combType (Vec Bit n)),
step (mul_const_pos x) st i = (N2Bv_sized n (Bv2N i * N.pos x), st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state (mul_const_pos x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state double</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N2Bv_sized n
  (Bv2N (N2Bv_sized n (Bv2N i * N.pos x)) +
   Bv2N (N2Bv_sized n (Bv2N i * N.pos x)) + Bv2N i) =
N2Bv_sized n (Bv2N i * N.pos x~<span class="mi">1</span>)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk6e"><span class="highlight"><span class="kp">repeat</span> <span class="kr">lazymatch goal with</span>
           | |- <span class="kp">context</span>
                 [N2Bv_sized n (Bv2N (N2Bv_sized n <span class="nl">?x</span>) + <span class="nl">?y</span> + <span class="nl">?z</span>)] =&gt;
             <span class="nb">replace</span> (Bv2N (N2Bv_sized n x) + y + z)%N
               <span class="kr">with</span> (y + z + Bv2N (N2Bv_sized n x))%N <span class="bp">by</span> <span class="bp">lia</span>;
               <span class="nb">autorewrite with</span> pull_N2Bv_sized
           <span class="kr">end</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">positive</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHx</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : circuit_state (mul_const_pos x)) (<span class="nv">i</span> : combType (Vec Bit n)),
step (mul_const_pos x) st i = (N2Bv_sized n (Bv2N i * N.pos x), st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state (mul_const_pos x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state double</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N2Bv_sized n
  (Bv2N i + Bv2N i * N.pos x + Bv2N i * N.pos x) =
N2Bv_sized n (Bv2N i * N.pos x~<span class="mi">1</span>)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">f_equal</span>; <span class="bp">lia</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk6f"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">positive</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHx</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : circuit_state (mul_const_pos x)) (<span class="nv">i</span> : combType (Vec Bit n)),
step (mul_const_pos x) st i = (N2Bv_sized n (Bv2N i * N.pos x), st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state (mul_const_pos x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state double</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">step (mul_const_pos x &gt;==&gt; double) (c, c0) i =
(N2Bv_sized n (Bv2N i * N.pos x~<span class="mi">0</span>), (c, c0))</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="expbysquaring-v-chk70" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="expbysquaring-v-chk70"><hr></label><div class="goal-conclusion"><span class="highlight">step (Comb ret) tt i = (N2Bv_sized n (Bv2N i * <span class="mi">1</span>), tt)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk71"><span class="highlight">{ <span class="c">(* x = y~0 *)</span></span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">positive</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHx</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : circuit_state (mul_const_pos x)) (<span class="nv">i</span> : combType (Vec Bit n)),
step (mul_const_pos x) st i = (N2Bv_sized n (Bv2N i * N.pos x), st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state (mul_const_pos x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state double</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">step (mul_const_pos x &gt;==&gt; double) (c, c0) i =
(N2Bv_sized n (Bv2N i * N.pos x~<span class="mi">0</span>), (c, c0))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk72"><span class="highlight"><span class="nb">cbn</span> [step].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">positive</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHx</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : circuit_state (mul_const_pos x)) (<span class="nv">i</span> : combType (Vec Bit n)),
step (mul_const_pos x) st i = (N2Bv_sized n (Bv2N i * N.pos x), st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state (mul_const_pos x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state double</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">let</span>
 &#39;(x0, cs1) := step (mul_const_pos x) (fst (c, c0)) i
  <span class="kr">in</span>
  <span class="kr">let</span>
  &#39;(y, cs2) := step double (snd (c, c0)) x0 <span class="kr">in</span>
   (y, (cs1, cs2))) =
(N2Bv_sized n (Bv2N i * N.pos x~<span class="mi">0</span>), (c, c0))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk73"><span class="highlight"><span class="kp">repeat</span> (destruct_pair_let; <span class="nb">cbn</span> [fst snd]).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">positive</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHx</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : circuit_state (mul_const_pos x)) (<span class="nv">i</span> : combType (Vec Bit n)),
step (mul_const_pos x) st i = (N2Bv_sized n (Bv2N i * N.pos x), st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state (mul_const_pos x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state double</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(fst
   (step double c0 (fst (step (mul_const_pos x) c i))),
(snd (step (mul_const_pos x) c i),
snd
  (step double c0 (fst (step (mul_const_pos x) c i))))) =
(N2Bv_sized n (Bv2N i * N.pos x~<span class="mi">0</span>), (c, c0))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk74"><span class="highlight">simpl_ident.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">positive</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHx</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : circuit_state (mul_const_pos x)) (<span class="nv">i</span> : combType (Vec Bit n)),
step (mul_const_pos x) st i = (N2Bv_sized n (Bv2N i * N.pos x), st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state (mul_const_pos x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state double</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(fst
   (step double c0 (fst (step (mul_const_pos x) c i))),
(snd (step (mul_const_pos x) c i),
snd
  (step double c0 (fst (step (mul_const_pos x) c i))))) =
(N2Bv_sized n (Bv2N i * N.pos x~<span class="mi">0</span>), (c, c0))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk75"><span class="highlight"><span class="nb">rewrite</span> double_step, IHx.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">positive</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHx</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : circuit_state (mul_const_pos x)) (<span class="nv">i</span> : combType (Vec Bit n)),
step (mul_const_pos x) st i = (N2Bv_sized n (Bv2N i * N.pos x), st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state (mul_const_pos x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state double</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(fst
   (N2Bv_sized n
      (Bv2N (fst (N2Bv_sized n (Bv2N i * N.pos x), c)) +
       Bv2N (fst (N2Bv_sized n (Bv2N i * N.pos x), c))),
   c0),
(snd (N2Bv_sized n (Bv2N i * N.pos x), c),
snd
  (N2Bv_sized n
     (Bv2N (fst (N2Bv_sized n (Bv2N i * N.pos x), c)) +
      Bv2N (fst (N2Bv_sized n (Bv2N i * N.pos x), c))),
  c0))) = (N2Bv_sized n (Bv2N i * N.pos x~<span class="mi">0</span>), (c, c0))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk76"><span class="highlight"><span class="nb">cbn</span> [fst snd].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">positive</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHx</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : circuit_state (mul_const_pos x)) (<span class="nv">i</span> : combType (Vec Bit n)),
step (mul_const_pos x) st i = (N2Bv_sized n (Bv2N i * N.pos x), st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state (mul_const_pos x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state double</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(N2Bv_sized n
   (Bv2N (N2Bv_sized n (Bv2N i * N.pos x)) +
    Bv2N (N2Bv_sized n (Bv2N i * N.pos x))), (c, c0)) =
(N2Bv_sized n (Bv2N i * N.pos x~<span class="mi">0</span>), (c, c0))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk77"><span class="highlight"><span class="nb">f_equal</span>; [ ].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">positive</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHx</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : circuit_state (mul_const_pos x)) (<span class="nv">i</span> : combType (Vec Bit n)),
step (mul_const_pos x) st i = (N2Bv_sized n (Bv2N i * N.pos x), st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state (mul_const_pos x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state double</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N2Bv_sized n
  (Bv2N (N2Bv_sized n (Bv2N i * N.pos x)) +
   Bv2N (N2Bv_sized n (Bv2N i * N.pos x))) =
N2Bv_sized n (Bv2N i * N.pos x~<span class="mi">0</span>)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk78"><span class="highlight"><span class="nb">autorewrite with</span> pull_N2Bv_sized.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">positive</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHx</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">st</span> : circuit_state (mul_const_pos x)) (<span class="nv">i</span> : combType (Vec Bit n)),
step (mul_const_pos x) st i = (N2Bv_sized n (Bv2N i * N.pos x), st)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state (mul_const_pos x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state double</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N2Bv_sized n (Bv2N i * N.pos x + Bv2N i * N.pos x) =
N2Bv_sized n (Bv2N i * N.pos x~<span class="mi">0</span>)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">f_equal</span>; <span class="bp">lia</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk79"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">step (Comb ret) tt i = (N2Bv_sized n (Bv2N i * <span class="mi">1</span>), tt)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk7a"><span class="highlight">{ <span class="c">(* x = 1 *)</span></span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">step (Comb ret) tt i = (N2Bv_sized n (Bv2N i * <span class="mi">1</span>), tt)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk7b"><span class="highlight"><span class="nb">cbn</span> [step].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(ret i, tt) = (N2Bv_sized n (Bv2N i * <span class="mi">1</span>), tt)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk7c"><span class="highlight">simpl_ident.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(i, tt) = (N2Bv_sized n (Bv2N i * <span class="mi">1</span>), tt)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk7d"><span class="highlight"><span class="nb">rewrite</span> N.mul_1_r, N2Bv_sized_Bv2N.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(i, tt) = (i, tt)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">}</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk7e"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">mul_constN_step</span> <span class="nv">n</span> <span class="nv">x</span> <span class="nv">st</span> <span class="nv">i</span> :
  step (mul_constN x) st i = (N2Bv_sized n (Bv2N i * x), st).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">st</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state (mul_constN x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">step (mul_constN x) st i =
(N2Bv_sized n (Bv2N i * x), st)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk7f"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">st</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state (mul_constN x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">step (mul_constN x) st i =
(N2Bv_sized n (Bv2N i * x), st)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk80"><span class="highlight"><span class="nb">cbv</span> [mul_constN].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">st</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state (mul_constN x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">step
  <span class="kr">match</span> x <span class="kr">with</span>
  | <span class="mi">0</span>%N =&gt;
      Comb
        (<span class="kr">fun</span> <span class="nv">_</span> : combType (Vec Bit n) =&gt;
         ret (Vec.of_N <span class="mi">0</span>))
  | N.pos p =&gt; mul_const_pos p
  <span class="kr">end</span> st i = (N2Bv_sized n (Bv2N i * x), st)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk81"><span class="highlight"><span class="nb">destruct</span> x; [ | <span class="nb">apply</span> mul_const_pos_step ].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">st</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state (mul_constN <span class="mi">0</span>)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">step
  (Comb
     (<span class="kr">fun</span> <span class="nv">_</span> : combType (Vec Bit n) =&gt; ret (Vec.of_N <span class="mi">0</span>)))
  st i = (N2Bv_sized n (Bv2N i * <span class="mi">0</span>), st)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">  <span class="c">(* remaining case : x = 0 *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk82"><span class="highlight"><span class="nb">cbn</span> [step].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">st</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state (mul_constN <span class="mi">0</span>)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(ret (Vec.of_N <span class="mi">0</span>), tt) =
(N2Bv_sized n (Bv2N i * <span class="mi">0</span>), st)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk83"><span class="highlight"><span class="nb">destruct</span> st.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(ret (Vec.of_N <span class="mi">0</span>), tt) =
(N2Bv_sized n (Bv2N i * <span class="mi">0</span>), tt)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk84"><span class="highlight">simpl_ident.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(N2Bv_sized n <span class="mi">0</span>, tt) = (N2Bv_sized n (Bv2N i * <span class="mi">0</span>), tt)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk85"><span class="highlight"><span class="nb">rewrite</span> N.mul_0_r.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(N2Bv_sized n <span class="mi">0</span>, tt) = (N2Bv_sized n <span class="mi">0</span>, tt)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>Just like we did for <tt class="docutils literal">stream_multiply</tt>, we prove that exponentiation matches
<tt class="docutils literal">exp_by_squaring_spec</tt> - first for any start value, and then for a start value
of 1.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk86"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">exponentiate_is_exp_by_squaring&#39;</span> <span class="nv">n</span> <span class="nv">x</span> <span class="nv">l</span> <span class="nv">start</span> :
  exp_by_squaring_spec
    (A:=combType (Vec Bit n))
    (<span class="kr">fun</span> <span class="nv">v</span> =&gt; N2Bv_sized n (Bv2N v * x))
    (<span class="kr">fun</span> <span class="nv">v</span> =&gt; N2Bv_sized n (Bv2N v * Bv2N v))
    start l
  = N2Bv_sized n (Bv2N start ^ (<span class="mi">2</span> ^ N.of_nat (length l))
                  * x ^ from_stream l).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">start</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">exp_by_squaring_spec
  (<span class="kr">fun</span> <span class="nv">v</span> : combType (Vec Bit n) =&gt;
   N2Bv_sized n (Bv2N v * x))
  (<span class="kr">fun</span> <span class="nv">v</span> : combType (Vec Bit n) =&gt;
   N2Bv_sized n (Bv2N v * Bv2N v)) start l =
N2Bv_sized n
  (Bv2N start ^ <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) *
   x ^ from_stream l)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk87"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">start</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">exp_by_squaring_spec
  (<span class="kr">fun</span> <span class="nv">v</span> : combType (Vec Bit n) =&gt;
   N2Bv_sized n (Bv2N v * x))
  (<span class="kr">fun</span> <span class="nv">v</span> : combType (Vec Bit n) =&gt;
   N2Bv_sized n (Bv2N v * Bv2N v)) start l =
N2Bv_sized n
  (Bv2N start ^ <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) *
   x ^ from_stream l)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk88"><span class="highlight"><span class="nb">cbv</span> [exp_by_squaring_spec].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">start</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool) =&gt;
   <span class="kr">if</span> bit
   <span class="kr">then</span>
    N2Bv_sized n
      (Bv2N (N2Bv_sized n (Bv2N r * Bv2N r)) * x)
   <span class="kr">else</span> N2Bv_sized n (Bv2N r * Bv2N r)) l start =
N2Bv_sized n
  (Bv2N start ^ <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) *
   x ^ from_stream l)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk89"><span class="highlight"><span class="nb">revert</span> start; <span class="nb">induction</span> l.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">start</span> : combType (Vec Bit n),
fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool) =&gt;
   <span class="kr">if</span> bit
   <span class="kr">then</span>
    N2Bv_sized n
      (Bv2N (N2Bv_sized n (Bv2N r * Bv2N r)) * x)
   <span class="kr">else</span> N2Bv_sized n (Bv2N r * Bv2N r)) [] start =
N2Bv_sized n
  (Bv2N start ^ <span class="mi">2</span> ^ N.of_nat (Datatypes.length []) *
   x ^ from_stream [])</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="expbysquaring-v-chk8a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">start</span> : combType (Vec Bit n),
fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool)
   =&gt;
   <span class="kr">if</span> bit
   <span class="kr">then</span>
    N2Bv_sized n
      (Bv2N (N2Bv_sized n (Bv2N r * Bv2N r)) * x)
   <span class="kr">else</span> N2Bv_sized n (Bv2N r * Bv2N r)) l start =
N2Bv_sized n
  (Bv2N start
   ^ <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) *
   x ^ from_stream l)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="expbysquaring-v-chk8a"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">start</span> : combType (Vec Bit n),
fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool) =&gt;
   <span class="kr">if</span> bit
   <span class="kr">then</span>
    N2Bv_sized n
      (Bv2N (N2Bv_sized n (Bv2N r * Bv2N r)) * x)
   <span class="kr">else</span> N2Bv_sized n (Bv2N r * Bv2N r)) 
  (a :: l) start =
N2Bv_sized n
  (Bv2N start
   ^ <span class="mi">2</span> ^ N.of_nat (Datatypes.length (a :: l)) *
   x ^ from_stream (a :: l))</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk8b"><span class="highlight">{</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">start</span> : combType (Vec Bit n),
fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool) =&gt;
   <span class="kr">if</span> bit
   <span class="kr">then</span>
    N2Bv_sized n
      (Bv2N (N2Bv_sized n (Bv2N r * Bv2N r)) * x)
   <span class="kr">else</span> N2Bv_sized n (Bv2N r * Bv2N r)) [] start =
N2Bv_sized n
  (Bv2N start ^ <span class="mi">2</span> ^ N.of_nat (Datatypes.length []) *
   x ^ from_stream [])</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk8c"><span class="highlight"><span class="nb">intros</span>; <span class="nb">cbn</span> - [N.pow].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">start</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">start = N2Bv_sized n (Bv2N start ^ <span class="mi">2</span> ^ <span class="mi">0</span> * x ^ <span class="mi">0</span>)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk8d"><span class="highlight"><span class="nb">rewrite</span> !N.pow_0_r, N.pow_1_r, N.mul_1_r.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">start</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">start = N2Bv_sized n (Bv2N start)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">rewrite</span> N2Bv_sized_Bv2N; <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk8e"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">start</span> : combType (Vec Bit n),
fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool)
   =&gt;
   <span class="kr">if</span> bit
   <span class="kr">then</span>
    N2Bv_sized n
      (Bv2N (N2Bv_sized n (Bv2N r * Bv2N r)) * x)
   <span class="kr">else</span> N2Bv_sized n (Bv2N r * Bv2N r)) l start =
N2Bv_sized n
  (Bv2N start
   ^ <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) *
   x ^ from_stream l)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">start</span> : combType (Vec Bit n),
fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool) =&gt;
   <span class="kr">if</span> bit
   <span class="kr">then</span>
    N2Bv_sized n
      (Bv2N (N2Bv_sized n (Bv2N r * Bv2N r)) * x)
   <span class="kr">else</span> N2Bv_sized n (Bv2N r * Bv2N r)) 
  (a :: l) start =
N2Bv_sized n
  (Bv2N start
   ^ <span class="mi">2</span> ^ N.of_nat (Datatypes.length (a :: l)) *
   x ^ from_stream (a :: l))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk8f"><span class="highlight">{</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">start</span> : combType (Vec Bit n),
fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool)
   =&gt;
   <span class="kr">if</span> bit
   <span class="kr">then</span>
    N2Bv_sized n
      (Bv2N (N2Bv_sized n (Bv2N r * Bv2N r)) * x)
   <span class="kr">else</span> N2Bv_sized n (Bv2N r * Bv2N r)) l start =
N2Bv_sized n
  (Bv2N start
   ^ <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) *
   x ^ from_stream l)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">start</span> : combType (Vec Bit n),
fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool) =&gt;
   <span class="kr">if</span> bit
   <span class="kr">then</span>
    N2Bv_sized n
      (Bv2N (N2Bv_sized n (Bv2N r * Bv2N r)) * x)
   <span class="kr">else</span> N2Bv_sized n (Bv2N r * Bv2N r)) 
  (a :: l) start =
N2Bv_sized n
  (Bv2N start
   ^ <span class="mi">2</span> ^ N.of_nat (Datatypes.length (a :: l)) *
   x ^ from_stream (a :: l))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk90"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">start</span> : combType (Vec Bit n),
fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool)
   =&gt;
   <span class="kr">if</span> bit
   <span class="kr">then</span>
    N2Bv_sized n
      (Bv2N (N2Bv_sized n (Bv2N r * Bv2N r)) * x)
   <span class="kr">else</span> N2Bv_sized n (Bv2N r * Bv2N r)) l start =
N2Bv_sized n
  (Bv2N start
   ^ <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) *
   x ^ from_stream l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">start</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool) =&gt;
   <span class="kr">if</span> bit
   <span class="kr">then</span>
    N2Bv_sized n
      (Bv2N (N2Bv_sized n (Bv2N r * Bv2N r)) * x)
   <span class="kr">else</span> N2Bv_sized n (Bv2N r * Bv2N r)) 
  (a :: l) start =
N2Bv_sized n
  (Bv2N start
   ^ <span class="mi">2</span> ^ N.of_nat (Datatypes.length (a :: l)) *
   x ^ from_stream (a :: l))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk91"><span class="highlight"><span class="nb">cbn</span> [fold_left].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">start</span> : combType (Vec Bit n),
fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool)
   =&gt;
   <span class="kr">if</span> bit
   <span class="kr">then</span>
    N2Bv_sized n
      (Bv2N (N2Bv_sized n (Bv2N r * Bv2N r)) * x)
   <span class="kr">else</span> N2Bv_sized n (Bv2N r * Bv2N r)) l start =
N2Bv_sized n
  (Bv2N start
   ^ <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) *
   x ^ from_stream l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">start</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool) =&gt;
   <span class="kr">if</span> bit
   <span class="kr">then</span>
    N2Bv_sized n
      (Bv2N (N2Bv_sized n (Bv2N r * Bv2N r)) * x)
   <span class="kr">else</span> N2Bv_sized n (Bv2N r * Bv2N r)) l
  (<span class="kr">if</span> a
   <span class="kr">then</span>
    N2Bv_sized n
      (Bv2N (N2Bv_sized n (Bv2N start * Bv2N start)) *
       x)
   <span class="kr">else</span> N2Bv_sized n (Bv2N start * Bv2N start)) =
N2Bv_sized n
  (Bv2N start
   ^ <span class="mi">2</span> ^ N.of_nat (Datatypes.length (a :: l)) *
   x ^ from_stream (a :: l))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk92"><span class="highlight"><span class="nb">rewrite</span> IHl.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">start</span> : combType (Vec Bit n),
fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool)
   =&gt;
   <span class="kr">if</span> bit
   <span class="kr">then</span>
    N2Bv_sized n
      (Bv2N (N2Bv_sized n (Bv2N r * Bv2N r)) * x)
   <span class="kr">else</span> N2Bv_sized n (Bv2N r * Bv2N r)) l start =
N2Bv_sized n
  (Bv2N start
   ^ <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) *
   x ^ from_stream l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">start</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N2Bv_sized n
  (Bv2N
     (<span class="kr">if</span> a
      <span class="kr">then</span>
       N2Bv_sized n
         (Bv2N
            (N2Bv_sized n (Bv2N start * Bv2N start)) *
          x)
      <span class="kr">else</span> N2Bv_sized n (Bv2N start * Bv2N start))
   ^ <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) *
   x ^ from_stream l) =
N2Bv_sized n
  (Bv2N start
   ^ <span class="mi">2</span> ^ N.of_nat (Datatypes.length (a :: l)) *
   x ^ from_stream (a :: l))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk93"><span class="highlight"><span class="nb">rewrite</span> from_stream_cons.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">start</span> : combType (Vec Bit n),
fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool)
   =&gt;
   <span class="kr">if</span> bit
   <span class="kr">then</span>
    N2Bv_sized n
      (Bv2N (N2Bv_sized n (Bv2N r * Bv2N r)) * x)
   <span class="kr">else</span> N2Bv_sized n (Bv2N r * Bv2N r)) l start =
N2Bv_sized n
  (Bv2N start
   ^ <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) *
   x ^ from_stream l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">start</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N2Bv_sized n
  (Bv2N
     (<span class="kr">if</span> a
      <span class="kr">then</span>
       N2Bv_sized n
         (Bv2N
            (N2Bv_sized n (Bv2N start * Bv2N start)) *
          x)
      <span class="kr">else</span> N2Bv_sized n (Bv2N start * Bv2N start))
   ^ <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) *
   x ^ from_stream l) =
N2Bv_sized n
  (Bv2N start
   ^ <span class="mi">2</span> ^ N.of_nat (Datatypes.length (a :: l)) *
   x
   ^ ((<span class="kr">if</span> a
       <span class="kr">then</span> (<span class="mi">2</span> ^ N.of_nat (Datatypes.length l))%N
       <span class="kr">else</span> <span class="mi">0</span>%N) + from_stream l))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk94"><span class="highlight"><span class="nb">cbn</span> [length].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">start</span> : combType (Vec Bit n),
fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool)
   =&gt;
   <span class="kr">if</span> bit
   <span class="kr">then</span>
    N2Bv_sized n
      (Bv2N (N2Bv_sized n (Bv2N r * Bv2N r)) * x)
   <span class="kr">else</span> N2Bv_sized n (Bv2N r * Bv2N r)) l start =
N2Bv_sized n
  (Bv2N start
   ^ <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) *
   x ^ from_stream l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">start</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N2Bv_sized n
  (Bv2N
     (<span class="kr">if</span> a
      <span class="kr">then</span>
       N2Bv_sized n
         (Bv2N
            (N2Bv_sized n (Bv2N start * Bv2N start)) *
          x)
      <span class="kr">else</span> N2Bv_sized n (Bv2N start * Bv2N start))
   ^ <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) *
   x ^ from_stream l) =
N2Bv_sized n
  (Bv2N start ^ <span class="mi">2</span> ^ N.of_nat (S (Datatypes.length l)) *
   x
   ^ ((<span class="kr">if</span> a
       <span class="kr">then</span> (<span class="mi">2</span> ^ N.of_nat (Datatypes.length l))%N
       <span class="kr">else</span> <span class="mi">0</span>%N) + from_stream l))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk95"><span class="highlight"><span class="nb">rewrite</span> Nat2N.inj_succ, N.pow_succ_r&#39;.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHl</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">start</span> : combType (Vec Bit n),
fold_left
  (<span class="kr">fun</span> (<span class="nv">r</span> : combType (Vec Bit n)) (<span class="nv">bit</span> : bool)
   =&gt;
   <span class="kr">if</span> bit
   <span class="kr">then</span>
    N2Bv_sized n
      (Bv2N (N2Bv_sized n (Bv2N r * Bv2N r)) * x)
   <span class="kr">else</span> N2Bv_sized n (Bv2N r * Bv2N r)) l start =
N2Bv_sized n
  (Bv2N start
   ^ <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) *
   x ^ from_stream l)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">start</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N2Bv_sized n
  (Bv2N
     (<span class="kr">if</span> a
      <span class="kr">then</span>
       N2Bv_sized n
         (Bv2N
            (N2Bv_sized n (Bv2N start * Bv2N start)) *
          x)
      <span class="kr">else</span> N2Bv_sized n (Bv2N start * Bv2N start))
   ^ <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) *
   x ^ from_stream l) =
N2Bv_sized n
  (Bv2N start
   ^ (<span class="mi">2</span> * <span class="mi">2</span> ^ N.of_nat (Datatypes.length l)) *
   x
   ^ ((<span class="kr">if</span> a
       <span class="kr">then</span> (<span class="mi">2</span> ^ N.of_nat (Datatypes.length l))%N
       <span class="kr">else</span> <span class="mi">0</span>%N) + from_stream l))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">destruct_one_match;
      <span class="nb">rewrite</span> <span class="nl">?N</span>.add_0_l;
      <span class="nb">autorewrite with</span> pull_N2Bv_sized;
      <span class="nb">rewrite</span> <span class="nl">?N</span>.pow_mul_r, <span class="nl">?N</span>.pow_add_r;
      <span class="kr">lazymatch goal with</span>
      | |- <span class="kp">context</span> [N2Bv_sized n (Bv2N (N2Bv_sized n <span class="nl">?x</span>) ^ <span class="nl">?y</span> * <span class="nl">?z</span>)] =&gt;
        <span class="nb">rewrite</span> &lt;-(N2Bv_sized_mul_idemp_l _ _ z);
          <span class="nb">autorewrite with</span> pull_N2Bv_sized
      <span class="kr">end</span>;
      <span class="nb">rewrite</span> <span class="nl">?N</span>.pow_2_r, <span class="nl">?N</span>.pow_mul_l;
      <span class="nb">apply</span> <span class="nb">f_equal</span>; <span class="bp">lia</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">}</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk96"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">exponentiation_is_exp_by_squaring</span> <span class="nv">n</span> <span class="nv">x</span> <span class="nv">l</span> :
  exp_by_squaring_spec
    (A:=combType (Vec Bit n))
    (<span class="kr">fun</span> <span class="nv">v</span> =&gt; N2Bv_sized n (Bv2N v * x))
    (<span class="kr">fun</span> <span class="nv">v</span> =&gt; N2Bv_sized n (Bv2N v * Bv2N v))
    (N2Bv_sized n <span class="mi">1</span>) l
  = N2Bv_sized n (x ^ from_stream l).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">exp_by_squaring_spec
  (<span class="kr">fun</span> <span class="nv">v</span> : combType (Vec Bit n) =&gt;
   N2Bv_sized n (Bv2N v * x))
  (<span class="kr">fun</span> <span class="nv">v</span> : combType (Vec Bit n) =&gt;
   N2Bv_sized n (Bv2N v * Bv2N v)) (N2Bv_sized n <span class="mi">1</span>) l =
N2Bv_sized n (x ^ from_stream l)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk97"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">exp_by_squaring_spec
  (<span class="kr">fun</span> <span class="nv">v</span> : combType (Vec Bit n) =&gt;
   N2Bv_sized n (Bv2N v * x))
  (<span class="kr">fun</span> <span class="nv">v</span> : combType (Vec Bit n) =&gt;
   N2Bv_sized n (Bv2N v * Bv2N v)) (N2Bv_sized n <span class="mi">1</span>) l =
N2Bv_sized n (x ^ from_stream l)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk98"><span class="highlight"><span class="nb">rewrite</span> exponentiate_is_exp_by_squaring&#39;.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N2Bv_sized n
  (Bv2N (N2Bv_sized n <span class="mi">1</span>)
   ^ <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) *
   x ^ from_stream l) =
N2Bv_sized n (x ^ from_stream l)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk99"><span class="highlight"><span class="nb">assert</span> (<span class="mi">2</span> ^ N.of_nat (length l) &lt;&gt; <span class="mi">0</span>)%N
    <span class="bp">by</span> (<span class="nb">apply</span> N.pow_nonzero; <span class="bp">lia</span>).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(<span class="mi">2</span> ^ N.of_nat (Datatypes.length l))%N &lt;&gt; <span class="mi">0</span>%N</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N2Bv_sized n
  (Bv2N (N2Bv_sized n <span class="mi">1</span>)
   ^ <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) *
   x ^ from_stream l) =
N2Bv_sized n (x ^ from_stream l)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk9a"><span class="highlight"><span class="nb">rewrite</span> Bv2N_N2Bv_sized_modulo <span class="bp">by</span> <span class="bp">lia</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(<span class="mi">2</span> ^ N.of_nat (Datatypes.length l))%N &lt;&gt; <span class="mi">0</span>%N</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N2Bv_sized n
  ((<span class="mi">1</span> mod <span class="mi">2</span> ^ N.of_nat n)
   ^ <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) *
   x ^ from_stream l) =
N2Bv_sized n (x ^ from_stream l)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk9b"><span class="highlight"><span class="nb">destruct</span> n; [ <span class="nb">apply</span> nil_eq | ].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(<span class="mi">2</span> ^ N.of_nat (Datatypes.length l))%N &lt;&gt; <span class="mi">0</span>%N</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N2Bv_sized (S n)
  ((<span class="mi">1</span> mod <span class="mi">2</span> ^ N.of_nat (S n))
   ^ <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) *
   x ^ from_stream l) =
N2Bv_sized (S n) (x ^ from_stream l)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk9c"><span class="highlight"><span class="nb">rewrite</span> N.mod_1_l <span class="bp">by</span> (<span class="nb">apply</span> N.pow_gt_1; <span class="bp">lia</span>).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(<span class="mi">2</span> ^ N.of_nat (Datatypes.length l))%N &lt;&gt; <span class="mi">0</span>%N</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N2Bv_sized (S n)
  (<span class="mi">1</span> ^ <span class="mi">2</span> ^ N.of_nat (Datatypes.length l) *
   x ^ from_stream l) =
N2Bv_sized (S n) (x ^ from_stream l)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk9d"><span class="highlight"><span class="nb">rewrite</span> N.pow_1_l.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(<span class="mi">2</span> ^ N.of_nat (Datatypes.length l))%N &lt;&gt; <span class="mi">0</span>%N</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N2Bv_sized (S n) (<span class="mi">1</span> * x ^ from_stream l) =
N2Bv_sized (S n) (x ^ from_stream l)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">f_equal</span>; <span class="bp">lia</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>And now we can prove <tt class="docutils literal">stream_exponentiate</tt> is always correct!</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk9e"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">stream_exponentiate_correct</span> <span class="nv">n</span> <span class="nv">x</span> (<span class="nv">input</span> : list bool) :
  simulate (stream_exponentiate (n:=n) x) input
  = map_stream
      (<span class="kr">fun</span> <span class="nv">i</span> =&gt; N2Bv_sized n (x ^ (from_stream i)))
      input.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate (stream_exponentiate x) input =
map_stream
  (<span class="kr">fun</span> <span class="nv">i</span> : list bool =&gt;
   N2Bv_sized n (x ^ from_stream i)) input</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chk9f"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate (stream_exponentiate x) input =
map_stream
  (<span class="kr">fun</span> <span class="nv">i</span> : list bool =&gt;
   N2Bv_sized n (x ^ from_stream i)) input</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chka0"><span class="highlight"><span class="nb">intros</span>; <span class="nb">cbv</span> [stream_exponentiate].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate
  (exp_by_squaring (Vec.of_N <span class="mi">1</span>) 
     (Comb squareN) (mul_constN x)) input =
map_stream
  (<span class="kr">fun</span> <span class="nv">i</span> : list bool =&gt;
   N2Bv_sized n (x ^ from_stream i)) input</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chka1"><span class="highlight"><span class="nb">rewrite</span> @exp_by_squaring_correct
    <span class="kr">with</span> (A:=Vec Bit n)
         (mul_spec:=<span class="kr">fun</span> <span class="nv">v</span> =&gt; N2Bv_sized n (Bv2N v * x))
         (square_spec := <span class="kr">fun</span> <span class="nv">v</span> =&gt; N2Bv_sized n (Bv2N v * Bv2N v))
    <span class="bp">by</span> <span class="kp">first</span> [ <span class="kp">solve</span> [<span class="nb">apply</span> mul_constN_step]
             | <span class="nb">cbn</span> [circuit_state step]; <span class="nb">intros</span>; simpl_ident;
               <span class="kr">lazymatch goal with</span> x : unit |- _ =&gt; <span class="nb">destruct</span> x <span class="kr">end</span>;
               <span class="bp">reflexivity</span> ].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map_stream
  (exp_by_squaring_spec
     (<span class="kr">fun</span> <span class="nv">v</span> : Bvector n =&gt; N2Bv_sized n (Bv2N v * x))
     (<span class="kr">fun</span> <span class="nv">v</span> : Bvector n =&gt;
      N2Bv_sized n (Bv2N v * Bv2N v)) 
     (Vec.of_N <span class="mi">1</span>)) input =
map_stream
  (<span class="kr">fun</span> <span class="nv">i</span> : list bool =&gt;
   N2Bv_sized n (x ^ from_stream i)) input</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chka2"><span class="highlight"><span class="nb">apply</span> map_ext; <span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">exp_by_squaring_spec
  (<span class="kr">fun</span> <span class="nv">v</span> : Bvector n =&gt; N2Bv_sized n (Bv2N v * x))
  (<span class="kr">fun</span> <span class="nv">v</span> : Bvector n =&gt; N2Bv_sized n (Bv2N v * Bv2N v))
  (Vec.of_N <span class="mi">1</span>) (firstn (S a) input) =
N2Bv_sized n (x ^ from_stream (firstn (S a) input))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="expbysquaring-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="expbysquaring-v-chka3"><span class="highlight">simpl_ident.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">exp_by_squaring_spec
  (<span class="kr">fun</span> <span class="nv">v</span> : Bvector n =&gt; N2Bv_sized n (Bv2N v * x))
  (<span class="kr">fun</span> <span class="nv">v</span> : Bvector n =&gt; N2Bv_sized n (Bv2N v * Bv2N v))
  (N2Bv_sized n <span class="mi">1</span>) (firstn (S a) input) =
N2Bv_sized n (x ^ from_stream (firstn (S a) input))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> exponentiation_is_exp_by_squaring.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>Thanks for bearing with us through the end! For questions, comments, and
contributions, contact us on our GitHub <a class="reference external" href="https://github.com/project-oak/silveroak">repo</a>.</p>
</div>
</div></body>
</html>
