<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.16: http://docutils.sourceforge.net/" />
<title>Tutorial</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.min.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.12.0+0.12.0. Coq sources are in this panel; goals and messages will appear in the other. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus.</div><div class="document" id="tutorial">
<h1 class="title">Tutorial</h1>

<p>Welcome! This is a quick primer for designing circuits with Cava. We'll walk
through a few small examples end-to-end. This tutorial will not explain Coq
syntax in depth, but will use the same few patterns throughout; you shouldn't
need to know Coq to follow along.</p>
<p>Use Ctrl+down and Ctrl+up to step through the Coq code along with the
tutorial. Use Ctrl+click to focus on a particular line.</p>
<div class="section" id="example-1-inverter">
<h1>Example 1 : Inverter</h1>
<p>To start, let's define a 1-bit inverter.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">inverter</span>
           {<span class="nv">signal</span> : SignalType -&gt; <span class="kt">Type</span>}
           {<span class="nv">semantics</span> : Cava signal}
  : Circuit (signal Bit) (signal Bit) :=
  Comb inv.</span></span></span></pre><p>A few things to notice here:</p>
<ul class="simple">
<li><tt class="docutils literal">SignalType</tt> is Cava's type system. The inverter is parameterized over
<tt class="docutils literal">signal</tt>, which converts <tt class="docutils literal">SignalType</tt>s to Coq types. <tt class="docutils literal">Bit</tt> is one
example of a <tt class="docutils literal">SignalType</tt>; we'll see more examples later on.</li>
<li><tt class="docutils literal">Comb</tt> is short for &quot;combinational&quot;; our inverter has no loops, registers,
or timing requirements, so it is a purely combinational circuit.</li>
<li>The inverter is also paramterized over <tt class="docutils literal">semantics</tt>, an instance of the
typeclass <tt class="docutils literal">Cava</tt>. This instance provides implementations of circuit
primitives, such as 1-bit logic gates. One primitive gate is a 1-bit inverter
<tt class="docutils literal">inv</tt>, so our inverter is just a simple invocation of the primitive.</li>
</ul>
<p>Normally, we'd write circuit definitions a little more concisely by writing them
inside a <tt class="docutils literal">Section</tt> that contains <tt class="docutils literal">signal</tt> and <tt class="docutils literal">semantics</tt> as context
variables, like this:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">WithCava</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> {<span class="nv">signal</span>} {<span class="nv">semantics</span> : Cava signal}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">inverter_concise</span> : Circuit (signal Bit) (signal Bit)
    := Comb inv.</span></span></span></pre><p>For the rest of the circuit definitions in this tutorial, you can assume that
we're inside the section and that every definition is parameterized over the
<tt class="docutils literal">signal</tt> and <tt class="docutils literal">semantics</tt> context variables.</p>
<p>Back to our inverter. Let's take a closer look at the <tt class="docutils literal">inv</tt> primitive.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk0"><span class="highlight"><span class="kn">About</span> inv.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">inv :
<span class="kr">forall</span> {<span class="nv">signal</span> : SignalType -&gt; <span class="kt">Type</span>}
  {<span class="nv">Cava</span> : Cava signal},
signal Bit -&gt; cava (signal Bit)

inv <span class="kr">is</span> not universe polymorphic
<span class="kn">Arguments</span> inv {signal}%function_scope {Cava}
inv <span class="kr">is</span> transparent
Expands to: Constant Cava.Core.CavaClass.inv</span></blockquote></div></div></small></span></pre><p>You can see in the type signature <tt class="docutils literal">signal Bit <span class="pre">-&gt;</span> cava (signal Bit)</tt> that
<tt class="docutils literal">inv</tt> is defined as a pure Coq function in terms of a monad called
<tt class="docutils literal">cava</tt>. The <tt class="docutils literal">cava</tt> monad, like <tt class="docutils literal">inv</tt>, is provided by <tt class="docutils literal">semantics</tt>. The
monad is used to capture sharing; it's semantically different in Cava to write:</p>
<pre class="literal-block">
x &lt;- inv zero ;;
y &lt;- inv zero ;;
xor2 x y
</pre>
<p>than it is to write:</p>
<pre class="literal-block">
x &lt;- inv zero ;;
xor2 x x
</pre>
<p>Both expressions have the same meaning, and if we were using Gallina <tt class="docutils literal">let</tt>
binders there would be no difference. But the generated circuit can use two
wires for the first definition, and fork the same wire in the second. As circuit
diagrams, this is the difference between:</p>
<pre class="literal-block">
       +-----+      +-----+
0 -----| inv |------|     |
       +-----+      | xor |----- out
       +-----+      |     |
0 -----| inv |------|     |
       +-----+      +-----+
</pre>
<p>and:</p>
<pre class="literal-block">
                      +-----+
                  +---|     |
                  |   | xor |---- out
       +-----+    |   |     |
0 -----| inv |----+---|     |
       +-----+        +-----+
</pre>
<p>This difference isn't significant in determining what the value of <tt class="docutils literal">out</tt> will
be, but it can be very useful when trying to exercise fine-grained control over
circuit layout and area! At a first approximation, you can think of a monadic
bind (<tt class="docutils literal">_ &lt;- _ ;; ...</tt>) as <em>naming a wire</em> in the circuit graph.</p>
<p>We could have represented sharing by describing circuit graphs with a list of
nodes and edges. However, this is essentially the &quot;machine code&quot; of structural
hardware descriptions, and is far too tedious a representation for humans to
work with. The monadic-function abstraction allows human engineers to think
about the functional behavior and composition of circuits at a more intuitive
level.</p>
<p>Parameterizing over the <tt class="docutils literal">cava</tt> monad and primitive implementations allows us
to use different instances of <tt class="docutils literal">Cava</tt> to interpret the same circuit definition
in different ways. One <tt class="docutils literal">Cava</tt> instance generates netlists by adding and
connecting wires in the background using a state monad. For circuit simulations
and proofs of functional correctness, on the other hand, we don't care about
sharing at all; these use no-op identity monad that acts the same as a <tt class="docutils literal">let</tt>
binder.</p>
<p>Let's use our <tt class="docutils literal">inverter</tt> definition to see these two interpretations in
action.</p>
<p>First, let's generate a netlist. We need to define an interface that describes the
circuit's input and output ports and behavior relative to the (global) clock and
reset signals. Then we can compute a netlist (type <tt class="docutils literal">CavaState</tt>), which
describes the full layout of the circuit in a way that can be easily translated
to SystemVerilog.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight"><span class="c">(* netlist-generating semantics *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Existing Instance</span> <span class="nf">CavaCombinationalNet</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">inverter_interface</span>
  := sequentialInterface <span class="s2">&quot;inverter_interface&quot;</span>
     <span class="s2">&quot;clk&quot;</span> PositiveEdge <span class="s2">&quot;rst&quot;</span> PositiveEdge
     [mkPort <span class="s2">&quot;i&quot;</span> Bit]
     [mkPort <span class="s2">&quot;o&quot;</span> Bit]
     [].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk1"><span class="highlight"><span class="kn">Compute</span> makeCircuitNetlist inverter_interface inverter.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= {|
  netNumber := <span class="mi">1</span>;
  vectorNumber := <span class="mi">0</span>;
  vectorDeclarations := [];
  externalDeclarations := [];
  clockNet := Some (NamedWire <span class="s2">&quot;clk&quot;</span>);
  clockEdge := PositiveEdge;
  resetNet := Some (NamedWire <span class="s2">&quot;rst&quot;</span>);
  resetEdge := PositiveEdge;
  module := {|
            moduleName := <span class="s2">&quot;inverter_interface&quot;</span>;
            netlist := [AssignSignal
                          (NamedWire <span class="s2">&quot;o&quot;</span>)
                          (Wire <span class="mi">0</span>);
                       Not (NamedWire <span class="s2">&quot;i&quot;</span>)
                         (Wire <span class="mi">0</span>)];
            inputs := [{|
                       port_name := <span class="s2">&quot;i&quot;</span>;
                       port_type := Bit |};
                      {|
                      port_name := <span class="s2">&quot;rst&quot;</span>;
                      port_type := Bit |};
                      {|
                      port_name := <span class="s2">&quot;clk&quot;</span>;
                      port_type := Bit |}];
            outputs := [{|
                        port_name := <span class="s2">&quot;o&quot;</span>;
                        port_type := Bit |}] |};
  libraryModules := [] |}
: CavaState</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* A closer look at the circuit body *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk2"><span class="highlight"><span class="kn">Compute</span> (makeCircuitNetlist inverter_interface inverter).(module).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= {|
  moduleName := <span class="s2">&quot;inverter_interface&quot;</span>;
  netlist := [AssignSignal (NamedWire <span class="s2">&quot;o&quot;</span>)
                (Wire <span class="mi">0</span>);
             Not (NamedWire <span class="s2">&quot;i&quot;</span>) (Wire <span class="mi">0</span>)];
  inputs := [{|
             port_name := <span class="s2">&quot;i&quot;</span>;
             port_type := Bit |};
            {|
            port_name := <span class="s2">&quot;rst&quot;</span>;
            port_type := Bit |};
            {|
            port_name := <span class="s2">&quot;clk&quot;</span>;
            port_type := Bit |}];
  outputs := [{|
              port_name := <span class="s2">&quot;o&quot;</span>;
              port_type := Bit |}] |}
: <span class="kn">Module</span></span></blockquote></div></div></small></span></pre><p>You may notice that we're using something called <tt class="docutils literal">sequentialInterface</tt> here,
and referring to clock and reset signals, even though our inverter is a purely
combinational circuit. We introduce timing in the netlist interface here in
order to drive the circuit with multiple inputs over time, and to plug it in as
a subcomponent of circuits that are not combinational.</p>
<p>Now, let's simulate the circuit, which can be useful for testing and proving
functional correctness. Here, we use the identity-monad interpretation. The
<tt class="docutils literal">signal</tt> for this <tt class="docutils literal">Cava</tt> instance is <tt class="docutils literal">combType</tt>, which interprets a
<tt class="docutils literal">Bit</tt> simply as a Coq <tt class="docutils literal">bool</tt>. If we provide the three inputs
<tt class="docutils literal">[true; false; true]</tt> to the circuit simulation function <tt class="docutils literal">multistep</tt>, we'll
get <tt class="docutils literal">[false; true; false]</tt>:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight"><span class="c">(* identity-monad semantics *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Existing Instance</span> <span class="nf">CombinationalSemantics</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk3"><span class="highlight"><span class="kn">Compute</span> simulate inverter [true; false; true].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= [false; true; false]
: list (combType Bit)</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk4"><span class="highlight"><span class="kn">Compute</span> simulate inverter [true; false; true; true; true; false].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= [false; true; false; false; false; true]
: list (combType Bit)</span></blockquote></div></div></small></span></pre><p>We can use the simulation to write proofs about the circuit. For instance, we
can prove that <tt class="docutils literal">inverter</tt> obeys a natural Coq specification:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk5"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">inverter_correct</span> (<span class="nv">input</span> : list bool) :
  simulate inverter input = map negb input.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate inverter input = map negb input</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk6"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate inverter input = map negb input</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">  <span class="c">(* inline the circuit definition *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk7"><span class="highlight"><span class="nb">cbv</span> [inverter].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate (Comb inv) input = map negb input</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="c">(* simplify simulate to create an expression in terms of Coq lists *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk8"><span class="highlight"><span class="nb">autorewrite with</span> push_simulate.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map inv input = map negb input</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="c">(* assert that the two List.map functions are equivalent *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk9"><span class="highlight"><span class="nb">apply</span> map_ext.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> : bool, inv a = negb a</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chka"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">inv a = negb a</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="c">(* inline the inv primitive (fun x =&gt; ret (negb x)) *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chkb"><span class="highlight"><span class="nb">cbn</span> [inv CombinationalSemantics].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ret (negb a) = negb a</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="c">(* simplify the identity monad expressions *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chkc"><span class="highlight">simpl_ident.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">negb a = negb a</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>We can even prove that composing two inverters is the same as doing
nothing. Here, <tt class="docutils literal"><span class="pre">&gt;==&gt;</span></tt> is circuit composition (a Kleisli arrow). The proof
structure is pretty similar.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chkd"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">inverter_idempotent</span> (<span class="nv">input</span> : list bool) :
  simulate (inverter &gt;==&gt; inverter) input = input.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate (inverter &gt;==&gt; inverter) input = input</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chke"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate (inverter &gt;==&gt; inverter) input = input</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chkf"><span class="highlight"><span class="nb">cbv</span> [inverter].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate (Comb inv &gt;==&gt; Comb inv) input = input</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk10"><span class="highlight"><span class="nb">autorewrite with</span> push_simulate.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map inv (map inv input) = input</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk11"><span class="highlight"><span class="nb">rewrite</span> map_map.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map (<span class="kr">fun</span> <span class="nv">x</span> : combType Bit =&gt; inv (inv x)) input =
input</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk12"><span class="highlight"><span class="nb">apply</span> List.map_id_ext.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> : combType Bit, inv (inv a) = a</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk13"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType Bit</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">inv (inv a) = a</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk14"><span class="highlight"><span class="nb">cbn</span> [inv CombinationalSemantics].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType Bit</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ret (negb (ret (negb a))) = a</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk15"><span class="highlight">simpl_ident.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType Bit</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">negb (negb a) = a</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> Bool.negb_involutive.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>A note about reading Coq proofs: in general, it's more important to understand
the lemma statement (the part before <tt class="docutils literal">Proof</tt> than it is to understand the
proof body. The lemma statement shows what is being proven, and the proof body
contains an &quot;argument&quot; to Coq that the statement is true.</p>
<p>To summarize, there are three things you can do with Cava circuits:</p>
<ol class="arabic simple">
<li>Define them (parameterized over an abstract <tt class="docutils literal">Cava</tt> instance)</li>
<li>Generate netlists for them using the <tt class="docutils literal">CavaCombinationalNet</tt> instance and
the <tt class="docutils literal">makeCircuitNetlist</tt> function. These netlists can then be translated into
SystemVerilog.</li>
<li>Simulate them using <tt class="docutils literal">simulate</tt>, and prove things about the simulations, by
plugging in the <tt class="docutils literal">CombinationalSemantics</tt> instance.</li>
</ol>
<p>In the following examples, we'll use this exact same three-part pattern to
explore more complex circuits.</p>
</div>
<div class="section" id="example-2-byte-xor">
<h1>Example 2 : Byte xor</h1>
<p>Our next example is a circuit that xors two bytes:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">  </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">xor_byte</span> :
    Circuit (signal (Vec Bit <span class="mi">8</span>) * signal (Vec Bit <span class="mi">8</span>))
            (signal (Vec Bit <span class="mi">8</span>)) :=
    Comb (<span class="kr">fun</span> &#39;(v1, v2) =&gt; Vec.map2 xor2 v1 v2).</span></span></span></pre><p>This circuit maps a 1-bit xor (<tt class="docutils literal">xor2</tt>) over the two input vectors. <tt class="docutils literal">xor2</tt> is
one of the primitives provided by the <tt class="docutils literal">Cava</tt> instance, like <tt class="docutils literal">inv</tt>. Once
again, this is a combinational circuit, so we define it by wrapping a monadic
function with <tt class="docutils literal">Comb</tt>.</p>
<p>The <tt class="docutils literal">Vec</tt> here is another <tt class="docutils literal">SignalType</tt>, with a slightly more complicated
construction than <tt class="docutils literal">Bit</tt>. A <tt class="docutils literal">Vec Bit 8</tt> is a vector of 8 bits: a
byte. Vectors can be formed from any other <tt class="docutils literal">SignalType</tt>, including other
vectors; <tt class="docutils literal">Vec (Vec (Vec Bit 8) 4) 2)</tt> is a valid construction representing a
two-dimensional array of bytes (equivalently, a three-dimensional array of
bits).</p>
<p>To generate a netlist for this circuit, we use mostly the same procedure as for
the inverter, except that we change the input and output port types to match the
circuit's type signature.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">xor_byte_interface</span>
  := sequentialInterface <span class="s2">&quot;xor_byte_interface&quot;</span>
     <span class="s2">&quot;clk&quot;</span> PositiveEdge <span class="s2">&quot;rst&quot;</span> PositiveEdge
     [mkPort <span class="s2">&quot;v1&quot;</span> (Vec Bit <span class="mi">8</span>); mkPort <span class="s2">&quot;v2&quot;</span> (Vec Bit <span class="mi">8</span>)]
     [mkPort <span class="s2">&quot;o&quot;</span> (Vec Bit <span class="mi">8</span>)]
     [].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk16"><span class="highlight"><span class="kn">Compute</span> (makeCircuitNetlist xor_byte_interface xor_byte).(module).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= {|
  moduleName := <span class="s2">&quot;xor_byte_interface&quot;</span>;
  netlist := [AssignSignal
                (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;o&quot;</span>)
                (LocalVec Bit <span class="mi">8</span> <span class="mi">0</span>);
             AssignSignal (LocalVec Bit <span class="mi">8</span> <span class="mi">0</span>)
               (VecLit
                  [Wire <span class="mi">16</span>; Wire <span class="mi">17</span>; Wire <span class="mi">18</span>;
                  Wire <span class="mi">19</span>; Wire <span class="mi">20</span>; Wire <span class="mi">21</span>;
                  Wire <span class="mi">22</span>; Wire <span class="mi">23</span>]);
             Xor (Wire <span class="mi">7</span>) (Wire <span class="mi">15</span>) (Wire <span class="mi">23</span>);
             Xor (Wire <span class="mi">6</span>) (Wire <span class="mi">14</span>) (Wire <span class="mi">22</span>);
             Xor (Wire <span class="mi">5</span>) (Wire <span class="mi">13</span>) (Wire <span class="mi">21</span>);
             Xor (Wire <span class="mi">4</span>) (Wire <span class="mi">12</span>) (Wire <span class="mi">20</span>);
             Xor (Wire <span class="mi">3</span>) (Wire <span class="mi">11</span>) (Wire <span class="mi">19</span>);
             Xor (Wire <span class="mi">2</span>) (Wire <span class="mi">10</span>) (Wire <span class="mi">18</span>);
             Xor (Wire <span class="mi">1</span>) (Wire <span class="mi">9</span>) (Wire <span class="mi">17</span>);
             Xor (Wire <span class="mi">0</span>) (Wire <span class="mi">8</span>) (Wire <span class="mi">16</span>);
             AssignSignal (Wire <span class="mi">15</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">7</span>);
             AssignSignal (Wire <span class="mi">14</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">6</span>);
             AssignSignal (Wire <span class="mi">13</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">5</span>);
             AssignSignal (Wire <span class="mi">12</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">4</span>);
             AssignSignal (Wire <span class="mi">11</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">3</span>);
             AssignSignal (Wire <span class="mi">10</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">2</span>);
             AssignSignal (Wire <span class="mi">9</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">1</span>);
             AssignSignal (Wire <span class="mi">8</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">0</span>);
             AssignSignal (Wire <span class="mi">7</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">7</span>);
             AssignSignal (Wire <span class="mi">6</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">6</span>);
             AssignSignal (Wire <span class="mi">5</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">5</span>);
             AssignSignal (Wire <span class="mi">4</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">4</span>);
             AssignSignal (Wire <span class="mi">3</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">3</span>);
             AssignSignal (Wire <span class="mi">2</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">2</span>);
             AssignSignal (Wire <span class="mi">1</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">1</span>);
             AssignSignal (Wire <span class="mi">0</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">0</span>)];
  inputs := [{|
             port_name := <span class="s2">&quot;v2&quot;</span>;
             port_type := Vec Bit <span class="mi">8</span> |};
            {|
            port_name := <span class="s2">&quot;v1&quot;</span>;
            port_type := Vec Bit <span class="mi">8</span> |};
            {|
            port_name := <span class="s2">&quot;rst&quot;</span>;
            port_type := Bit |};
            {|
            port_name := <span class="s2">&quot;clk&quot;</span>;
            port_type := Bit |}];
  outputs := [{|
              port_name := <span class="s2">&quot;o&quot;</span>;
              port_type := Vec Bit <span class="mi">8</span> |}] |}
: <span class="kn">Module</span></span></blockquote></div></div></small></span></pre><p>Tuples in the input or output types become lists of ports for the netlist
interface, so <tt class="docutils literal">signal (Vec Bit 8) * signal (Vec Bit 8)</tt> becomes <tt class="docutils literal">[mkPort &quot;v1&quot;
(Vec Bit 8); mkPort &quot;v2&quot; (Vec Bit 8)]</tt>. The names of the ports (&quot;v1&quot;, &quot;v2&quot;, and
&quot;o&quot;) are just for readability and potentially reference by other netlists; they
can be named however you prefer.</p>
<p>We can also, as before, simulate the circuit.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk17"><span class="highlight"><span class="kn">Compute</span>
  simulate xor_byte
  [([true;  true; true;  false; false; false; false; false]%vector,
    [false; true; false; true;  false; false; false; false]%vector)].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= [[true; false; true; true; false; false; false;
   false]%vector]
: list (combType (Vec Bit <span class="mi">8</span>))</span></blockquote></div></div></small></span></pre><p>Literal bit vectors are not especially readable, though; it's not immediately
clear that this simulation is 7 xor 10 = 13. For simulations with bitvectors,
it's often clearer to use natural-number-to-bitvector conversions from the Coq
standard library :</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk18"><span class="highlight"><span class="kn">Compute</span> map Bv2N
        (simulate xor_byte [(N2Bv_sized <span class="mi">8</span> <span class="mi">7</span>, N2Bv_sized <span class="mi">8</span> <span class="mi">10</span>)]).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= [<span class="mi">13</span>%N]
: list N</span></blockquote></div></div></small></span></pre><p>Finally, we can prove that the circuit is correct. In this case, we prove that
the circuit's behavior matches the <tt class="docutils literal">BVxor</tt> definition from the standard
library, specialized to bit-vectors of length 8.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk19"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">xor_byte_correct</span> (<span class="nv">i</span> : list (Vector.t bool <span class="mi">8</span> * Vector.t bool <span class="mi">8</span>)) :
  simulate xor_byte i = map (<span class="kr">fun</span> &#39;(v1,v2) =&gt; BVxor <span class="mi">8</span> v1 v2) i.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t bool <span class="mi">8</span> * t bool <span class="mi">8</span>)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate xor_byte i =
map (<span class="kr">fun</span> &#39;(v1, v2) =&gt; BVxor <span class="mi">8</span> v1 v2) i</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk1a"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t bool <span class="mi">8</span> * t bool <span class="mi">8</span>)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate xor_byte i =
map (<span class="kr">fun</span> &#39;(v1, v2) =&gt; BVxor <span class="mi">8</span> v1 v2) i</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk1b"><span class="highlight"><span class="nb">cbv</span> [xor_byte].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t bool <span class="mi">8</span> * t bool <span class="mi">8</span>)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate (Comb (<span class="kr">fun</span> &#39;(v1, v2) =&gt; Vec.map2 xor2 v1 v2))
  i = map (<span class="kr">fun</span> &#39;(v1, v2) =&gt; BVxor <span class="mi">8</span> v1 v2) i</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk1c"><span class="highlight"><span class="nb">autorewrite with</span> push_simulate.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t bool <span class="mi">8</span> * t bool <span class="mi">8</span>)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map (<span class="kr">fun</span> &#39;(v1, v2) =&gt; Vec.map2 xor2 v1 v2) i =
map (<span class="kr">fun</span> &#39;(v1, v2) =&gt; BVxor <span class="mi">8</span> v1 v2) i</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk1d"><span class="highlight"><span class="nb">apply</span> map_ext; <span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t bool <span class="mi">8</span> * t bool <span class="mi">8</span>)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(t bool <span class="mi">8</span> * t bool <span class="mi">8</span>)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">let</span> &#39;(v1, v2) := a <span class="kr">in</span> Vec.map2 xor2 v1 v2) =
(<span class="kr">let</span> &#39;(v1, v2) := a <span class="kr">in</span> BVxor <span class="mi">8</span> v1 v2)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk1e"><span class="highlight">destruct_pair_let.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t bool <span class="mi">8</span> * t bool <span class="mi">8</span>)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(t bool <span class="mi">8</span> * t bool <span class="mi">8</span>)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Vec.map2 xor2 (fst a) (snd a) =
BVxor <span class="mi">8</span> (fst a) (snd a)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk1f"><span class="highlight"><span class="nb">cbv</span> [BVxor].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t bool <span class="mi">8</span> * t bool <span class="mi">8</span>)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(t bool <span class="mi">8</span> * t bool <span class="mi">8</span>)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Vec.map2 xor2 (fst a) (snd a) =
Vector.map2 xorb (fst a) (snd a)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk20"><span class="highlight">simpl_ident.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t bool <span class="mi">8</span> * t bool <span class="mi">8</span>)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(t bool <span class="mi">8</span> * t bool <span class="mi">8</span>)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xor2 (x, y))
  (fst a) (snd a) = Vector.map2 xorb (fst a) (snd a)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk21"><span class="highlight"><span class="nb">apply</span> Vector.map2_ext.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t bool <span class="mi">8</span> * t bool <span class="mi">8</span>)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(t bool <span class="mi">8</span> * t bool <span class="mi">8</span>)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : combType Bit, xor2 (a, b) = xorb a b</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>Again, no need to focus too much on the body of the proof here; understanding
the lemma statement is the most important part. However, one interesting thing
to note is that the proof is not computational; we don't analyze the 2^16
possibile inputs separately. In fact, we never destruct the vectors or refer to
the length at all, which leads us to our next example.</p>
</div>
<div class="section" id="example-3-bit-vector-xor">
<h1>Example 3: Bit-vector xor</h1>
<p>As it turns out, we can define <tt class="docutils literal">xor_byte</tt> over <em>arbitrary-length</em> bitvectors
with very little modification. The circuit is virtually identical, except that
it takes a length argument <tt class="docutils literal">n</tt> and all the <tt class="docutils literal">8</tt>s are replaced with <tt class="docutils literal">n</tt>:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">  </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">xor_bitvec</span> (<span class="nv">n</span> : nat) :
    Circuit (signal (Vec Bit n) * signal (Vec Bit n))
            (signal (Vec Bit n)) :=
    Comb (<span class="kr">fun</span> &#39;(v1, v2) =&gt; Vec.map2 xor2 v1 v2).</span></span></span></pre><p>We can define an interface for this circuit that also takes <tt class="docutils literal">n</tt> as an
argument, and then compute a netlist for any number of gates we want.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">xor_bitvec_interface</span> {<span class="nv">n</span> : nat}
  := sequentialInterface <span class="s2">&quot;xor_bitvec_interface&quot;</span>
     <span class="s2">&quot;clk&quot;</span> PositiveEdge <span class="s2">&quot;rst&quot;</span> PositiveEdge
     [mkPort <span class="s2">&quot;v1&quot;</span> (Vec Bit n); mkPort <span class="s2">&quot;v2&quot;</span> (Vec Bit n)]
     [mkPort <span class="s2">&quot;o&quot;</span> (Vec Bit n)]
     [].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* Netlist for a 2-bit xor *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk22"><span class="highlight"><span class="kn">Compute</span>
  (makeCircuitNetlist xor_bitvec_interface (xor_bitvec <span class="mi">2</span>)).(module).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= {|
  moduleName := <span class="s2">&quot;xor_bitvec_interface&quot;</span>;
  netlist := [AssignSignal
                (NamedVector Bit <span class="mi">2</span> <span class="s2">&quot;o&quot;</span>)
                (LocalVec Bit <span class="mi">2</span> <span class="mi">0</span>);
             AssignSignal (LocalVec Bit <span class="mi">2</span> <span class="mi">0</span>)
               (VecLit [Wire <span class="mi">4</span>; Wire <span class="mi">5</span>]);
             Xor (Wire <span class="mi">1</span>) (Wire <span class="mi">3</span>) (Wire <span class="mi">5</span>);
             Xor (Wire <span class="mi">0</span>) (Wire <span class="mi">2</span>) (Wire <span class="mi">4</span>);
             AssignSignal (Wire <span class="mi">3</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">2</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">1</span>);
             AssignSignal (Wire <span class="mi">2</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">2</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">0</span>);
             AssignSignal (Wire <span class="mi">1</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">2</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">1</span>);
             AssignSignal (Wire <span class="mi">0</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">2</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">0</span>)];
  inputs := [{|
             port_name := <span class="s2">&quot;v2&quot;</span>;
             port_type := Vec Bit <span class="mi">2</span> |};
            {|
            port_name := <span class="s2">&quot;v1&quot;</span>;
            port_type := Vec Bit <span class="mi">2</span> |};
            {|
            port_name := <span class="s2">&quot;rst&quot;</span>;
            port_type := Bit |};
            {|
            port_name := <span class="s2">&quot;clk&quot;</span>;
            port_type := Bit |}];
  outputs := [{|
              port_name := <span class="s2">&quot;o&quot;</span>;
              port_type := Vec Bit <span class="mi">2</span> |}] |}
: <span class="kn">Module</span></span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* Netlist for a 100-bit xor! *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk23"><span class="highlight"><span class="kn">Compute</span>
  (makeCircuitNetlist xor_bitvec_interface (xor_bitvec <span class="mi">100</span>)).(module).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= {|
  moduleName := <span class="s2">&quot;xor_bitvec_interface&quot;</span>;
  netlist := [AssignSignal
                (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;o&quot;</span>)
                (LocalVec Bit <span class="mi">100</span> <span class="mi">0</span>);
             AssignSignal (LocalVec Bit <span class="mi">100</span> <span class="mi">0</span>)
               (VecLit
                  [Wire <span class="mi">200</span>; Wire <span class="mi">201</span>; Wire <span class="mi">202</span>;
                  Wire <span class="mi">203</span>; Wire <span class="mi">204</span>; Wire <span class="mi">205</span>;
                  Wire <span class="mi">206</span>; Wire <span class="mi">207</span>; Wire <span class="mi">208</span>;
                  Wire <span class="mi">209</span>; Wire <span class="mi">210</span>; Wire <span class="mi">211</span>;
                  Wire <span class="mi">212</span>; Wire <span class="mi">213</span>; Wire <span class="mi">214</span>;
                  Wire <span class="mi">215</span>; Wire <span class="mi">216</span>; Wire <span class="mi">217</span>;
                  Wire <span class="mi">218</span>; Wire <span class="mi">219</span>; Wire <span class="mi">220</span>;
                  Wire <span class="mi">221</span>; Wire <span class="mi">222</span>; Wire <span class="mi">223</span>;
                  Wire <span class="mi">224</span>; Wire <span class="mi">225</span>; Wire <span class="mi">226</span>;
                  Wire <span class="mi">227</span>; Wire <span class="mi">228</span>; Wire <span class="mi">229</span>;
                  Wire <span class="mi">230</span>; Wire <span class="mi">231</span>; Wire <span class="mi">232</span>;
                  Wire <span class="mi">233</span>; Wire <span class="mi">234</span>; Wire <span class="mi">235</span>;
                  Wire <span class="mi">236</span>; Wire <span class="mi">237</span>; Wire <span class="mi">238</span>;
                  Wire <span class="mi">239</span>; Wire <span class="mi">240</span>; Wire <span class="mi">241</span>;
                  Wire <span class="mi">242</span>; Wire <span class="mi">243</span>; Wire <span class="mi">244</span>;
                  Wire <span class="mi">245</span>; Wire <span class="mi">246</span>; Wire <span class="mi">247</span>;
                  Wire <span class="mi">248</span>; Wire <span class="mi">249</span>; Wire <span class="mi">250</span>;
                  Wire <span class="mi">251</span>; Wire <span class="mi">252</span>; Wire <span class="mi">253</span>;
                  Wire <span class="mi">254</span>; Wire <span class="mi">255</span>; Wire <span class="mi">256</span>;
                  Wire <span class="mi">257</span>; Wire <span class="mi">258</span>; Wire <span class="mi">259</span>;
                  Wire <span class="mi">260</span>; Wire <span class="mi">261</span>; Wire <span class="mi">262</span>;
                  Wire <span class="mi">263</span>; Wire <span class="mi">264</span>; Wire <span class="mi">265</span>;
                  Wire <span class="mi">266</span>; Wire <span class="mi">267</span>; Wire <span class="mi">268</span>;
                  Wire <span class="mi">269</span>; Wire <span class="mi">270</span>; Wire <span class="mi">271</span>;
                  Wire <span class="mi">272</span>; Wire <span class="mi">273</span>; Wire <span class="mi">274</span>;
                  Wire <span class="mi">275</span>; Wire <span class="mi">276</span>; Wire <span class="mi">277</span>;
                  Wire <span class="mi">278</span>; Wire <span class="mi">279</span>; Wire <span class="mi">280</span>;
                  Wire <span class="mi">281</span>; Wire <span class="mi">282</span>; Wire <span class="mi">283</span>;
                  Wire <span class="mi">284</span>; Wire <span class="mi">285</span>; Wire <span class="mi">286</span>;
                  Wire <span class="mi">287</span>; Wire <span class="mi">288</span>; Wire <span class="mi">289</span>;
                  Wire <span class="mi">290</span>; Wire <span class="mi">291</span>; Wire <span class="mi">292</span>;
                  Wire <span class="mi">293</span>; Wire <span class="mi">294</span>; Wire <span class="mi">295</span>;
                  Wire <span class="mi">296</span>; Wire <span class="mi">297</span>; Wire <span class="mi">298</span>;
                  Wire <span class="mi">299</span>]);
             Xor (Wire <span class="mi">99</span>) (Wire <span class="mi">199</span>) (Wire <span class="mi">299</span>);
             Xor (Wire <span class="mi">98</span>) (Wire <span class="mi">198</span>) (Wire <span class="mi">298</span>);
             Xor (Wire <span class="mi">97</span>) (Wire <span class="mi">197</span>) (Wire <span class="mi">297</span>);
             Xor (Wire <span class="mi">96</span>) (Wire <span class="mi">196</span>) (Wire <span class="mi">296</span>);
             Xor (Wire <span class="mi">95</span>) (Wire <span class="mi">195</span>) (Wire <span class="mi">295</span>);
             Xor (Wire <span class="mi">94</span>) (Wire <span class="mi">194</span>) (Wire <span class="mi">294</span>);
             Xor (Wire <span class="mi">93</span>) (Wire <span class="mi">193</span>) (Wire <span class="mi">293</span>);
             Xor (Wire <span class="mi">92</span>) (Wire <span class="mi">192</span>) (Wire <span class="mi">292</span>);
             Xor (Wire <span class="mi">91</span>) (Wire <span class="mi">191</span>) (Wire <span class="mi">291</span>);
             Xor (Wire <span class="mi">90</span>) (Wire <span class="mi">190</span>) (Wire <span class="mi">290</span>);
             Xor (Wire <span class="mi">89</span>) (Wire <span class="mi">189</span>) (Wire <span class="mi">289</span>);
             Xor (Wire <span class="mi">88</span>) (Wire <span class="mi">188</span>) (Wire <span class="mi">288</span>);
             Xor (Wire <span class="mi">87</span>) (Wire <span class="mi">187</span>) (Wire <span class="mi">287</span>);
             Xor (Wire <span class="mi">86</span>) (Wire <span class="mi">186</span>) (Wire <span class="mi">286</span>);
             Xor (Wire <span class="mi">85</span>) (Wire <span class="mi">185</span>) (Wire <span class="mi">285</span>);
             Xor (Wire <span class="mi">84</span>) (Wire <span class="mi">184</span>) (Wire <span class="mi">284</span>);
             Xor (Wire <span class="mi">83</span>) (Wire <span class="mi">183</span>) (Wire <span class="mi">283</span>);
             Xor (Wire <span class="mi">82</span>) (Wire <span class="mi">182</span>) (Wire <span class="mi">282</span>);
             Xor (Wire <span class="mi">81</span>) (Wire <span class="mi">181</span>) (Wire <span class="mi">281</span>);
             Xor (Wire <span class="mi">80</span>) (Wire <span class="mi">180</span>) (Wire <span class="mi">280</span>);
             Xor (Wire <span class="mi">79</span>) (Wire <span class="mi">179</span>) (Wire <span class="mi">279</span>);
             Xor (Wire <span class="mi">78</span>) (Wire <span class="mi">178</span>) (Wire <span class="mi">278</span>);
             Xor (Wire <span class="mi">77</span>) (Wire <span class="mi">177</span>) (Wire <span class="mi">277</span>);
             Xor (Wire <span class="mi">76</span>) (Wire <span class="mi">176</span>) (Wire <span class="mi">276</span>);
             Xor (Wire <span class="mi">75</span>) (Wire <span class="mi">175</span>) (Wire <span class="mi">275</span>);
             Xor (Wire <span class="mi">74</span>) (Wire <span class="mi">174</span>) (Wire <span class="mi">274</span>);
             Xor (Wire <span class="mi">73</span>) (Wire <span class="mi">173</span>) (Wire <span class="mi">273</span>);
             Xor (Wire <span class="mi">72</span>) (Wire <span class="mi">172</span>) (Wire <span class="mi">272</span>);
             Xor (Wire <span class="mi">71</span>) (Wire <span class="mi">171</span>) (Wire <span class="mi">271</span>);
             Xor (Wire <span class="mi">70</span>) (Wire <span class="mi">170</span>) (Wire <span class="mi">270</span>);
             Xor (Wire <span class="mi">69</span>) (Wire <span class="mi">169</span>) (Wire <span class="mi">269</span>);
             Xor (Wire <span class="mi">68</span>) (Wire <span class="mi">168</span>) (Wire <span class="mi">268</span>);
             Xor (Wire <span class="mi">67</span>) (Wire <span class="mi">167</span>) (Wire <span class="mi">267</span>);
             Xor (Wire <span class="mi">66</span>) (Wire <span class="mi">166</span>) (Wire <span class="mi">266</span>);
             Xor (Wire <span class="mi">65</span>) (Wire <span class="mi">165</span>) (Wire <span class="mi">265</span>);
             Xor (Wire <span class="mi">64</span>) (Wire <span class="mi">164</span>) (Wire <span class="mi">264</span>);
             Xor (Wire <span class="mi">63</span>) (Wire <span class="mi">163</span>) (Wire <span class="mi">263</span>);
             Xor (Wire <span class="mi">62</span>) (Wire <span class="mi">162</span>) (Wire <span class="mi">262</span>);
             Xor (Wire <span class="mi">61</span>) (Wire <span class="mi">161</span>) (Wire <span class="mi">261</span>);
             Xor (Wire <span class="mi">60</span>) (Wire <span class="mi">160</span>) (Wire <span class="mi">260</span>);
             Xor (Wire <span class="mi">59</span>) (Wire <span class="mi">159</span>) (Wire <span class="mi">259</span>);
             Xor (Wire <span class="mi">58</span>) (Wire <span class="mi">158</span>) (Wire <span class="mi">258</span>);
             Xor (Wire <span class="mi">57</span>) (Wire <span class="mi">157</span>) (Wire <span class="mi">257</span>);
             Xor (Wire <span class="mi">56</span>) (Wire <span class="mi">156</span>) (Wire <span class="mi">256</span>);
             Xor (Wire <span class="mi">55</span>) (Wire <span class="mi">155</span>) (Wire <span class="mi">255</span>);
             Xor (Wire <span class="mi">54</span>) (Wire <span class="mi">154</span>) (Wire <span class="mi">254</span>);
             Xor (Wire <span class="mi">53</span>) (Wire <span class="mi">153</span>) (Wire <span class="mi">253</span>);
             Xor (Wire <span class="mi">52</span>) (Wire <span class="mi">152</span>) (Wire <span class="mi">252</span>);
             Xor (Wire <span class="mi">51</span>) (Wire <span class="mi">151</span>) (Wire <span class="mi">251</span>);
             Xor (Wire <span class="mi">50</span>) (Wire <span class="mi">150</span>) (Wire <span class="mi">250</span>);
             Xor (Wire <span class="mi">49</span>) (Wire <span class="mi">149</span>) (Wire <span class="mi">249</span>);
             Xor (Wire <span class="mi">48</span>) (Wire <span class="mi">148</span>) (Wire <span class="mi">248</span>);
             Xor (Wire <span class="mi">47</span>) (Wire <span class="mi">147</span>) (Wire <span class="mi">247</span>);
             Xor (Wire <span class="mi">46</span>) (Wire <span class="mi">146</span>) (Wire <span class="mi">246</span>);
             Xor (Wire <span class="mi">45</span>) (Wire <span class="mi">145</span>) (Wire <span class="mi">245</span>);
             Xor (Wire <span class="mi">44</span>) (Wire <span class="mi">144</span>) (Wire <span class="mi">244</span>);
             Xor (Wire <span class="mi">43</span>) (Wire <span class="mi">143</span>) (Wire <span class="mi">243</span>);
             Xor (Wire <span class="mi">42</span>) (Wire <span class="mi">142</span>) (Wire <span class="mi">242</span>);
             Xor (Wire <span class="mi">41</span>) (Wire <span class="mi">141</span>) (Wire <span class="mi">241</span>);
             Xor (Wire <span class="mi">40</span>) (Wire <span class="mi">140</span>) (Wire <span class="mi">240</span>);
             Xor (Wire <span class="mi">39</span>) (Wire <span class="mi">139</span>) (Wire <span class="mi">239</span>);
             Xor (Wire <span class="mi">38</span>) (Wire <span class="mi">138</span>) (Wire <span class="mi">238</span>);
             Xor (Wire <span class="mi">37</span>) (Wire <span class="mi">137</span>) (Wire <span class="mi">237</span>);
             Xor (Wire <span class="mi">36</span>) (Wire <span class="mi">136</span>) (Wire <span class="mi">236</span>);
             Xor (Wire <span class="mi">35</span>) (Wire <span class="mi">135</span>) (Wire <span class="mi">235</span>);
             Xor (Wire <span class="mi">34</span>) (Wire <span class="mi">134</span>) (Wire <span class="mi">234</span>);
             Xor (Wire <span class="mi">33</span>) (Wire <span class="mi">133</span>) (Wire <span class="mi">233</span>);
             Xor (Wire <span class="mi">32</span>) (Wire <span class="mi">132</span>) (Wire <span class="mi">232</span>);
             Xor (Wire <span class="mi">31</span>) (Wire <span class="mi">131</span>) (Wire <span class="mi">231</span>);
             Xor (Wire <span class="mi">30</span>) (Wire <span class="mi">130</span>) (Wire <span class="mi">230</span>);
             Xor (Wire <span class="mi">29</span>) (Wire <span class="mi">129</span>) (Wire <span class="mi">229</span>);
             Xor (Wire <span class="mi">28</span>) (Wire <span class="mi">128</span>) (Wire <span class="mi">228</span>);
             Xor (Wire <span class="mi">27</span>) (Wire <span class="mi">127</span>) (Wire <span class="mi">227</span>);
             Xor (Wire <span class="mi">26</span>) (Wire <span class="mi">126</span>) (Wire <span class="mi">226</span>);
             Xor (Wire <span class="mi">25</span>) (Wire <span class="mi">125</span>) (Wire <span class="mi">225</span>);
             Xor (Wire <span class="mi">24</span>) (Wire <span class="mi">124</span>) (Wire <span class="mi">224</span>);
             Xor (Wire <span class="mi">23</span>) (Wire <span class="mi">123</span>) (Wire <span class="mi">223</span>);
             Xor (Wire <span class="mi">22</span>) (Wire <span class="mi">122</span>) (Wire <span class="mi">222</span>);
             Xor (Wire <span class="mi">21</span>) (Wire <span class="mi">121</span>) (Wire <span class="mi">221</span>);
             Xor (Wire <span class="mi">20</span>) (Wire <span class="mi">120</span>) (Wire <span class="mi">220</span>);
             Xor (Wire <span class="mi">19</span>) (Wire <span class="mi">119</span>) (Wire <span class="mi">219</span>);
             Xor (Wire <span class="mi">18</span>) (Wire <span class="mi">118</span>) (Wire <span class="mi">218</span>);
             Xor (Wire <span class="mi">17</span>) (Wire <span class="mi">117</span>) (Wire <span class="mi">217</span>);
             Xor (Wire <span class="mi">16</span>) (Wire <span class="mi">116</span>) (Wire <span class="mi">216</span>);
             Xor (Wire <span class="mi">15</span>) (Wire <span class="mi">115</span>) (Wire <span class="mi">215</span>);
             Xor (Wire <span class="mi">14</span>) (Wire <span class="mi">114</span>) (Wire <span class="mi">214</span>);
             Xor (Wire <span class="mi">13</span>) (Wire <span class="mi">113</span>) (Wire <span class="mi">213</span>);
             Xor (Wire <span class="mi">12</span>) (Wire <span class="mi">112</span>) (Wire <span class="mi">212</span>);
             Xor (Wire <span class="mi">11</span>) (Wire <span class="mi">111</span>) (Wire <span class="mi">211</span>);
             Xor (Wire <span class="mi">10</span>) (Wire <span class="mi">110</span>) (Wire <span class="mi">210</span>);
             Xor (Wire <span class="mi">9</span>) (Wire <span class="mi">109</span>) (Wire <span class="mi">209</span>);
             Xor (Wire <span class="mi">8</span>) (Wire <span class="mi">108</span>) (Wire <span class="mi">208</span>);
             Xor (Wire <span class="mi">7</span>) (Wire <span class="mi">107</span>) (Wire <span class="mi">207</span>);
             Xor (Wire <span class="mi">6</span>) (Wire <span class="mi">106</span>) (Wire <span class="mi">206</span>);
             Xor (Wire <span class="mi">5</span>) (Wire <span class="mi">105</span>) (Wire <span class="mi">205</span>);
             Xor (Wire <span class="mi">4</span>) (Wire <span class="mi">104</span>) (Wire <span class="mi">204</span>);
             Xor (Wire <span class="mi">3</span>) (Wire <span class="mi">103</span>) (Wire <span class="mi">203</span>);
             Xor (Wire <span class="mi">2</span>) (Wire <span class="mi">102</span>) (Wire <span class="mi">202</span>);
             Xor (Wire <span class="mi">1</span>) (Wire <span class="mi">101</span>) (Wire <span class="mi">201</span>);
             Xor (Wire <span class="mi">0</span>) (Wire <span class="mi">100</span>) (Wire <span class="mi">200</span>);
             AssignSignal (Wire <span class="mi">199</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">99</span>);
             AssignSignal (Wire <span class="mi">198</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">98</span>);
             AssignSignal (Wire <span class="mi">197</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">97</span>);
             AssignSignal (Wire <span class="mi">196</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">96</span>);
             AssignSignal (Wire <span class="mi">195</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">95</span>);
             AssignSignal (Wire <span class="mi">194</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">94</span>);
             AssignSignal (Wire <span class="mi">193</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">93</span>);
             AssignSignal (Wire <span class="mi">192</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">92</span>);
             AssignSignal (Wire <span class="mi">191</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">91</span>);
             AssignSignal (Wire <span class="mi">190</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">90</span>);
             AssignSignal (Wire <span class="mi">189</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">89</span>);
             AssignSignal (Wire <span class="mi">188</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">88</span>);
             AssignSignal (Wire <span class="mi">187</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">87</span>);
             AssignSignal (Wire <span class="mi">186</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">86</span>);
             AssignSignal (Wire <span class="mi">185</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">85</span>);
             AssignSignal (Wire <span class="mi">184</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">84</span>);
             AssignSignal (Wire <span class="mi">183</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">83</span>);
             AssignSignal (Wire <span class="mi">182</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">82</span>);
             AssignSignal (Wire <span class="mi">181</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">81</span>);
             AssignSignal (Wire <span class="mi">180</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">80</span>);
             AssignSignal (Wire <span class="mi">179</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">79</span>);
             AssignSignal (Wire <span class="mi">178</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">78</span>);
             AssignSignal (Wire <span class="mi">177</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">77</span>);
             AssignSignal (Wire <span class="mi">176</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">76</span>);
             AssignSignal (Wire <span class="mi">175</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">75</span>);
             AssignSignal (Wire <span class="mi">174</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">74</span>);
             AssignSignal (Wire <span class="mi">173</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">73</span>);
             AssignSignal (Wire <span class="mi">172</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">72</span>);
             AssignSignal (Wire <span class="mi">171</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">71</span>);
             AssignSignal (Wire <span class="mi">170</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">70</span>);
             AssignSignal (Wire <span class="mi">169</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">69</span>);
             AssignSignal (Wire <span class="mi">168</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">68</span>);
             AssignSignal (Wire <span class="mi">167</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">67</span>);
             AssignSignal (Wire <span class="mi">166</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">66</span>);
             AssignSignal (Wire <span class="mi">165</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">65</span>);
             AssignSignal (Wire <span class="mi">164</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">64</span>);
             AssignSignal (Wire <span class="mi">163</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">63</span>);
             AssignSignal (Wire <span class="mi">162</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">62</span>);
             AssignSignal (Wire <span class="mi">161</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">61</span>);
             AssignSignal (Wire <span class="mi">160</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">60</span>);
             AssignSignal (Wire <span class="mi">159</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">59</span>);
             AssignSignal (Wire <span class="mi">158</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">58</span>);
             AssignSignal (Wire <span class="mi">157</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">57</span>);
             AssignSignal (Wire <span class="mi">156</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">56</span>);
             AssignSignal (Wire <span class="mi">155</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">55</span>);
             AssignSignal (Wire <span class="mi">154</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">54</span>);
             AssignSignal (Wire <span class="mi">153</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">53</span>);
             AssignSignal (Wire <span class="mi">152</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">52</span>);
             AssignSignal (Wire <span class="mi">151</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">51</span>);
             AssignSignal (Wire <span class="mi">150</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">50</span>);
             AssignSignal (Wire <span class="mi">149</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">49</span>);
             AssignSignal (Wire <span class="mi">148</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">48</span>);
             AssignSignal (Wire <span class="mi">147</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">47</span>);
             AssignSignal (Wire <span class="mi">146</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">46</span>);
             AssignSignal (Wire <span class="mi">145</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">45</span>);
             AssignSignal (Wire <span class="mi">144</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">44</span>);
             AssignSignal (Wire <span class="mi">143</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">43</span>);
             AssignSignal (Wire <span class="mi">142</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">42</span>);
             AssignSignal (Wire <span class="mi">141</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">41</span>);
             AssignSignal (Wire <span class="mi">140</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">40</span>);
             AssignSignal (Wire <span class="mi">139</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">39</span>);
             AssignSignal (Wire <span class="mi">138</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">38</span>);
             AssignSignal (Wire <span class="mi">137</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">37</span>);
             AssignSignal (Wire <span class="mi">136</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">36</span>);
             AssignSignal (Wire <span class="mi">135</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">35</span>);
             AssignSignal (Wire <span class="mi">134</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">34</span>);
             AssignSignal (Wire <span class="mi">133</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">33</span>);
             AssignSignal (Wire <span class="mi">132</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">32</span>);
             AssignSignal (Wire <span class="mi">131</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">31</span>);
             AssignSignal (Wire <span class="mi">130</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">30</span>);
             AssignSignal (Wire <span class="mi">129</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">29</span>);
             AssignSignal (Wire <span class="mi">128</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">28</span>);
             AssignSignal (Wire <span class="mi">127</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">27</span>);
             AssignSignal (Wire <span class="mi">126</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">26</span>);
             AssignSignal (Wire <span class="mi">125</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">25</span>);
             AssignSignal (Wire <span class="mi">124</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">24</span>);
             AssignSignal (Wire <span class="mi">123</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">23</span>);
             AssignSignal (Wire <span class="mi">122</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">22</span>);
             AssignSignal (Wire <span class="mi">121</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">21</span>);
             AssignSignal (Wire <span class="mi">120</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">20</span>);
             AssignSignal (Wire <span class="mi">119</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">19</span>);
             AssignSignal (Wire <span class="mi">118</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">18</span>);
             AssignSignal (Wire <span class="mi">117</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">17</span>);
             AssignSignal (Wire <span class="mi">116</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">16</span>);
             AssignSignal (Wire <span class="mi">115</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">15</span>);
             AssignSignal (Wire <span class="mi">114</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">14</span>);
             AssignSignal (Wire <span class="mi">113</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">13</span>);
             AssignSignal (Wire <span class="mi">112</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">12</span>);
             AssignSignal (Wire <span class="mi">111</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">11</span>);
             AssignSignal (Wire <span class="mi">110</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">10</span>);
             AssignSignal (Wire <span class="mi">109</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">9</span>);
             AssignSignal (Wire <span class="mi">108</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">8</span>);
             AssignSignal (Wire <span class="mi">107</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">7</span>);
             AssignSignal (Wire <span class="mi">106</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">6</span>);
             AssignSignal (Wire <span class="mi">105</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">5</span>);
             AssignSignal (Wire <span class="mi">104</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">4</span>);
             AssignSignal (Wire <span class="mi">103</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">3</span>);
             AssignSignal (Wire <span class="mi">102</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">2</span>);
             AssignSignal (Wire <span class="mi">101</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">1</span>);
             AssignSignal (Wire <span class="mi">100</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">0</span>);
             AssignSignal (Wire <span class="mi">99</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">99</span>);
             AssignSignal (Wire <span class="mi">98</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">98</span>);
             AssignSignal (Wire <span class="mi">97</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">97</span>);
             AssignSignal (Wire <span class="mi">96</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">96</span>);
             AssignSignal (Wire <span class="mi">95</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">95</span>);
             AssignSignal (Wire <span class="mi">94</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">94</span>);
             AssignSignal (Wire <span class="mi">93</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">93</span>);
             AssignSignal (Wire <span class="mi">92</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">92</span>);
             AssignSignal (Wire <span class="mi">91</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">91</span>);
             AssignSignal (Wire <span class="mi">90</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">90</span>);
             AssignSignal (Wire <span class="mi">89</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">89</span>);
             AssignSignal (Wire <span class="mi">88</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">88</span>);
             AssignSignal (Wire <span class="mi">87</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">87</span>);
             AssignSignal (Wire <span class="mi">86</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">86</span>);
             AssignSignal (Wire <span class="mi">85</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">85</span>);
             AssignSignal (Wire <span class="mi">84</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">84</span>);
             AssignSignal (Wire <span class="mi">83</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">83</span>);
             AssignSignal (Wire <span class="mi">82</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">82</span>);
             AssignSignal (Wire <span class="mi">81</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">81</span>);
             AssignSignal (Wire <span class="mi">80</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">80</span>);
             AssignSignal (Wire <span class="mi">79</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">79</span>);
             AssignSignal (Wire <span class="mi">78</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">78</span>);
             AssignSignal (Wire <span class="mi">77</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">77</span>);
             AssignSignal (Wire <span class="mi">76</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">76</span>);
             AssignSignal (Wire <span class="mi">75</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">75</span>);
             AssignSignal (Wire <span class="mi">74</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">74</span>);
             AssignSignal (Wire <span class="mi">73</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">73</span>);
             AssignSignal (Wire <span class="mi">72</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">72</span>);
             AssignSignal (Wire <span class="mi">71</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">71</span>);
             AssignSignal (Wire <span class="mi">70</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">70</span>);
             AssignSignal (Wire <span class="mi">69</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">69</span>);
             AssignSignal (Wire <span class="mi">68</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">68</span>);
             AssignSignal (Wire <span class="mi">67</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">67</span>);
             AssignSignal (Wire <span class="mi">66</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">66</span>);
             AssignSignal (Wire <span class="mi">65</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">65</span>);
             AssignSignal (Wire <span class="mi">64</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">64</span>);
             AssignSignal (Wire <span class="mi">63</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">63</span>);
             AssignSignal (Wire <span class="mi">62</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">62</span>);
             AssignSignal (Wire <span class="mi">61</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">61</span>);
             AssignSignal (Wire <span class="mi">60</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">60</span>);
             AssignSignal (Wire <span class="mi">59</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">59</span>);
             AssignSignal (Wire <span class="mi">58</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">58</span>);
             AssignSignal (Wire <span class="mi">57</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">57</span>);
             AssignSignal (Wire <span class="mi">56</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">56</span>);
             AssignSignal (Wire <span class="mi">55</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">55</span>);
             AssignSignal (Wire <span class="mi">54</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">54</span>);
             AssignSignal (Wire <span class="mi">53</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">53</span>);
             AssignSignal (Wire <span class="mi">52</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">52</span>);
             AssignSignal (Wire <span class="mi">51</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">51</span>);
             AssignSignal (Wire <span class="mi">50</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">50</span>);
             AssignSignal (Wire <span class="mi">49</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">49</span>);
             AssignSignal (Wire <span class="mi">48</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">48</span>);
             AssignSignal (Wire <span class="mi">47</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">47</span>);
             AssignSignal (Wire <span class="mi">46</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">46</span>);
             AssignSignal (Wire <span class="mi">45</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">45</span>);
             AssignSignal (Wire <span class="mi">44</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">44</span>);
             AssignSignal (Wire <span class="mi">43</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">43</span>);
             AssignSignal (Wire <span class="mi">42</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">42</span>);
             AssignSignal (Wire <span class="mi">41</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">41</span>);
             AssignSignal (Wire <span class="mi">40</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">40</span>);
             AssignSignal (Wire <span class="mi">39</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">39</span>);
             AssignSignal (Wire <span class="mi">38</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">38</span>);
             AssignSignal (Wire <span class="mi">37</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">37</span>);
             AssignSignal (Wire <span class="mi">36</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">36</span>);
             AssignSignal (Wire <span class="mi">35</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">35</span>);
             AssignSignal (Wire <span class="mi">34</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">34</span>);
             AssignSignal (Wire <span class="mi">33</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">33</span>);
             AssignSignal (Wire <span class="mi">32</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">32</span>);
             AssignSignal (Wire <span class="mi">31</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">31</span>);
             AssignSignal (Wire <span class="mi">30</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">30</span>);
             AssignSignal (Wire <span class="mi">29</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">29</span>);
             AssignSignal (Wire <span class="mi">28</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">28</span>);
             AssignSignal (Wire <span class="mi">27</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">27</span>);
             AssignSignal (Wire <span class="mi">26</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">26</span>);
             AssignSignal (Wire <span class="mi">25</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">25</span>);
             AssignSignal (Wire <span class="mi">24</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">24</span>);
             AssignSignal (Wire <span class="mi">23</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">23</span>);
             AssignSignal (Wire <span class="mi">22</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">22</span>);
             AssignSignal (Wire <span class="mi">21</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">21</span>);
             AssignSignal (Wire <span class="mi">20</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">20</span>);
             AssignSignal (Wire <span class="mi">19</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">19</span>);
             AssignSignal (Wire <span class="mi">18</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">18</span>);
             AssignSignal (Wire <span class="mi">17</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">17</span>);
             AssignSignal (Wire <span class="mi">16</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">16</span>);
             AssignSignal (Wire <span class="mi">15</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">15</span>);
             AssignSignal (Wire <span class="mi">14</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">14</span>);
             AssignSignal (Wire <span class="mi">13</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">13</span>);
             AssignSignal (Wire <span class="mi">12</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">12</span>);
             AssignSignal (Wire <span class="mi">11</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">11</span>);
             AssignSignal (Wire <span class="mi">10</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">10</span>);
             AssignSignal (Wire <span class="mi">9</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">9</span>);
             AssignSignal (Wire <span class="mi">8</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">8</span>);
             AssignSignal (Wire <span class="mi">7</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">7</span>);
             AssignSignal (Wire <span class="mi">6</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">6</span>);
             AssignSignal (Wire <span class="mi">5</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">5</span>);
             AssignSignal (Wire <span class="mi">4</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">4</span>);
             AssignSignal (Wire <span class="mi">3</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">3</span>);
             AssignSignal (Wire <span class="mi">2</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">2</span>);
             AssignSignal (Wire <span class="mi">1</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">1</span>);
             AssignSignal (Wire <span class="mi">0</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">0</span>)];
  inputs := [{|
             port_name := <span class="s2">&quot;v2&quot;</span>;
             port_type := Vec Bit <span class="mi">100</span> |};
            {|
            port_name := <span class="s2">&quot;v1&quot;</span>;
            port_type := Vec Bit <span class="mi">100</span> |};
            {|
            port_name := <span class="s2">&quot;rst&quot;</span>;
            port_type := Bit |};
            {|
            port_name := <span class="s2">&quot;clk&quot;</span>;
            port_type := Bit |}];
  outputs := [{|
              port_name := <span class="s2">&quot;o&quot;</span>;
              port_type := Vec Bit <span class="mi">100</span> |}] |}
: <span class="kn">Module</span></span></blockquote></div></div></small></span></pre><p>Simulations are the same; just plug in any size.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight"><span class="c">(* 7 xor 10 = 13 (n=8) (same as xor_byte) *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk24"><span class="highlight"><span class="kn">Compute</span> map Bv2N
        (simulate (xor_bitvec <span class="mi">8</span>) [(N2Bv_sized <span class="mi">8</span> <span class="mi">7</span>, N2Bv_sized <span class="mi">8</span> <span class="mi">10</span>)]).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= [<span class="mi">13</span>%N]
: list N</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* 1 xor 3 = 2 (n=2) *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk25"><span class="highlight"><span class="kn">Compute</span> map Bv2N
        (simulate (xor_bitvec <span class="mi">2</span>) [(N2Bv_sized <span class="mi">2</span> <span class="mi">1</span>, N2Bv_sized <span class="mi">2</span> <span class="mi">3</span>)]).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= [<span class="mi">2</span>%N]
: list N</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* 1000 xor 3 = 1003 (n=10) *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk26"><span class="highlight"><span class="kn">Compute</span> map Bv2N
        (simulate (xor_bitvec <span class="mi">10</span>)
                  [(N2Bv_sized <span class="mi">10</span> <span class="mi">1000</span>, N2Bv_sized <span class="mi">10</span> <span class="mi">3</span>)]).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= [<span class="mi">1003</span>%N]
: list N</span></blockquote></div></div></small></span></pre><p>The correctness proof has is exactly the same as the <tt class="docutils literal">xor_byte</tt> proof, except
with <tt class="docutils literal">n</tt> instead of <tt class="docutils literal">8</tt>; the proof body is completely unchanged.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk27"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">xor_bitvec_correct</span>
      <span class="nv">n</span> (<span class="nv">i</span> : list (Vector.t bool n * Vector.t bool n)) :
  simulate (xor_bitvec n) i = map (<span class="kr">fun</span> &#39;(v1,v2) =&gt; BVxor n v1 v2) i.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t bool n * t bool n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate (xor_bitvec n) i =
map (<span class="kr">fun</span> &#39;(v1, v2) =&gt; BVxor n v1 v2) i</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk28"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t bool n * t bool n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate (xor_bitvec n) i =
map (<span class="kr">fun</span> &#39;(v1, v2) =&gt; BVxor n v1 v2) i</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk29"><span class="highlight"><span class="nb">cbv</span> [xor_bitvec].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t bool n * t bool n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate (Comb (<span class="kr">fun</span> &#39;(v1, v2) =&gt; Vec.map2 xor2 v1 v2))
  i = map (<span class="kr">fun</span> &#39;(v1, v2) =&gt; BVxor n v1 v2) i</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk2a"><span class="highlight"><span class="nb">autorewrite with</span> push_simulate.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t bool n * t bool n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map (<span class="kr">fun</span> &#39;(v1, v2) =&gt; Vec.map2 xor2 v1 v2) i =
map (<span class="kr">fun</span> &#39;(v1, v2) =&gt; BVxor n v1 v2) i</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk2b"><span class="highlight"><span class="nb">apply</span> map_ext; <span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t bool n * t bool n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(t bool n * t bool n)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">let</span> &#39;(v1, v2) := a <span class="kr">in</span> Vec.map2 xor2 v1 v2) =
(<span class="kr">let</span> &#39;(v1, v2) := a <span class="kr">in</span> BVxor n v1 v2)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk2c"><span class="highlight">destruct_pair_let.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t bool n * t bool n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(t bool n * t bool n)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Vec.map2 xor2 (fst a) (snd a) =
BVxor n (fst a) (snd a)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk2d"><span class="highlight"><span class="nb">cbv</span> [BVxor].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t bool n * t bool n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(t bool n * t bool n)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Vec.map2 xor2 (fst a) (snd a) =
Vector.map2 xorb (fst a) (snd a)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk2e"><span class="highlight">simpl_ident.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t bool n * t bool n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(t bool n * t bool n)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xor2 (x, y))
  (fst a) (snd a) = Vector.map2 xorb (fst a) (snd a)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk2f"><span class="highlight"><span class="nb">apply</span> Vector.map2_ext.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t bool n * t bool n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(t bool n * t bool n)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : combType Bit, xor2 (a, b) = xorb a b</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>We can also easily prove that, for 8-bit vectors, <tt class="docutils literal">xor_bitvec</tt> is equivalent
to <tt class="docutils literal">xor_byte</tt>:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk30"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">xor_bitvec_xor_byte_equiv</span>
      (<span class="nv">i</span> : list (Vector.t bool <span class="mi">8</span> * Vector.t bool <span class="mi">8</span>)) :
  simulate (xor_bitvec <span class="mi">8</span>) i = simulate xor_byte i.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t bool <span class="mi">8</span> * t bool <span class="mi">8</span>)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate (xor_bitvec <span class="mi">8</span>) i = simulate xor_byte i</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk31"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t bool <span class="mi">8</span> * t bool <span class="mi">8</span>)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate (xor_bitvec <span class="mi">8</span>) i = simulate xor_byte i</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>This example demonstrates the advantage of using a proof assistant instead of a
more computational method. The <tt class="docutils literal">xor_bitvec_correct</tt> proof checks essentially
instantly and holds for <em>all</em> values of <tt class="docutils literal">n</tt>. With one circuit definition, and
one proof, you have defined every single length of bit-vector xor you'll ever
need. The same principle can apply to more complicated structures as well.</p>
</div>
<div class="section" id="example-4-tree-of-xors">
<h1>Example 4: Tree of xors</h1>
<p>To take the last circuit a step further, let's consider xoring not just two
<tt class="docutils literal">n</tt>-length vectors, but an arbitrary number <tt class="docutils literal">m</tt> of <tt class="docutils literal">n</tt>-length vectors!</p>
<p>Simulations</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk32"><span class="highlight"><span class="kn">Compute</span> map Bv2N
        (simulate xor_tree
                  [[N2Bv_sized <span class="mi">8</span> <span class="mi">7</span>; N2Bv_sized <span class="mi">8</span> <span class="mi">10</span>]%vector]).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= [<span class="mi">13</span>%N]
: list N</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk33"><span class="highlight"><span class="kn">Compute</span> map Bv2N
        (simulate xor_tree
                  [[ N2Bv_sized <span class="mi">8</span> <span class="mi">1</span>
                     ; N2Bv_sized <span class="mi">8</span> <span class="mi">2</span>
                     ; N2Bv_sized <span class="mi">8</span> <span class="mi">4</span>
                     ; N2Bv_sized <span class="mi">8</span> <span class="mi">8</span>
                     ; N2Bv_sized <span class="mi">8</span> <span class="mi">16</span>
                     ; N2Bv_sized <span class="mi">8</span> <span class="mi">32</span>
                     ; N2Bv_sized <span class="mi">8</span> <span class="mi">64</span>
                     ; N2Bv_sized <span class="mi">8</span> <span class="mi">128</span>
                   ]%vector]).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= [<span class="mi">255</span>%N]
: list N</span></blockquote></div></div></small></span></pre><p>Proofs</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk34"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">xor_tree_correct</span> <span class="nv">n</span> <span class="nv">m</span> (<span class="nv">i</span> : list (Vector.t (Vector.t bool n) m)) :
  m &lt;&gt; <span class="mi">0</span> -&gt; <span class="c">(* rule out size-0 tree *)</span>
  simulate xor_tree i = map (<span class="kr">fun</span> <span class="nv">vs</span> =&gt;
                               Vector.fold_left
                                 (BVxor n) (N2Bv_sized n <span class="mi">0</span>) vs) i.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t (t bool n) m)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">m &lt;&gt; <span class="mi">0</span> -&gt;
simulate xor_tree i =
map
  (<span class="kr">fun</span> <span class="nv">vs</span> : t (t bool n) m =&gt;
   Vector.fold_left (BVxor n) (N2Bv_sized n <span class="mi">0</span>) vs) i</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk35"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t (t bool n) m)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">m &lt;&gt; <span class="mi">0</span> -&gt;
simulate xor_tree i =
map
  (<span class="kr">fun</span> <span class="nv">vs</span> : t (t bool n) m =&gt;
   Vector.fold_left (BVxor n) (N2Bv_sized n <span class="mi">0</span>) vs) i</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk36"><span class="highlight"><span class="nb">cbv</span> [xor_tree].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t (t bool n) m)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">m &lt;&gt; <span class="mi">0</span> -&gt;
simulate
  (Comb (tree (<span class="kr">fun</span> &#39;(v1, v2) =&gt; Vec.map2 xor2 v1 v2)))
  i =
map
  (<span class="kr">fun</span> <span class="nv">vs</span> : t (t bool n) m =&gt;
   Vector.fold_left (BVxor n) (N2Bv_sized n <span class="mi">0</span>) vs) i</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk37"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t (t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate
  (Comb (tree (<span class="kr">fun</span> &#39;(v1, v2) =&gt; Vec.map2 xor2 v1 v2)))
  i =
map
  (<span class="kr">fun</span> <span class="nv">vs</span> : t (t bool n) m =&gt;
   Vector.fold_left (BVxor n) (N2Bv_sized n <span class="mi">0</span>) vs) i</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk38"><span class="highlight"><span class="nb">autorewrite with</span> push_simulate.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t (t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map (tree (<span class="kr">fun</span> &#39;(v1, v2) =&gt; Vec.map2 xor2 v1 v2)) i =
map
  (<span class="kr">fun</span> <span class="nv">vs</span> : t (t bool n) m =&gt;
   Vector.fold_left (BVxor n) (N2Bv_sized n <span class="mi">0</span>) vs) i</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk39"><span class="highlight"><span class="nb">apply</span> map_ext; <span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t (t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t (t bool n) m</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tree (<span class="kr">fun</span> &#39;(v1, v2) =&gt; Vec.map2 xor2 v1 v2) a =
Vector.fold_left (BVxor n) (N2Bv_sized n <span class="mi">0</span>) a</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk3a"><span class="highlight"><span class="nb">apply</span> (tree_equiv (t:=Vec Bit n)); <span class="nb">intros</span>; <span class="nb">auto</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t (t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t (t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">BVxor n (N2Bv_sized n <span class="mi">0</span>) a0 = a0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tutorial-v-chk3b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t (t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t (t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="tutorial-v-chk3b"><hr></label><div class="goal-conclusion"><span class="highlight">BVxor n a0 (N2Bv_sized n <span class="mi">0</span>) = a0</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="tutorial-v-chk3c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t (t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t (t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0, b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="tutorial-v-chk3c"><hr></label><div class="goal-conclusion"><span class="highlight">BVxor n a0 (BVxor n b c) = BVxor n (BVxor n a0 b) c</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="tutorial-v-chk3d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t (t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t (t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0, b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="tutorial-v-chk3d"><hr></label><div class="goal-conclusion"><span class="highlight">Vec.map2 xor2 a0 b = BVxor n a0 b</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk3e"><span class="highlight">{ <span class="c">(* 0 is a left identity *)</span></span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t (t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t (t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">BVxor n (N2Bv_sized n <span class="mi">0</span>) a0 = a0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk3f"><span class="highlight"><span class="nb">apply</span> Bv2N_inj.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t (t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t (t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Bv2N (BVxor n (N2Bv_sized n <span class="mi">0</span>) a0) = Bv2N a0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk40"><span class="highlight"><span class="nb">autorewrite with</span> push_Bv2N.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t (t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t (t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N.lxor <span class="mi">0</span> (Bv2N a0) = Bv2N a0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> N.lxor_0_l.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk41"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t (t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t (t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">BVxor n a0 (N2Bv_sized n <span class="mi">0</span>) = a0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tutorial-v-chk42" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t (t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t (t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0, b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="tutorial-v-chk42"><hr></label><div class="goal-conclusion"><span class="highlight">BVxor n a0 (BVxor n b c) = BVxor n (BVxor n a0 b) c</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="tutorial-v-chk43" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t (t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t (t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0, b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="tutorial-v-chk43"><hr></label><div class="goal-conclusion"><span class="highlight">Vec.map2 xor2 a0 b = BVxor n a0 b</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk44"><span class="highlight">{ <span class="c">(* 0 is a right identity *)</span></span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t (t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t (t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">BVxor n a0 (N2Bv_sized n <span class="mi">0</span>) = a0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk45"><span class="highlight"><span class="nb">apply</span> Bv2N_inj.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t (t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t (t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Bv2N (BVxor n a0 (N2Bv_sized n <span class="mi">0</span>)) = Bv2N a0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk46"><span class="highlight"><span class="nb">autorewrite with</span> push_Bv2N.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t (t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t (t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N.lxor (Bv2N a0) <span class="mi">0</span> = Bv2N a0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> N.lxor_0_r.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk47"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t (t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t (t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0, b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">BVxor n a0 (BVxor n b c) = BVxor n (BVxor n a0 b) c</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tutorial-v-chk48" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t (t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t (t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0, b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="tutorial-v-chk48"><hr></label><div class="goal-conclusion"><span class="highlight">Vec.map2 xor2 a0 b = BVxor n a0 b</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk49"><span class="highlight">{ <span class="c">(* xor is associative *)</span></span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t (t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t (t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0, b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">BVxor n a0 (BVxor n b c) = BVxor n (BVxor n a0 b) c</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk4a"><span class="highlight"><span class="nb">apply</span> Bv2N_inj.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t (t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t (t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0, b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Bv2N (BVxor n a0 (BVxor n b c)) =
Bv2N (BVxor n (BVxor n a0 b) c)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk4b"><span class="highlight"><span class="nb">autorewrite with</span> push_Bv2N.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t (t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t (t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0, b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N.lxor (Bv2N a0) (N.lxor (Bv2N b) (Bv2N c)) =
N.lxor (N.lxor (Bv2N a0) (Bv2N b)) (Bv2N c)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk4c"><span class="highlight"><span class="nb">symmetry</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t (t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t (t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0, b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N.lxor (N.lxor (Bv2N a0) (Bv2N b)) (Bv2N c) =
N.lxor (Bv2N a0) (N.lxor (Bv2N b) (Bv2N c))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> N.lxor_assoc.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk4d"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t (t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t (t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0, b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Vec.map2 xor2 a0 b = BVxor n a0 b</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk4e"><span class="highlight">{ <span class="c">(* xor circuit is equivalent to BVxor *)</span></span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t (t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t (t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0, b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Vec.map2 xor2 a0 b = BVxor n a0 b</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk4f"><span class="highlight"><span class="nb">cbv</span> [BVxor].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t (t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t (t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0, b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Vec.map2 xor2 a0 b = Vector.map2 xorb a0 b</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk50"><span class="highlight">simpl_ident.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t (t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t (t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0, b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xor2 (x, y)) a0
  b = Vector.map2 xorb a0 b</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk51"><span class="highlight"><span class="nb">apply</span> Vector.map2_ext.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t (t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t (t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0, b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : combType Bit, xor2 (a, b) = xorb a b</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">}</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk52"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">xor_bitvec_xor_tree_equiv</span>
      <span class="nv">n</span> (<span class="nv">i</span> : list (Vector.t bool n * Vector.t bool n)) :
  simulate (xor_bitvec n) i =
  simulate xor_tree (map (<span class="kr">fun</span> &#39;(v1,v2) =&gt; [v1;v2]%vector) i).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t bool n * t bool n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate (xor_bitvec n) i =
simulate xor_tree
  (map (<span class="kr">fun</span> &#39;(v1, v2) =&gt; [v1; v2]%vector) i)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk53"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t bool n * t bool n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate (xor_bitvec n) i =
simulate xor_tree
  (map (<span class="kr">fun</span> &#39;(v1, v2) =&gt; [v1; v2]%vector) i)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk54"><span class="highlight"><span class="nb">cbv</span> [xor_bitvec xor_tree]; <span class="nb">autorewrite with</span> push_simulate.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t bool n * t bool n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map (<span class="kr">fun</span> &#39;(v1, v2) =&gt; Vec.map2 xor2 v1 v2) i =
map (tree (<span class="kr">fun</span> &#39;(v1, v2) =&gt; Vec.map2 xor2 v1 v2))
  (map (<span class="kr">fun</span> &#39;(v1, v2) =&gt; [v1; v2]%vector) i)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk55"><span class="highlight"><span class="nb">rewrite</span> map_map.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t bool n * t bool n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map (<span class="kr">fun</span> &#39;(v1, v2) =&gt; Vec.map2 xor2 v1 v2) i =
map
  (<span class="kr">fun</span> <span class="nv">x</span> : t bool n * t bool n =&gt;
   tree (<span class="kr">fun</span> &#39;(v1, v2) =&gt; Vec.map2 xor2 v1 v2)
     (<span class="kr">let</span> &#39;(v1, v2) := x <span class="kr">in</span> [v1; v2]%vector)) i</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk56"><span class="highlight"><span class="nb">apply</span> map_ext; <span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t bool n * t bool n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(t bool n * t bool n)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">let</span> &#39;(v1, v2) := a <span class="kr">in</span> Vec.map2 xor2 v1 v2) =
tree (<span class="kr">fun</span> &#39;(v1, v2) =&gt; Vec.map2 xor2 v1 v2)
  (<span class="kr">let</span> &#39;(v1, v2) := a <span class="kr">in</span> [v1; v2]%vector)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk57"><span class="highlight">destruct_pair_let.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t bool n * t bool n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(t bool n * t bool n)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Vec.map2 xor2 (fst a) (snd a) =
tree (<span class="kr">fun</span> &#39;(v1, v2) =&gt; Vec.map2 xor2 v1 v2)
  [fst a; snd a]%vector</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="c">(* The tree lemma produces the same side conditions as before, but</span>
<span class="c">     we solve them here in a more concise way *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk58"><span class="highlight"><span class="nb">erewrite</span> @tree_equiv <span class="kr">with</span>
      (t:=Vec Bit n) (op:=BVxor n) (id:=N2Bv_sized n <span class="mi">0</span>)
    <span class="bp">by</span> (<span class="nb">intros</span>; <span class="nb">auto</span>; simpl_ident; <span class="nb">apply</span> Bv2N_inj;
        <span class="nb">autorewrite with</span> push_Bv2N;
        <span class="nb">auto using</span> N.lxor_0_r, N.lxor_0_l, N.lxor_assoc).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t bool n * t bool n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(t bool n * t bool n)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Vec.map2 xor2 (fst a) (snd a) =
Vector.fold_left (BVxor n) (N2Bv_sized n <span class="mi">0</span>)
  [fst a; snd a]</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk59"><span class="highlight"><span class="nb">autorewrite with</span> push_vector_fold vsimpl.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t bool n * t bool n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(t bool n * t bool n)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Vec.map2 xor2 (fst a) (snd a) =
BVxor n (BVxor n (N2Bv_sized n <span class="mi">0</span>) (fst a)) (snd a)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk5a"><span class="highlight">simpl_ident.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t bool n * t bool n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(t bool n * t bool n)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xor2 (x, y))
  (fst a) (snd a) =
BVxor n (BVxor n (N2Bv_sized n <span class="mi">0</span>) (fst a)) (snd a)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk5b"><span class="highlight"><span class="nb">apply</span> Bv2N_inj.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t bool n * t bool n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(t bool n * t bool n)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Bv2N
  (Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xor2 (x, y))
     (fst a) (snd a)) =
Bv2N
  (BVxor n (BVxor n (N2Bv_sized n <span class="mi">0</span>) (fst a)) (snd a))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk5c"><span class="highlight"><span class="nb">autorewrite with</span> push_Bv2N.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t bool n * t bool n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(t bool n * t bool n)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N.lxor (Bv2N (fst a)) (Bv2N (snd a)) =
N.lxor (N.lxor <span class="mi">0</span> (Bv2N (fst a))) (Bv2N (snd a))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk5d"><span class="highlight"><span class="nb">rewrite</span> N.lxor_0_l.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (t bool n * t bool n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(t bool n * t bool n)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N.lxor (Bv2N (fst a)) (Bv2N (snd a)) =
N.lxor (Bv2N (fst a)) (Bv2N (snd a))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre></div>
</div>
</div></body>
</html>
