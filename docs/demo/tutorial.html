<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.16: http://docutils.sourceforge.net/" />
<title>Tutorial</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.min.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.12.0+0.12.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="tutorial">
<h1 class="title">Tutorial</h1>

<link rel="stylesheet" href="tutorial.css" type="text/css" /><p>Welcome! This is a quick primer for designing circuits with Cava. We'll walk
through a few small examples end-to-end. This tutorial will not explain Coq
syntax in depth, but will use the same few patterns throughout; you shouldn't
need to know Coq to follow along.</p>
<p>Use Ctrl+down and Ctrl+up to step through the Coq code along with the
tutorial. Use Ctrl+click to focus on a particular line.</p>
<div class="section" id="preliminaries">
<h1>Preliminaries</h1>
<p>To import the core Cava library you need to define and simulate circuits, just:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> Cava.Cava.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Import</span> Circuit.Notations.</span></span></span></pre><p>If you also want to do proofs about circuits, this import should have everything you need:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> Cava.CavaProperties.</span></span></span></pre></div>
<div class="section" id="example-1-inverter">
<h1>Example 1 : Inverter</h1>
<p>To start, let's define a 1-bit inverter.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">inverter</span>
           {<span class="nv">signal</span> : SignalType -&gt; <span class="kt">Type</span>}
           {<span class="nv">semantics</span> : Cava signal}
  : Circuit (signal Bit) (signal Bit) :=
  Comb inv.</span></span></span></pre><p>A few things to notice here:</p>
<ul class="simple">
<li><tt class="docutils literal">SignalType</tt> is Cava's type system. The inverter is parameterized over
<tt class="docutils literal">signal</tt>, which converts <tt class="docutils literal">SignalType</tt>s to Coq types. <tt class="docutils literal">Bit</tt> is one
example of a <tt class="docutils literal">SignalType</tt>; we'll see more examples later on.</li>
<li><tt class="docutils literal">Comb</tt> is short for &quot;combinational&quot;; our inverter has no loops, registers,
or timing requirements, so it is a purely combinational circuit.</li>
<li>The inverter is also paramterized over <tt class="docutils literal">semantics</tt>, an instance of the
typeclass <tt class="docutils literal">Cava</tt>. This instance provides implementations of circuit
primitives, such as 1-bit logic gates. One primitive gate is a 1-bit inverter
<tt class="docutils literal">inv</tt>, so our inverter is just a simple invocation of the primitive.</li>
</ul>
<p>Normally, we'd write circuit definitions a little more concisely by writing them
inside a <tt class="docutils literal">Section</tt> that contains <tt class="docutils literal">signal</tt> and <tt class="docutils literal">semantics</tt> as context
variables, like this:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">WithCava</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> {<span class="nv">signal</span>} {<span class="nv">semantics</span> : Cava signal}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">inverter_concise</span> : Circuit (signal Bit) (signal Bit)
    := Comb inv.</span></span></span></pre><p>For the rest of the circuit definitions in this tutorial, you can assume that
we're inside the section and that every definition is parameterized over the
<tt class="docutils literal">signal</tt> and <tt class="docutils literal">semantics</tt> context variables.</p>
<p>Back to our inverter. Let's take a closer look at the <tt class="docutils literal">inv</tt> primitive.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk0"><span class="highlight"><span class="kn">About</span> inv.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">inv :
<span class="kr">forall</span> {<span class="nv">signal</span> : SignalType -&gt; <span class="kt">Type</span>}
  {<span class="nv">Cava</span> : Cava signal},
signal Bit -&gt; cava (signal Bit)

inv <span class="kr">is</span> not universe polymorphic
<span class="kn">Arguments</span> inv {signal}%function_scope {Cava}
inv <span class="kr">is</span> transparent
Expands to: Constant Cava.Core.CavaClass.inv</span></blockquote></div></div></small></span></pre><p>You can see in the type signature <tt class="docutils literal">signal Bit <span class="pre">-&gt;</span> cava (signal Bit)</tt> that
<tt class="docutils literal">inv</tt> is defined as a pure Coq function in terms of a monad called
<tt class="docutils literal">cava</tt>. The <tt class="docutils literal">cava</tt> monad, like <tt class="docutils literal">inv</tt>, is provided by <tt class="docutils literal">semantics</tt>. The
monad is used to capture sharing; it's semantically different in Cava to write:</p>
<pre class="literal-block">
x &lt;- inv zero ;;
y &lt;- inv zero ;;
xor2 x y
</pre>
<p>than it is to write:</p>
<pre class="literal-block">
x &lt;- inv zero ;;
xor2 x x
</pre>
<p>Both expressions have the same meaning, and if we were using Gallina <tt class="docutils literal">let</tt>
binders there would be no difference. But the generated circuit can use two
wires for the first definition, and fork the same wire in the second. As circuit
diagrams, this is the difference between:</p>
<pre class="literal-block">
       +-----+      +-----+
0 -----| inv |------|     |
       +-----+      | xor |----- out
       +-----+      |     |
0 -----| inv |------|     |
       +-----+      +-----+
</pre>
<p>and:</p>
<pre class="literal-block">
                      +-----+
                  +---|     |
                  |   | xor |---- out
       +-----+    |   |     |
0 -----| inv |----+---|     |
       +-----+        +-----+
</pre>
<p>This difference isn't significant in determining what the value of <tt class="docutils literal">out</tt> will
be, but it can be very useful when trying to exercise fine-grained control over
circuit layout and area! At a first approximation, you can think of a monadic
bind (<tt class="docutils literal">_ &lt;- _ ;; ...</tt>) as <em>naming a wire</em> in the circuit graph.</p>
<p>If the monad notations are unfamiliar, the <a class="reference external" href="/reference">reference</a> has more information on
those.</p>
<p>We could have represented sharing by describing circuit graphs with a list of
nodes and edges. However, this is essentially the &quot;machine code&quot; of structural
hardware descriptions, and is far too tedious a representation for humans to
work with. The monadic-function abstraction allows human engineers to think
about the functional behavior and composition of circuits at a more intuitive
level.</p>
<p>Parameterizing over the <tt class="docutils literal">cava</tt> monad and primitive implementations allows us
to use different instances of <tt class="docutils literal">Cava</tt> to interpret the same circuit definition
in different ways. One <tt class="docutils literal">Cava</tt> instance generates netlists by adding and
connecting wires in the background using a state monad. For circuit simulations
and proofs of functional correctness, on the other hand, we don't care about
sharing at all; these use no-op identity monad that acts the same as a <tt class="docutils literal">let</tt>
binder.</p>
<p>Let's use our <tt class="docutils literal">inverter</tt> definition to see these two interpretations in
action.</p>
<p>First, let's generate a netlist. We need to define an interface that describes the
circuit's input and output ports and behavior relative to the (global) clock and
reset signals. Then we can compute a netlist (type <tt class="docutils literal">CavaState</tt>), which
describes the full layout of the circuit in a way that can be easily translated
to SystemVerilog.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight"><span class="c">(* netlist-generating semantics *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Existing Instance</span> <span class="nf">CavaCombinationalNet</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">inverter_interface</span>
  := sequentialInterface <span class="s2">&quot;inverter_interface&quot;</span>
     <span class="s2">&quot;clk&quot;</span> PositiveEdge <span class="s2">&quot;rst&quot;</span> PositiveEdge
     [mkPort <span class="s2">&quot;i&quot;</span> Bit]
     [mkPort <span class="s2">&quot;o&quot;</span> Bit].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk1"><span class="highlight"><span class="kn">Compute</span> makeCircuitNetlist inverter_interface inverter.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= {|
  netNumber := <span class="mi">1</span>;
  vectorNumber := <span class="mi">0</span>;
  vectorDeclarations := [];
  externalDeclarations := [];
  clockNet := Some (NamedWire <span class="s2">&quot;clk&quot;</span>);
  clockEdge := PositiveEdge;
  resetNet := Some (NamedWire <span class="s2">&quot;rst&quot;</span>);
  resetEdge := PositiveEdge;
  module := {|
            moduleName := <span class="s2">&quot;inverter_interface&quot;</span>;
            netlist := [AssignSignal
                          (NamedWire <span class="s2">&quot;o&quot;</span>)
                          (Wire <span class="mi">0</span>);
                       Not (NamedWire <span class="s2">&quot;i&quot;</span>)
                         (Wire <span class="mi">0</span>)];
            inputs := [{|
                       port_name := <span class="s2">&quot;i&quot;</span>;
                       port_type := Bit |};
                      {|
                      port_name := <span class="s2">&quot;rst&quot;</span>;
                      port_type := Bit |};
                      {|
                      port_name := <span class="s2">&quot;clk&quot;</span>;
                      port_type := Bit |}];
            outputs := [{|
                        port_name := <span class="s2">&quot;o&quot;</span>;
                        port_type := Bit |}] |};
  libraryModules := [] |}
: CavaState</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* A closer look at the circuit body *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk2"><span class="highlight"><span class="kn">Compute</span> (makeCircuitNetlist inverter_interface inverter).(module).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= {|
  moduleName := <span class="s2">&quot;inverter_interface&quot;</span>;
  netlist := [AssignSignal (NamedWire <span class="s2">&quot;o&quot;</span>)
                (Wire <span class="mi">0</span>);
             Not (NamedWire <span class="s2">&quot;i&quot;</span>) (Wire <span class="mi">0</span>)];
  inputs := [{|
             port_name := <span class="s2">&quot;i&quot;</span>;
             port_type := Bit |};
            {|
            port_name := <span class="s2">&quot;rst&quot;</span>;
            port_type := Bit |};
            {|
            port_name := <span class="s2">&quot;clk&quot;</span>;
            port_type := Bit |}];
  outputs := [{|
              port_name := <span class="s2">&quot;o&quot;</span>;
              port_type := Bit |}] |}
: <span class="kn">Module</span></span></blockquote></div></div></small></span></pre><p>You may notice that we're using something called <tt class="docutils literal">sequentialInterface</tt> here,
and referring to clock and reset signals, even though our inverter is a purely
combinational circuit. We introduce timing in the netlist interface here in
order to drive the circuit with multiple inputs over time, and to plug it in as
a subcomponent of circuits that are not combinational.</p>
<p>Now, let's simulate the circuit, which can be useful for testing and proving
functional correctness. Here, we use the identity-monad interpretation. The
<tt class="docutils literal">signal</tt> for this <tt class="docutils literal">Cava</tt> instance is <tt class="docutils literal">combType</tt>, which interprets a
<tt class="docutils literal">Bit</tt> simply as a Coq <tt class="docutils literal">bool</tt>. If we provide the three inputs
<tt class="docutils literal">[true; false; true]</tt> to the circuit simulation function <tt class="docutils literal">simulate</tt>, we'll
get <tt class="docutils literal">[false; true; false]</tt>:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight"><span class="c">(* identity-monad semantics *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Existing Instance</span> <span class="nf">CombinationalSemantics</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk3"><span class="highlight"><span class="kn">Compute</span> simulate inverter [true; false; true].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= [false; true; false]
: list (combType Bit)</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk4"><span class="highlight"><span class="kn">Compute</span> simulate inverter [true; false; true; true; true; false].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= [false; true; false; false; false; true]
: list (combType Bit)</span></blockquote></div></div></small></span></pre><p>We can use the simulation to write proofs about the circuit. For instance, we
can prove that <tt class="docutils literal">inverter</tt> obeys a natural Coq specification:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk5"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">inverter_correct</span> (<span class="nv">input</span> : list bool) :
  simulate inverter input = map negb input.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate inverter input = map negb input</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk6"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate inverter input = map negb input</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">  <span class="c">(* inline the circuit definition *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk7"><span class="highlight"><span class="nb">cbv</span> [inverter].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate (Comb inv) input = map negb input</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="c">(* simplify simulate to create an expression in terms of Coq lists *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk8"><span class="highlight"><span class="nb">autorewrite with</span> push_simulate.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map inv input = map negb input</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="c">(* assert that the two List.map functions are equivalent *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk9"><span class="highlight"><span class="nb">apply</span> map_ext.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> : bool, inv a = negb a</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chka"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">inv a = negb a</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="c">(* inline the inv primitive (fun x =&gt; ret (negb x)) *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chkb"><span class="highlight"><span class="nb">cbn</span> [inv CombinationalSemantics].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ret (negb a) = negb a</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="c">(* simplify the identity monad expressions *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chkc"><span class="highlight">simpl_ident.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">negb a = negb a</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>We can even prove that composing two inverters is the same as doing
nothing. Here, <tt class="docutils literal"><span class="pre">&gt;==&gt;</span></tt> is circuit composition (a Kleisli arrow). The proof
structure is pretty similar.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chkd"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">inverter_idempotent</span> (<span class="nv">input</span> : list bool) :
  simulate (inverter &gt;==&gt; inverter) input = input.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate (inverter &gt;==&gt; inverter) input = input</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chke"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate (inverter &gt;==&gt; inverter) input = input</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chkf"><span class="highlight"><span class="nb">cbv</span> [inverter].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate (Comb inv &gt;==&gt; Comb inv) input = input</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk10"><span class="highlight"><span class="nb">autorewrite with</span> push_simulate.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map inv (map inv input) = input</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk11"><span class="highlight"><span class="nb">rewrite</span> map_map.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map (<span class="kr">fun</span> <span class="nv">x</span> : combType Bit =&gt; inv (inv x)) input =
input</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk12"><span class="highlight"><span class="nb">apply</span> List.map_id_ext.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> : combType Bit, inv (inv a) = a</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk13"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType Bit</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">inv (inv a) = a</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk14"><span class="highlight"><span class="nb">cbn</span> [inv CombinationalSemantics].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType Bit</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ret (negb (ret (negb a))) = a</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk15"><span class="highlight">simpl_ident.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType Bit</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">negb (negb a) = a</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> Bool.negb_involutive.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>A note about reading Coq proofs: in general, it's more important to understand
the lemma statement (the part before <tt class="docutils literal">Proof</tt>) than it is to understand the
proof body. The lemma statement shows what is being proven, and the proof body
contains an &quot;argument&quot; to Coq that the statement is true.</p>
<p>To summarize, there are three things you can do with Cava circuits:</p>
<ol class="arabic simple">
<li>Define them (parameterized over an abstract <tt class="docutils literal">Cava</tt> instance)</li>
<li>Generate netlists for them using the <tt class="docutils literal">CavaCombinationalNet</tt> instance and
the <tt class="docutils literal">makeCircuitNetlist</tt> function. These netlists can then be translated into
SystemVerilog.</li>
<li>Simulate them using <tt class="docutils literal">simulate</tt>, and prove things about the simulations, by
plugging in the <tt class="docutils literal">CombinationalSemantics</tt> instance.</li>
</ol>
<p>In the following examples, we'll use this exact same three-part pattern to
explore more complex circuits.</p>
</div>
<div class="section" id="example-2-byte-xor">
<h1>Example 2 : Byte xor</h1>
<p>Our next example is a circuit that xors two bytes:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">  </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">xor_byte</span> :
    Circuit (signal (Vec Bit <span class="mi">8</span>) * signal (Vec Bit <span class="mi">8</span>))
            (signal (Vec Bit <span class="mi">8</span>)) :=
    Comb (Vec.map2 xor2).</span></span></span></pre><p>This circuit maps a 1-bit xor (<tt class="docutils literal">xor2</tt>) over the two input vectors. <tt class="docutils literal">xor2</tt> is
one of the primitives provided by the <tt class="docutils literal">Cava</tt> instance, like <tt class="docutils literal">inv</tt>. Once
again, this is a combinational circuit, so we define it by wrapping a monadic
function with <tt class="docutils literal">Comb</tt>.</p>
<p>The <tt class="docutils literal">Vec</tt> here is another <tt class="docutils literal">SignalType</tt>, with a slightly more complicated
construction than <tt class="docutils literal">Bit</tt>. A <tt class="docutils literal">Vec Bit 8</tt> is a vector of 8 bits: a
byte. Vectors can be formed from any other <tt class="docutils literal">SignalType</tt>, including other
vectors; <tt class="docutils literal">Vec (Vec (Vec Bit 8) 4) 2)</tt> is a valid construction representing a
two-dimensional array of bytes (equivalently, a three-dimensional array of
bits).</p>
<p>The <tt class="docutils literal">Vec.map2</tt> definition is from Cava's vector library. It's important not to
confuse <tt class="docutils literal">Vec</tt>, the <tt class="docutils literal">SignalType</tt> in Cava's type system, with <tt class="docutils literal">Vector.t</tt>,
Coq's standard library vector type. In simulation, <tt class="docutils literal">Vec</tt> is translated into
<tt class="docutils literal">Vector.t</tt>, so you may see both in the codebase. You can also convert back and
forth between <tt class="docutils literal">Vec</tt> and <tt class="docutils literal">Vector.t</tt> using the Cava primitives <tt class="docutils literal">packV</tt> and
<tt class="docutils literal">unpackV</tt>. However, Cava's vector library mirrors most of the definitions
available for Coq standard library vectors, so it's usually best to use those
definitions instead: use <tt class="docutils literal">Vec.map2</tt> instead of <tt class="docutils literal">unpackV</tt>, <tt class="docutils literal">Vector.map2</tt>,
and <tt class="docutils literal">packV</tt>.</p>
<p>To see more definitions from Cava's core library, try taking a look at the Cava
<a class="reference external" href="/reference">reference</a>, which documents its contents.</p>
<p>To generate a netlist for this circuit, we use mostly the same procedure as for
the inverter, except that we change the input and output port types to match the
circuit's type signature.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">xor_byte_interface</span>
  := sequentialInterface <span class="s2">&quot;xor_byte_interface&quot;</span>
     <span class="s2">&quot;clk&quot;</span> PositiveEdge <span class="s2">&quot;rst&quot;</span> PositiveEdge
     [mkPort <span class="s2">&quot;v1&quot;</span> (Vec Bit <span class="mi">8</span>); mkPort <span class="s2">&quot;v2&quot;</span> (Vec Bit <span class="mi">8</span>)]
     [mkPort <span class="s2">&quot;o&quot;</span> (Vec Bit <span class="mi">8</span>)].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk16"><span class="highlight"><span class="kn">Compute</span> (makeCircuitNetlist xor_byte_interface xor_byte).(module).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= {|
  moduleName := <span class="s2">&quot;xor_byte_interface&quot;</span>;
  netlist := [AssignSignal
                (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;o&quot;</span>)
                (LocalVec Bit <span class="mi">8</span> <span class="mi">0</span>);
             AssignSignal (LocalVec Bit <span class="mi">8</span> <span class="mi">0</span>)
               (VecLit
                  [Wire <span class="mi">16</span>; Wire <span class="mi">17</span>; Wire <span class="mi">18</span>;
                  Wire <span class="mi">19</span>; Wire <span class="mi">20</span>; Wire <span class="mi">21</span>;
                  Wire <span class="mi">22</span>; Wire <span class="mi">23</span>]);
             Xor (Wire <span class="mi">7</span>) (Wire <span class="mi">15</span>) (Wire <span class="mi">23</span>);
             Xor (Wire <span class="mi">6</span>) (Wire <span class="mi">14</span>) (Wire <span class="mi">22</span>);
             Xor (Wire <span class="mi">5</span>) (Wire <span class="mi">13</span>) (Wire <span class="mi">21</span>);
             Xor (Wire <span class="mi">4</span>) (Wire <span class="mi">12</span>) (Wire <span class="mi">20</span>);
             Xor (Wire <span class="mi">3</span>) (Wire <span class="mi">11</span>) (Wire <span class="mi">19</span>);
             Xor (Wire <span class="mi">2</span>) (Wire <span class="mi">10</span>) (Wire <span class="mi">18</span>);
             Xor (Wire <span class="mi">1</span>) (Wire <span class="mi">9</span>) (Wire <span class="mi">17</span>);
             Xor (Wire <span class="mi">0</span>) (Wire <span class="mi">8</span>) (Wire <span class="mi">16</span>);
             AssignSignal (Wire <span class="mi">15</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">7</span>);
             AssignSignal (Wire <span class="mi">14</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">6</span>);
             AssignSignal (Wire <span class="mi">13</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">5</span>);
             AssignSignal (Wire <span class="mi">12</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">4</span>);
             AssignSignal (Wire <span class="mi">11</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">3</span>);
             AssignSignal (Wire <span class="mi">10</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">2</span>);
             AssignSignal (Wire <span class="mi">9</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">1</span>);
             AssignSignal (Wire <span class="mi">8</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">0</span>);
             AssignSignal (Wire <span class="mi">7</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">7</span>);
             AssignSignal (Wire <span class="mi">6</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">6</span>);
             AssignSignal (Wire <span class="mi">5</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">5</span>);
             AssignSignal (Wire <span class="mi">4</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">4</span>);
             AssignSignal (Wire <span class="mi">3</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">3</span>);
             AssignSignal (Wire <span class="mi">2</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">2</span>);
             AssignSignal (Wire <span class="mi">1</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">1</span>);
             AssignSignal (Wire <span class="mi">0</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">0</span>)];
  inputs := [{|
             port_name := <span class="s2">&quot;v2&quot;</span>;
             port_type := Vec Bit <span class="mi">8</span> |};
            {|
            port_name := <span class="s2">&quot;v1&quot;</span>;
            port_type := Vec Bit <span class="mi">8</span> |};
            {|
            port_name := <span class="s2">&quot;rst&quot;</span>;
            port_type := Bit |};
            {|
            port_name := <span class="s2">&quot;clk&quot;</span>;
            port_type := Bit |}];
  outputs := [{|
              port_name := <span class="s2">&quot;o&quot;</span>;
              port_type := Vec Bit <span class="mi">8</span> |}] |}
: <span class="kn">Module</span></span></blockquote></div></div></small></span></pre><p>Tuples in the input or output types become lists of ports for the netlist
interface, so <tt class="docutils literal">signal (Vec Bit 8) * signal (Vec Bit 8)</tt> becomes <tt class="docutils literal">[mkPort &quot;v1&quot;
(Vec Bit 8); mkPort &quot;v2&quot; (Vec Bit 8)]</tt>. The names of the ports (&quot;v1&quot;, &quot;v2&quot;, and
&quot;o&quot;) are just for readability and potentially for reference by other netlists;
they can be named however you prefer.</p>
<p>We can also, as before, simulate the circuit.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk17"><span class="highlight"><span class="kn">Compute</span>
  simulate xor_byte
  [([true;  true; true;  false; false; false; false; false],
    [false; true; false; true;  false; false; false; false])].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= [[true; false; true; true; false; false; false;
   false]%vector]%list
: list (combType (Vec Bit <span class="mi">8</span>))</span></blockquote></div></div></small></span></pre><p>Literal bit vectors are not especially readable, though; it's not immediately
clear that this simulation is 7 xor 10 = 13. For simulations with bitvectors,
it's often clearer to use natural-number-to-bitvector conversions from the Coq
standard library :</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk18"><span class="highlight"><span class="kn">Compute</span> map Bv2N
        (simulate xor_byte [(N2Bv_sized <span class="mi">8</span> <span class="mi">7</span>, N2Bv_sized <span class="mi">8</span> <span class="mi">10</span>)]).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= [<span class="mi">13</span>%N]%list
: list N</span></blockquote></div></div></small></span></pre><p>Finally, we can prove that the circuit is correct. In this case, we prove that
the circuit's behavior matches the <tt class="docutils literal">BVxor</tt> definition from the standard
library, specialized to bit-vectors of length 8.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk19"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">xor_byte_correct</span> (<span class="nv">i</span> : list (Vector.t bool <span class="mi">8</span> * Vector.t bool <span class="mi">8</span>)) :
  simulate xor_byte i = map (<span class="kr">fun</span> &#39;(v1,v2) =&gt; BVxor <span class="mi">8</span> v1 v2) i.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t bool <span class="mi">8</span> * Vector.t bool <span class="mi">8</span>)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate xor_byte i =
map (<span class="kr">fun</span> &#39;(v1, v2) =&gt; BVxor <span class="mi">8</span> v1 v2) i</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk1a"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t bool <span class="mi">8</span> * Vector.t bool <span class="mi">8</span>)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate xor_byte i =
map (<span class="kr">fun</span> &#39;(v1, v2) =&gt; BVxor <span class="mi">8</span> v1 v2) i</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk1b"><span class="highlight"><span class="nb">cbv</span> [xor_byte].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t bool <span class="mi">8</span> * Vector.t bool <span class="mi">8</span>)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate (Comb (Vec.map2 xor2)) i =
map (<span class="kr">fun</span> &#39;(v1, v2) =&gt; BVxor <span class="mi">8</span> v1 v2) i</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk1c"><span class="highlight"><span class="nb">autorewrite with</span> push_simulate.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t bool <span class="mi">8</span> * Vector.t bool <span class="mi">8</span>)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map (Vec.map2 xor2) i =
map (<span class="kr">fun</span> &#39;(v1, v2) =&gt; BVxor <span class="mi">8</span> v1 v2) i</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk1d"><span class="highlight"><span class="nb">apply</span> map_ext; <span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t bool <span class="mi">8</span> * Vector.t bool <span class="mi">8</span>)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(Vector.t bool <span class="mi">8</span> * Vector.t bool <span class="mi">8</span>)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Vec.map2 xor2 a =
(<span class="kr">let</span> &#39;(v1, v2) := a <span class="kr">in</span> BVxor <span class="mi">8</span> v1 v2)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk1e"><span class="highlight">destruct_pair_let.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t bool <span class="mi">8</span> * Vector.t bool <span class="mi">8</span>)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(Vector.t bool <span class="mi">8</span> * Vector.t bool <span class="mi">8</span>)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Vec.map2 xor2 (fst a, snd a) = BVxor <span class="mi">8</span> (fst a) (snd a)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk1f"><span class="highlight"><span class="nb">cbv</span> [BVxor].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t bool <span class="mi">8</span> * Vector.t bool <span class="mi">8</span>)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(Vector.t bool <span class="mi">8</span> * Vector.t bool <span class="mi">8</span>)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Vec.map2 xor2 (fst a, snd a) =
Vector.map2 xorb (fst a) (snd a)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk20"><span class="highlight">simpl_ident.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t bool <span class="mi">8</span> * Vector.t bool <span class="mi">8</span>)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(Vector.t bool <span class="mi">8</span> * Vector.t bool <span class="mi">8</span>)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xorb x y)
  (fst a) (snd a) = Vector.map2 xorb (fst a) (snd a)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk21"><span class="highlight"><span class="nb">apply</span> Vector.map2_ext.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t bool <span class="mi">8</span> * Vector.t bool <span class="mi">8</span>)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(Vector.t bool <span class="mi">8</span> * Vector.t bool <span class="mi">8</span>)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : combType Bit, xorb a b = xorb a b</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>Again, no need to focus too much on the body of the proof here; understanding
the lemma statement is the most important part. However, one interesting thing
to note is that the proof is not computational; we don't analyze the 2^16
possibile inputs separately. In fact, we never destruct the vectors or refer to
the length at all, which leads us to our next example.</p>
</div>
<div class="section" id="example-3-bit-vector-xor">
<h1>Example 3: Bit-vector xor</h1>
<p>As it turns out, we can define <tt class="docutils literal">xor_byte</tt> over <em>arbitrary-length</em> bitvectors
with very little modification. The circuit is virtually identical, except that
it takes a length argument <tt class="docutils literal">n</tt> and all the <tt class="docutils literal">8</tt>s are replaced with <tt class="docutils literal">n</tt>:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">  </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">xor_bitvec</span> (<span class="nv">n</span> : nat) :
    Circuit (signal (Vec Bit n) * signal (Vec Bit n))
            (signal (Vec Bit n)) :=
    Comb (Vec.map2 xor2).</span></span></span></pre><p>We can define an interface for this circuit that also takes <tt class="docutils literal">n</tt> as an
argument, and then compute a netlist for any number of gates we want.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">xor_bitvec_interface</span> {<span class="nv">n</span> : nat}
  := sequentialInterface <span class="s2">&quot;xor_bitvec_interface&quot;</span>
     <span class="s2">&quot;clk&quot;</span> PositiveEdge <span class="s2">&quot;rst&quot;</span> PositiveEdge
     [mkPort <span class="s2">&quot;v1&quot;</span> (Vec Bit n); mkPort <span class="s2">&quot;v2&quot;</span> (Vec Bit n)]
     [mkPort <span class="s2">&quot;o&quot;</span> (Vec Bit n)].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* Netlist for a 2-bit xor *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk22"><span class="highlight"><span class="kn">Compute</span>
  (makeCircuitNetlist xor_bitvec_interface (xor_bitvec <span class="mi">2</span>)).(module).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= {|
  moduleName := <span class="s2">&quot;xor_bitvec_interface&quot;</span>;
  netlist := [AssignSignal
                (NamedVector Bit <span class="mi">2</span> <span class="s2">&quot;o&quot;</span>)
                (LocalVec Bit <span class="mi">2</span> <span class="mi">0</span>);
             AssignSignal (LocalVec Bit <span class="mi">2</span> <span class="mi">0</span>)
               (VecLit [Wire <span class="mi">4</span>; Wire <span class="mi">5</span>]);
             Xor (Wire <span class="mi">1</span>) (Wire <span class="mi">3</span>) (Wire <span class="mi">5</span>);
             Xor (Wire <span class="mi">0</span>) (Wire <span class="mi">2</span>) (Wire <span class="mi">4</span>);
             AssignSignal (Wire <span class="mi">3</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">2</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">1</span>);
             AssignSignal (Wire <span class="mi">2</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">2</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">0</span>);
             AssignSignal (Wire <span class="mi">1</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">2</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">1</span>);
             AssignSignal (Wire <span class="mi">0</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">2</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">0</span>)];
  inputs := [{|
             port_name := <span class="s2">&quot;v2&quot;</span>;
             port_type := Vec Bit <span class="mi">2</span> |};
            {|
            port_name := <span class="s2">&quot;v1&quot;</span>;
            port_type := Vec Bit <span class="mi">2</span> |};
            {|
            port_name := <span class="s2">&quot;rst&quot;</span>;
            port_type := Bit |};
            {|
            port_name := <span class="s2">&quot;clk&quot;</span>;
            port_type := Bit |}];
  outputs := [{|
              port_name := <span class="s2">&quot;o&quot;</span>;
              port_type := Vec Bit <span class="mi">2</span> |}] |}
: <span class="kn">Module</span></span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* Netlist for a 100-bit xor! *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk23"><span class="highlight"><span class="kn">Compute</span>
  (makeCircuitNetlist xor_bitvec_interface (xor_bitvec <span class="mi">100</span>)).(module).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= {|
  moduleName := <span class="s2">&quot;xor_bitvec_interface&quot;</span>;
  netlist := [AssignSignal
                (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;o&quot;</span>)
                (LocalVec Bit <span class="mi">100</span> <span class="mi">0</span>);
             AssignSignal (LocalVec Bit <span class="mi">100</span> <span class="mi">0</span>)
               (VecLit
                  [Wire <span class="mi">200</span>; Wire <span class="mi">201</span>; Wire <span class="mi">202</span>;
                  Wire <span class="mi">203</span>; Wire <span class="mi">204</span>; Wire <span class="mi">205</span>;
                  Wire <span class="mi">206</span>; Wire <span class="mi">207</span>; Wire <span class="mi">208</span>;
                  Wire <span class="mi">209</span>; Wire <span class="mi">210</span>; Wire <span class="mi">211</span>;
                  Wire <span class="mi">212</span>; Wire <span class="mi">213</span>; Wire <span class="mi">214</span>;
                  Wire <span class="mi">215</span>; Wire <span class="mi">216</span>; Wire <span class="mi">217</span>;
                  Wire <span class="mi">218</span>; Wire <span class="mi">219</span>; Wire <span class="mi">220</span>;
                  Wire <span class="mi">221</span>; Wire <span class="mi">222</span>; Wire <span class="mi">223</span>;
                  Wire <span class="mi">224</span>; Wire <span class="mi">225</span>; Wire <span class="mi">226</span>;
                  Wire <span class="mi">227</span>; Wire <span class="mi">228</span>; Wire <span class="mi">229</span>;
                  Wire <span class="mi">230</span>; Wire <span class="mi">231</span>; Wire <span class="mi">232</span>;
                  Wire <span class="mi">233</span>; Wire <span class="mi">234</span>; Wire <span class="mi">235</span>;
                  Wire <span class="mi">236</span>; Wire <span class="mi">237</span>; Wire <span class="mi">238</span>;
                  Wire <span class="mi">239</span>; Wire <span class="mi">240</span>; Wire <span class="mi">241</span>;
                  Wire <span class="mi">242</span>; Wire <span class="mi">243</span>; Wire <span class="mi">244</span>;
                  Wire <span class="mi">245</span>; Wire <span class="mi">246</span>; Wire <span class="mi">247</span>;
                  Wire <span class="mi">248</span>; Wire <span class="mi">249</span>; Wire <span class="mi">250</span>;
                  Wire <span class="mi">251</span>; Wire <span class="mi">252</span>; Wire <span class="mi">253</span>;
                  Wire <span class="mi">254</span>; Wire <span class="mi">255</span>; Wire <span class="mi">256</span>;
                  Wire <span class="mi">257</span>; Wire <span class="mi">258</span>; Wire <span class="mi">259</span>;
                  Wire <span class="mi">260</span>; Wire <span class="mi">261</span>; Wire <span class="mi">262</span>;
                  Wire <span class="mi">263</span>; Wire <span class="mi">264</span>; Wire <span class="mi">265</span>;
                  Wire <span class="mi">266</span>; Wire <span class="mi">267</span>; Wire <span class="mi">268</span>;
                  Wire <span class="mi">269</span>; Wire <span class="mi">270</span>; Wire <span class="mi">271</span>;
                  Wire <span class="mi">272</span>; Wire <span class="mi">273</span>; Wire <span class="mi">274</span>;
                  Wire <span class="mi">275</span>; Wire <span class="mi">276</span>; Wire <span class="mi">277</span>;
                  Wire <span class="mi">278</span>; Wire <span class="mi">279</span>; Wire <span class="mi">280</span>;
                  Wire <span class="mi">281</span>; Wire <span class="mi">282</span>; Wire <span class="mi">283</span>;
                  Wire <span class="mi">284</span>; Wire <span class="mi">285</span>; Wire <span class="mi">286</span>;
                  Wire <span class="mi">287</span>; Wire <span class="mi">288</span>; Wire <span class="mi">289</span>;
                  Wire <span class="mi">290</span>; Wire <span class="mi">291</span>; Wire <span class="mi">292</span>;
                  Wire <span class="mi">293</span>; Wire <span class="mi">294</span>; Wire <span class="mi">295</span>;
                  Wire <span class="mi">296</span>; Wire <span class="mi">297</span>; Wire <span class="mi">298</span>;
                  Wire <span class="mi">299</span>]);
             Xor (Wire <span class="mi">99</span>) (Wire <span class="mi">199</span>) (Wire <span class="mi">299</span>);
             Xor (Wire <span class="mi">98</span>) (Wire <span class="mi">198</span>) (Wire <span class="mi">298</span>);
             Xor (Wire <span class="mi">97</span>) (Wire <span class="mi">197</span>) (Wire <span class="mi">297</span>);
             Xor (Wire <span class="mi">96</span>) (Wire <span class="mi">196</span>) (Wire <span class="mi">296</span>);
             Xor (Wire <span class="mi">95</span>) (Wire <span class="mi">195</span>) (Wire <span class="mi">295</span>);
             Xor (Wire <span class="mi">94</span>) (Wire <span class="mi">194</span>) (Wire <span class="mi">294</span>);
             Xor (Wire <span class="mi">93</span>) (Wire <span class="mi">193</span>) (Wire <span class="mi">293</span>);
             Xor (Wire <span class="mi">92</span>) (Wire <span class="mi">192</span>) (Wire <span class="mi">292</span>);
             Xor (Wire <span class="mi">91</span>) (Wire <span class="mi">191</span>) (Wire <span class="mi">291</span>);
             Xor (Wire <span class="mi">90</span>) (Wire <span class="mi">190</span>) (Wire <span class="mi">290</span>);
             Xor (Wire <span class="mi">89</span>) (Wire <span class="mi">189</span>) (Wire <span class="mi">289</span>);
             Xor (Wire <span class="mi">88</span>) (Wire <span class="mi">188</span>) (Wire <span class="mi">288</span>);
             Xor (Wire <span class="mi">87</span>) (Wire <span class="mi">187</span>) (Wire <span class="mi">287</span>);
             Xor (Wire <span class="mi">86</span>) (Wire <span class="mi">186</span>) (Wire <span class="mi">286</span>);
             Xor (Wire <span class="mi">85</span>) (Wire <span class="mi">185</span>) (Wire <span class="mi">285</span>);
             Xor (Wire <span class="mi">84</span>) (Wire <span class="mi">184</span>) (Wire <span class="mi">284</span>);
             Xor (Wire <span class="mi">83</span>) (Wire <span class="mi">183</span>) (Wire <span class="mi">283</span>);
             Xor (Wire <span class="mi">82</span>) (Wire <span class="mi">182</span>) (Wire <span class="mi">282</span>);
             Xor (Wire <span class="mi">81</span>) (Wire <span class="mi">181</span>) (Wire <span class="mi">281</span>);
             Xor (Wire <span class="mi">80</span>) (Wire <span class="mi">180</span>) (Wire <span class="mi">280</span>);
             Xor (Wire <span class="mi">79</span>) (Wire <span class="mi">179</span>) (Wire <span class="mi">279</span>);
             Xor (Wire <span class="mi">78</span>) (Wire <span class="mi">178</span>) (Wire <span class="mi">278</span>);
             Xor (Wire <span class="mi">77</span>) (Wire <span class="mi">177</span>) (Wire <span class="mi">277</span>);
             Xor (Wire <span class="mi">76</span>) (Wire <span class="mi">176</span>) (Wire <span class="mi">276</span>);
             Xor (Wire <span class="mi">75</span>) (Wire <span class="mi">175</span>) (Wire <span class="mi">275</span>);
             Xor (Wire <span class="mi">74</span>) (Wire <span class="mi">174</span>) (Wire <span class="mi">274</span>);
             Xor (Wire <span class="mi">73</span>) (Wire <span class="mi">173</span>) (Wire <span class="mi">273</span>);
             Xor (Wire <span class="mi">72</span>) (Wire <span class="mi">172</span>) (Wire <span class="mi">272</span>);
             Xor (Wire <span class="mi">71</span>) (Wire <span class="mi">171</span>) (Wire <span class="mi">271</span>);
             Xor (Wire <span class="mi">70</span>) (Wire <span class="mi">170</span>) (Wire <span class="mi">270</span>);
             Xor (Wire <span class="mi">69</span>) (Wire <span class="mi">169</span>) (Wire <span class="mi">269</span>);
             Xor (Wire <span class="mi">68</span>) (Wire <span class="mi">168</span>) (Wire <span class="mi">268</span>);
             Xor (Wire <span class="mi">67</span>) (Wire <span class="mi">167</span>) (Wire <span class="mi">267</span>);
             Xor (Wire <span class="mi">66</span>) (Wire <span class="mi">166</span>) (Wire <span class="mi">266</span>);
             Xor (Wire <span class="mi">65</span>) (Wire <span class="mi">165</span>) (Wire <span class="mi">265</span>);
             Xor (Wire <span class="mi">64</span>) (Wire <span class="mi">164</span>) (Wire <span class="mi">264</span>);
             Xor (Wire <span class="mi">63</span>) (Wire <span class="mi">163</span>) (Wire <span class="mi">263</span>);
             Xor (Wire <span class="mi">62</span>) (Wire <span class="mi">162</span>) (Wire <span class="mi">262</span>);
             Xor (Wire <span class="mi">61</span>) (Wire <span class="mi">161</span>) (Wire <span class="mi">261</span>);
             Xor (Wire <span class="mi">60</span>) (Wire <span class="mi">160</span>) (Wire <span class="mi">260</span>);
             Xor (Wire <span class="mi">59</span>) (Wire <span class="mi">159</span>) (Wire <span class="mi">259</span>);
             Xor (Wire <span class="mi">58</span>) (Wire <span class="mi">158</span>) (Wire <span class="mi">258</span>);
             Xor (Wire <span class="mi">57</span>) (Wire <span class="mi">157</span>) (Wire <span class="mi">257</span>);
             Xor (Wire <span class="mi">56</span>) (Wire <span class="mi">156</span>) (Wire <span class="mi">256</span>);
             Xor (Wire <span class="mi">55</span>) (Wire <span class="mi">155</span>) (Wire <span class="mi">255</span>);
             Xor (Wire <span class="mi">54</span>) (Wire <span class="mi">154</span>) (Wire <span class="mi">254</span>);
             Xor (Wire <span class="mi">53</span>) (Wire <span class="mi">153</span>) (Wire <span class="mi">253</span>);
             Xor (Wire <span class="mi">52</span>) (Wire <span class="mi">152</span>) (Wire <span class="mi">252</span>);
             Xor (Wire <span class="mi">51</span>) (Wire <span class="mi">151</span>) (Wire <span class="mi">251</span>);
             Xor (Wire <span class="mi">50</span>) (Wire <span class="mi">150</span>) (Wire <span class="mi">250</span>);
             Xor (Wire <span class="mi">49</span>) (Wire <span class="mi">149</span>) (Wire <span class="mi">249</span>);
             Xor (Wire <span class="mi">48</span>) (Wire <span class="mi">148</span>) (Wire <span class="mi">248</span>);
             Xor (Wire <span class="mi">47</span>) (Wire <span class="mi">147</span>) (Wire <span class="mi">247</span>);
             Xor (Wire <span class="mi">46</span>) (Wire <span class="mi">146</span>) (Wire <span class="mi">246</span>);
             Xor (Wire <span class="mi">45</span>) (Wire <span class="mi">145</span>) (Wire <span class="mi">245</span>);
             Xor (Wire <span class="mi">44</span>) (Wire <span class="mi">144</span>) (Wire <span class="mi">244</span>);
             Xor (Wire <span class="mi">43</span>) (Wire <span class="mi">143</span>) (Wire <span class="mi">243</span>);
             Xor (Wire <span class="mi">42</span>) (Wire <span class="mi">142</span>) (Wire <span class="mi">242</span>);
             Xor (Wire <span class="mi">41</span>) (Wire <span class="mi">141</span>) (Wire <span class="mi">241</span>);
             Xor (Wire <span class="mi">40</span>) (Wire <span class="mi">140</span>) (Wire <span class="mi">240</span>);
             Xor (Wire <span class="mi">39</span>) (Wire <span class="mi">139</span>) (Wire <span class="mi">239</span>);
             Xor (Wire <span class="mi">38</span>) (Wire <span class="mi">138</span>) (Wire <span class="mi">238</span>);
             Xor (Wire <span class="mi">37</span>) (Wire <span class="mi">137</span>) (Wire <span class="mi">237</span>);
             Xor (Wire <span class="mi">36</span>) (Wire <span class="mi">136</span>) (Wire <span class="mi">236</span>);
             Xor (Wire <span class="mi">35</span>) (Wire <span class="mi">135</span>) (Wire <span class="mi">235</span>);
             Xor (Wire <span class="mi">34</span>) (Wire <span class="mi">134</span>) (Wire <span class="mi">234</span>);
             Xor (Wire <span class="mi">33</span>) (Wire <span class="mi">133</span>) (Wire <span class="mi">233</span>);
             Xor (Wire <span class="mi">32</span>) (Wire <span class="mi">132</span>) (Wire <span class="mi">232</span>);
             Xor (Wire <span class="mi">31</span>) (Wire <span class="mi">131</span>) (Wire <span class="mi">231</span>);
             Xor (Wire <span class="mi">30</span>) (Wire <span class="mi">130</span>) (Wire <span class="mi">230</span>);
             Xor (Wire <span class="mi">29</span>) (Wire <span class="mi">129</span>) (Wire <span class="mi">229</span>);
             Xor (Wire <span class="mi">28</span>) (Wire <span class="mi">128</span>) (Wire <span class="mi">228</span>);
             Xor (Wire <span class="mi">27</span>) (Wire <span class="mi">127</span>) (Wire <span class="mi">227</span>);
             Xor (Wire <span class="mi">26</span>) (Wire <span class="mi">126</span>) (Wire <span class="mi">226</span>);
             Xor (Wire <span class="mi">25</span>) (Wire <span class="mi">125</span>) (Wire <span class="mi">225</span>);
             Xor (Wire <span class="mi">24</span>) (Wire <span class="mi">124</span>) (Wire <span class="mi">224</span>);
             Xor (Wire <span class="mi">23</span>) (Wire <span class="mi">123</span>) (Wire <span class="mi">223</span>);
             Xor (Wire <span class="mi">22</span>) (Wire <span class="mi">122</span>) (Wire <span class="mi">222</span>);
             Xor (Wire <span class="mi">21</span>) (Wire <span class="mi">121</span>) (Wire <span class="mi">221</span>);
             Xor (Wire <span class="mi">20</span>) (Wire <span class="mi">120</span>) (Wire <span class="mi">220</span>);
             Xor (Wire <span class="mi">19</span>) (Wire <span class="mi">119</span>) (Wire <span class="mi">219</span>);
             Xor (Wire <span class="mi">18</span>) (Wire <span class="mi">118</span>) (Wire <span class="mi">218</span>);
             Xor (Wire <span class="mi">17</span>) (Wire <span class="mi">117</span>) (Wire <span class="mi">217</span>);
             Xor (Wire <span class="mi">16</span>) (Wire <span class="mi">116</span>) (Wire <span class="mi">216</span>);
             Xor (Wire <span class="mi">15</span>) (Wire <span class="mi">115</span>) (Wire <span class="mi">215</span>);
             Xor (Wire <span class="mi">14</span>) (Wire <span class="mi">114</span>) (Wire <span class="mi">214</span>);
             Xor (Wire <span class="mi">13</span>) (Wire <span class="mi">113</span>) (Wire <span class="mi">213</span>);
             Xor (Wire <span class="mi">12</span>) (Wire <span class="mi">112</span>) (Wire <span class="mi">212</span>);
             Xor (Wire <span class="mi">11</span>) (Wire <span class="mi">111</span>) (Wire <span class="mi">211</span>);
             Xor (Wire <span class="mi">10</span>) (Wire <span class="mi">110</span>) (Wire <span class="mi">210</span>);
             Xor (Wire <span class="mi">9</span>) (Wire <span class="mi">109</span>) (Wire <span class="mi">209</span>);
             Xor (Wire <span class="mi">8</span>) (Wire <span class="mi">108</span>) (Wire <span class="mi">208</span>);
             Xor (Wire <span class="mi">7</span>) (Wire <span class="mi">107</span>) (Wire <span class="mi">207</span>);
             Xor (Wire <span class="mi">6</span>) (Wire <span class="mi">106</span>) (Wire <span class="mi">206</span>);
             Xor (Wire <span class="mi">5</span>) (Wire <span class="mi">105</span>) (Wire <span class="mi">205</span>);
             Xor (Wire <span class="mi">4</span>) (Wire <span class="mi">104</span>) (Wire <span class="mi">204</span>);
             Xor (Wire <span class="mi">3</span>) (Wire <span class="mi">103</span>) (Wire <span class="mi">203</span>);
             Xor (Wire <span class="mi">2</span>) (Wire <span class="mi">102</span>) (Wire <span class="mi">202</span>);
             Xor (Wire <span class="mi">1</span>) (Wire <span class="mi">101</span>) (Wire <span class="mi">201</span>);
             Xor (Wire <span class="mi">0</span>) (Wire <span class="mi">100</span>) (Wire <span class="mi">200</span>);
             AssignSignal (Wire <span class="mi">199</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">99</span>);
             AssignSignal (Wire <span class="mi">198</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">98</span>);
             AssignSignal (Wire <span class="mi">197</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">97</span>);
             AssignSignal (Wire <span class="mi">196</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">96</span>);
             AssignSignal (Wire <span class="mi">195</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">95</span>);
             AssignSignal (Wire <span class="mi">194</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">94</span>);
             AssignSignal (Wire <span class="mi">193</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">93</span>);
             AssignSignal (Wire <span class="mi">192</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">92</span>);
             AssignSignal (Wire <span class="mi">191</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">91</span>);
             AssignSignal (Wire <span class="mi">190</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">90</span>);
             AssignSignal (Wire <span class="mi">189</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">89</span>);
             AssignSignal (Wire <span class="mi">188</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">88</span>);
             AssignSignal (Wire <span class="mi">187</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">87</span>);
             AssignSignal (Wire <span class="mi">186</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">86</span>);
             AssignSignal (Wire <span class="mi">185</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">85</span>);
             AssignSignal (Wire <span class="mi">184</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">84</span>);
             AssignSignal (Wire <span class="mi">183</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">83</span>);
             AssignSignal (Wire <span class="mi">182</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">82</span>);
             AssignSignal (Wire <span class="mi">181</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">81</span>);
             AssignSignal (Wire <span class="mi">180</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">80</span>);
             AssignSignal (Wire <span class="mi">179</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">79</span>);
             AssignSignal (Wire <span class="mi">178</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">78</span>);
             AssignSignal (Wire <span class="mi">177</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">77</span>);
             AssignSignal (Wire <span class="mi">176</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">76</span>);
             AssignSignal (Wire <span class="mi">175</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">75</span>);
             AssignSignal (Wire <span class="mi">174</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">74</span>);
             AssignSignal (Wire <span class="mi">173</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">73</span>);
             AssignSignal (Wire <span class="mi">172</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">72</span>);
             AssignSignal (Wire <span class="mi">171</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">71</span>);
             AssignSignal (Wire <span class="mi">170</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">70</span>);
             AssignSignal (Wire <span class="mi">169</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">69</span>);
             AssignSignal (Wire <span class="mi">168</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">68</span>);
             AssignSignal (Wire <span class="mi">167</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">67</span>);
             AssignSignal (Wire <span class="mi">166</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">66</span>);
             AssignSignal (Wire <span class="mi">165</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">65</span>);
             AssignSignal (Wire <span class="mi">164</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">64</span>);
             AssignSignal (Wire <span class="mi">163</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">63</span>);
             AssignSignal (Wire <span class="mi">162</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">62</span>);
             AssignSignal (Wire <span class="mi">161</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">61</span>);
             AssignSignal (Wire <span class="mi">160</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">60</span>);
             AssignSignal (Wire <span class="mi">159</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">59</span>);
             AssignSignal (Wire <span class="mi">158</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">58</span>);
             AssignSignal (Wire <span class="mi">157</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">57</span>);
             AssignSignal (Wire <span class="mi">156</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">56</span>);
             AssignSignal (Wire <span class="mi">155</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">55</span>);
             AssignSignal (Wire <span class="mi">154</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">54</span>);
             AssignSignal (Wire <span class="mi">153</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">53</span>);
             AssignSignal (Wire <span class="mi">152</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">52</span>);
             AssignSignal (Wire <span class="mi">151</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">51</span>);
             AssignSignal (Wire <span class="mi">150</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">50</span>);
             AssignSignal (Wire <span class="mi">149</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">49</span>);
             AssignSignal (Wire <span class="mi">148</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">48</span>);
             AssignSignal (Wire <span class="mi">147</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">47</span>);
             AssignSignal (Wire <span class="mi">146</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">46</span>);
             AssignSignal (Wire <span class="mi">145</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">45</span>);
             AssignSignal (Wire <span class="mi">144</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">44</span>);
             AssignSignal (Wire <span class="mi">143</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">43</span>);
             AssignSignal (Wire <span class="mi">142</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">42</span>);
             AssignSignal (Wire <span class="mi">141</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">41</span>);
             AssignSignal (Wire <span class="mi">140</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">40</span>);
             AssignSignal (Wire <span class="mi">139</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">39</span>);
             AssignSignal (Wire <span class="mi">138</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">38</span>);
             AssignSignal (Wire <span class="mi">137</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">37</span>);
             AssignSignal (Wire <span class="mi">136</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">36</span>);
             AssignSignal (Wire <span class="mi">135</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">35</span>);
             AssignSignal (Wire <span class="mi">134</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">34</span>);
             AssignSignal (Wire <span class="mi">133</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">33</span>);
             AssignSignal (Wire <span class="mi">132</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">32</span>);
             AssignSignal (Wire <span class="mi">131</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">31</span>);
             AssignSignal (Wire <span class="mi">130</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">30</span>);
             AssignSignal (Wire <span class="mi">129</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">29</span>);
             AssignSignal (Wire <span class="mi">128</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">28</span>);
             AssignSignal (Wire <span class="mi">127</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">27</span>);
             AssignSignal (Wire <span class="mi">126</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">26</span>);
             AssignSignal (Wire <span class="mi">125</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">25</span>);
             AssignSignal (Wire <span class="mi">124</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">24</span>);
             AssignSignal (Wire <span class="mi">123</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">23</span>);
             AssignSignal (Wire <span class="mi">122</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">22</span>);
             AssignSignal (Wire <span class="mi">121</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">21</span>);
             AssignSignal (Wire <span class="mi">120</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">20</span>);
             AssignSignal (Wire <span class="mi">119</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">19</span>);
             AssignSignal (Wire <span class="mi">118</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">18</span>);
             AssignSignal (Wire <span class="mi">117</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">17</span>);
             AssignSignal (Wire <span class="mi">116</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">16</span>);
             AssignSignal (Wire <span class="mi">115</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">15</span>);
             AssignSignal (Wire <span class="mi">114</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">14</span>);
             AssignSignal (Wire <span class="mi">113</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">13</span>);
             AssignSignal (Wire <span class="mi">112</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">12</span>);
             AssignSignal (Wire <span class="mi">111</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">11</span>);
             AssignSignal (Wire <span class="mi">110</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">10</span>);
             AssignSignal (Wire <span class="mi">109</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">9</span>);
             AssignSignal (Wire <span class="mi">108</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">8</span>);
             AssignSignal (Wire <span class="mi">107</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">7</span>);
             AssignSignal (Wire <span class="mi">106</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">6</span>);
             AssignSignal (Wire <span class="mi">105</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">5</span>);
             AssignSignal (Wire <span class="mi">104</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">4</span>);
             AssignSignal (Wire <span class="mi">103</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">3</span>);
             AssignSignal (Wire <span class="mi">102</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">2</span>);
             AssignSignal (Wire <span class="mi">101</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">1</span>);
             AssignSignal (Wire <span class="mi">100</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v2&quot;</span>) <span class="mi">0</span>);
             AssignSignal (Wire <span class="mi">99</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">99</span>);
             AssignSignal (Wire <span class="mi">98</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">98</span>);
             AssignSignal (Wire <span class="mi">97</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">97</span>);
             AssignSignal (Wire <span class="mi">96</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">96</span>);
             AssignSignal (Wire <span class="mi">95</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">95</span>);
             AssignSignal (Wire <span class="mi">94</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">94</span>);
             AssignSignal (Wire <span class="mi">93</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">93</span>);
             AssignSignal (Wire <span class="mi">92</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">92</span>);
             AssignSignal (Wire <span class="mi">91</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">91</span>);
             AssignSignal (Wire <span class="mi">90</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">90</span>);
             AssignSignal (Wire <span class="mi">89</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">89</span>);
             AssignSignal (Wire <span class="mi">88</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">88</span>);
             AssignSignal (Wire <span class="mi">87</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">87</span>);
             AssignSignal (Wire <span class="mi">86</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">86</span>);
             AssignSignal (Wire <span class="mi">85</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">85</span>);
             AssignSignal (Wire <span class="mi">84</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">84</span>);
             AssignSignal (Wire <span class="mi">83</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">83</span>);
             AssignSignal (Wire <span class="mi">82</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">82</span>);
             AssignSignal (Wire <span class="mi">81</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">81</span>);
             AssignSignal (Wire <span class="mi">80</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">80</span>);
             AssignSignal (Wire <span class="mi">79</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">79</span>);
             AssignSignal (Wire <span class="mi">78</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">78</span>);
             AssignSignal (Wire <span class="mi">77</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">77</span>);
             AssignSignal (Wire <span class="mi">76</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">76</span>);
             AssignSignal (Wire <span class="mi">75</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">75</span>);
             AssignSignal (Wire <span class="mi">74</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">74</span>);
             AssignSignal (Wire <span class="mi">73</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">73</span>);
             AssignSignal (Wire <span class="mi">72</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">72</span>);
             AssignSignal (Wire <span class="mi">71</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">71</span>);
             AssignSignal (Wire <span class="mi">70</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">70</span>);
             AssignSignal (Wire <span class="mi">69</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">69</span>);
             AssignSignal (Wire <span class="mi">68</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">68</span>);
             AssignSignal (Wire <span class="mi">67</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">67</span>);
             AssignSignal (Wire <span class="mi">66</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">66</span>);
             AssignSignal (Wire <span class="mi">65</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">65</span>);
             AssignSignal (Wire <span class="mi">64</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">64</span>);
             AssignSignal (Wire <span class="mi">63</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">63</span>);
             AssignSignal (Wire <span class="mi">62</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">62</span>);
             AssignSignal (Wire <span class="mi">61</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">61</span>);
             AssignSignal (Wire <span class="mi">60</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">60</span>);
             AssignSignal (Wire <span class="mi">59</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">59</span>);
             AssignSignal (Wire <span class="mi">58</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">58</span>);
             AssignSignal (Wire <span class="mi">57</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">57</span>);
             AssignSignal (Wire <span class="mi">56</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">56</span>);
             AssignSignal (Wire <span class="mi">55</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">55</span>);
             AssignSignal (Wire <span class="mi">54</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">54</span>);
             AssignSignal (Wire <span class="mi">53</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">53</span>);
             AssignSignal (Wire <span class="mi">52</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">52</span>);
             AssignSignal (Wire <span class="mi">51</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">51</span>);
             AssignSignal (Wire <span class="mi">50</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">50</span>);
             AssignSignal (Wire <span class="mi">49</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">49</span>);
             AssignSignal (Wire <span class="mi">48</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">48</span>);
             AssignSignal (Wire <span class="mi">47</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">47</span>);
             AssignSignal (Wire <span class="mi">46</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">46</span>);
             AssignSignal (Wire <span class="mi">45</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">45</span>);
             AssignSignal (Wire <span class="mi">44</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">44</span>);
             AssignSignal (Wire <span class="mi">43</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">43</span>);
             AssignSignal (Wire <span class="mi">42</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">42</span>);
             AssignSignal (Wire <span class="mi">41</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">41</span>);
             AssignSignal (Wire <span class="mi">40</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">40</span>);
             AssignSignal (Wire <span class="mi">39</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">39</span>);
             AssignSignal (Wire <span class="mi">38</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">38</span>);
             AssignSignal (Wire <span class="mi">37</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">37</span>);
             AssignSignal (Wire <span class="mi">36</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">36</span>);
             AssignSignal (Wire <span class="mi">35</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">35</span>);
             AssignSignal (Wire <span class="mi">34</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">34</span>);
             AssignSignal (Wire <span class="mi">33</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">33</span>);
             AssignSignal (Wire <span class="mi">32</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">32</span>);
             AssignSignal (Wire <span class="mi">31</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">31</span>);
             AssignSignal (Wire <span class="mi">30</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">30</span>);
             AssignSignal (Wire <span class="mi">29</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">29</span>);
             AssignSignal (Wire <span class="mi">28</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">28</span>);
             AssignSignal (Wire <span class="mi">27</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">27</span>);
             AssignSignal (Wire <span class="mi">26</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">26</span>);
             AssignSignal (Wire <span class="mi">25</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">25</span>);
             AssignSignal (Wire <span class="mi">24</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">24</span>);
             AssignSignal (Wire <span class="mi">23</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">23</span>);
             AssignSignal (Wire <span class="mi">22</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">22</span>);
             AssignSignal (Wire <span class="mi">21</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">21</span>);
             AssignSignal (Wire <span class="mi">20</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">20</span>);
             AssignSignal (Wire <span class="mi">19</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">19</span>);
             AssignSignal (Wire <span class="mi">18</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">18</span>);
             AssignSignal (Wire <span class="mi">17</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">17</span>);
             AssignSignal (Wire <span class="mi">16</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">16</span>);
             AssignSignal (Wire <span class="mi">15</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">15</span>);
             AssignSignal (Wire <span class="mi">14</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">14</span>);
             AssignSignal (Wire <span class="mi">13</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">13</span>);
             AssignSignal (Wire <span class="mi">12</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">12</span>);
             AssignSignal (Wire <span class="mi">11</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">11</span>);
             AssignSignal (Wire <span class="mi">10</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">10</span>);
             AssignSignal (Wire <span class="mi">9</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">9</span>);
             AssignSignal (Wire <span class="mi">8</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">8</span>);
             AssignSignal (Wire <span class="mi">7</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">7</span>);
             AssignSignal (Wire <span class="mi">6</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">6</span>);
             AssignSignal (Wire <span class="mi">5</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">5</span>);
             AssignSignal (Wire <span class="mi">4</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">4</span>);
             AssignSignal (Wire <span class="mi">3</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">3</span>);
             AssignSignal (Wire <span class="mi">2</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">2</span>);
             AssignSignal (Wire <span class="mi">1</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">1</span>);
             AssignSignal (Wire <span class="mi">0</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">100</span> <span class="s2">&quot;v1&quot;</span>) <span class="mi">0</span>)];
  inputs := [{|
             port_name := <span class="s2">&quot;v2&quot;</span>;
             port_type := Vec Bit <span class="mi">100</span> |};
            {|
            port_name := <span class="s2">&quot;v1&quot;</span>;
            port_type := Vec Bit <span class="mi">100</span> |};
            {|
            port_name := <span class="s2">&quot;rst&quot;</span>;
            port_type := Bit |};
            {|
            port_name := <span class="s2">&quot;clk&quot;</span>;
            port_type := Bit |}];
  outputs := [{|
              port_name := <span class="s2">&quot;o&quot;</span>;
              port_type := Vec Bit <span class="mi">100</span> |}] |}
: <span class="kn">Module</span></span></blockquote></div></div></small></span></pre><p>Simulations are the same; just plug in any size.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight"><span class="c">(* 7 xor 10 = 13 (n=8) (same as xor_byte) *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk24"><span class="highlight"><span class="kn">Compute</span> map Bv2N
        (simulate (xor_bitvec <span class="mi">8</span>) [(N2Bv_sized <span class="mi">8</span> <span class="mi">7</span>, N2Bv_sized <span class="mi">8</span> <span class="mi">10</span>)]).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= [<span class="mi">13</span>%N]%list
: list N</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* 1 xor 3 = 2 (n=2) *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk25"><span class="highlight"><span class="kn">Compute</span> map Bv2N
        (simulate (xor_bitvec <span class="mi">2</span>) [(N2Bv_sized <span class="mi">2</span> <span class="mi">1</span>, N2Bv_sized <span class="mi">2</span> <span class="mi">3</span>)]).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= [<span class="mi">2</span>%N]%list
: list N</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* 1000 xor 3 = 1003 (n=10) *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk26"><span class="highlight"><span class="kn">Compute</span> map Bv2N
        (simulate (xor_bitvec <span class="mi">10</span>)
                  [(N2Bv_sized <span class="mi">10</span> <span class="mi">1000</span>, N2Bv_sized <span class="mi">10</span> <span class="mi">3</span>)]).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= [<span class="mi">1003</span>%N]%list
: list N</span></blockquote></div></div></small></span></pre><p>The correctness proof has is exactly the same as the <tt class="docutils literal">xor_byte</tt> proof, except
with <tt class="docutils literal">n</tt> instead of <tt class="docutils literal">8</tt>; the proof body is completely unchanged.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk27"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">xor_bitvec_correct</span>
      <span class="nv">n</span> (<span class="nv">i</span> : list (Vector.t bool n * Vector.t bool n)) :
  simulate (xor_bitvec n) i = map (<span class="kr">fun</span> &#39;(v1,v2) =&gt; BVxor n v1 v2) i.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t bool n * Vector.t bool n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate (xor_bitvec n) i =
map (<span class="kr">fun</span> &#39;(v1, v2) =&gt; BVxor n v1 v2) i</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk28"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t bool n * Vector.t bool n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate (xor_bitvec n) i =
map (<span class="kr">fun</span> &#39;(v1, v2) =&gt; BVxor n v1 v2) i</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk29"><span class="highlight"><span class="nb">cbv</span> [xor_bitvec].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t bool n * Vector.t bool n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate (Comb (Vec.map2 xor2)) i =
map (<span class="kr">fun</span> &#39;(v1, v2) =&gt; BVxor n v1 v2) i</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk2a"><span class="highlight"><span class="nb">autorewrite with</span> push_simulate.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t bool n * Vector.t bool n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map (Vec.map2 xor2) i =
map (<span class="kr">fun</span> &#39;(v1, v2) =&gt; BVxor n v1 v2) i</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk2b"><span class="highlight"><span class="nb">apply</span> map_ext; <span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t bool n * Vector.t bool n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(Vector.t bool n * Vector.t bool n)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Vec.map2 xor2 a =
(<span class="kr">let</span> &#39;(v1, v2) := a <span class="kr">in</span> BVxor n v1 v2)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk2c"><span class="highlight">destruct_pair_let.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t bool n * Vector.t bool n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(Vector.t bool n * Vector.t bool n)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Vec.map2 xor2 (fst a, snd a) = BVxor n (fst a) (snd a)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk2d"><span class="highlight"><span class="nb">cbv</span> [BVxor].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t bool n * Vector.t bool n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(Vector.t bool n * Vector.t bool n)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Vec.map2 xor2 (fst a, snd a) =
Vector.map2 xorb (fst a) (snd a)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk2e"><span class="highlight">simpl_ident.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t bool n * Vector.t bool n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(Vector.t bool n * Vector.t bool n)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xorb x y)
  (fst a) (snd a) = Vector.map2 xorb (fst a) (snd a)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk2f"><span class="highlight"><span class="nb">apply</span> Vector.map2_ext.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t bool n * Vector.t bool n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(Vector.t bool n * Vector.t bool n)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : combType Bit, xorb a b = xorb a b</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>We can also easily prove that, for 8-bit vectors, <tt class="docutils literal">xor_bitvec</tt> is equivalent
to <tt class="docutils literal">xor_byte</tt>:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk30"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">xor_bitvec_xor_byte_equiv</span>
      (<span class="nv">i</span> : list (Vector.t bool <span class="mi">8</span> * Vector.t bool <span class="mi">8</span>)) :
  simulate (xor_bitvec <span class="mi">8</span>) i = simulate xor_byte i.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t bool <span class="mi">8</span> * Vector.t bool <span class="mi">8</span>)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate (xor_bitvec <span class="mi">8</span>) i = simulate xor_byte i</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk31"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t bool <span class="mi">8</span> * Vector.t bool <span class="mi">8</span>)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate (xor_bitvec <span class="mi">8</span>) i = simulate xor_byte i</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>This example demonstrates the advantage of using a proof assistant instead of a
more computational method. The <tt class="docutils literal">xor_bitvec_correct</tt> proof checks essentially
instantly and holds for <em>all</em> values of <tt class="docutils literal">n</tt>. With one circuit definition, and
one proof, you have defined every single length of bit-vector xor you'll ever
need. The same principle can apply to more complicated structures as well.</p>
</div>
<div class="section" id="example-4-tree-of-xors">
<h1>Example 4: Tree of xors</h1>
<p>To take the last circuit a step further, let's consider xoring not just two
<tt class="docutils literal">n</tt>-length vectors, but an arbitrary number <tt class="docutils literal">m</tt> of <tt class="docutils literal">n</tt>-length vectors!</p>
<p>We could write a definition that chains the xors together one by one:</p>
<pre class="literal-block">
xor (xor (xor (xor (xor a b) c) d) e f)
</pre>
<p>However, since there are no data dependencies, the circuit will have better
timing properties for possibly large <tt class="docutils literal">m</tt> if it is a tree, e.g.:</p>
<pre class="literal-block">
xor (xor (xor a b) c) (xor (xor d e) f)
</pre>
<p>Luckily, Cava's standard library contains a <tt class="docutils literal">tree</tt> combinator for exactly this
kind of situation.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">  </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">xor_tree</span> {<span class="nv">n</span> <span class="nv">m</span> : nat} :
    Circuit (signal (Vec (Vec Bit n) m))
            (signal (Vec Bit n)) :=
    Comb (tree (Vec.map2 xor2)).</span></span></span></pre><p>Now, we can just plug in any sequence of same-size vectors and compute the
results!</p>
<p>One note for those less familiar with Coq: the curly braces <tt class="docutils literal">{}</tt> around the
<tt class="docutils literal">n</tt> and <tt class="docutils literal">m</tt> arguments are standard Coq syntax for &quot;implicit&quot; arguments; Coq
will try to guess their values rather than requiring them to be passed
explicitly. So we can actually write <tt class="docutils literal">xor_tree vec</tt> instead of e.g. <tt class="docutils literal">xor_tree
2 3 vec</tt>, and Coq will try to infer <tt class="docutils literal">n</tt> and <tt class="docutils literal">m</tt> from the type of
<tt class="docutils literal">vec</tt>. If Coq struggles to infer them, we can also plug in these arguments
manually by referencing their names, e.g. <tt class="docutils literal">xor_tree <span class="pre">(m:=3)</span> vec</tt>.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight"><span class="c">(* 7 xor 10 = 13 (n=8, m=2)*)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk32"><span class="highlight"><span class="kn">Compute</span> map Bv2N
        (simulate xor_tree
                  [[N2Bv_sized <span class="mi">8</span> <span class="mi">7</span>; N2Bv_sized <span class="mi">8</span> <span class="mi">10</span>]]).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= [<span class="mi">13</span>%N]%list
: list N</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* 1000 xor 3 = 1003 (n=10, m=2) *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk33"><span class="highlight"><span class="kn">Compute</span> map Bv2N
        (simulate xor_tree
                  [[N2Bv_sized <span class="mi">10</span> <span class="mi">1000</span>; N2Bv_sized <span class="mi">10</span> <span class="mi">3</span>]]).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= [<span class="mi">1003</span>%N]%list
: list N</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* 1 xor 2 xor 4 xor 8 xor 16 xor 32 xor 64 xor 128 = 255 (n=8, m=8) *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk34"><span class="highlight"><span class="kn">Compute</span> map Bv2N
        (simulate xor_tree
                  [[ N2Bv_sized <span class="mi">8</span> <span class="mi">1</span>
                     ; N2Bv_sized <span class="mi">8</span> <span class="mi">2</span>
                     ; N2Bv_sized <span class="mi">8</span> <span class="mi">4</span>
                     ; N2Bv_sized <span class="mi">8</span> <span class="mi">8</span>
                     ; N2Bv_sized <span class="mi">8</span> <span class="mi">16</span>
                     ; N2Bv_sized <span class="mi">8</span> <span class="mi">32</span>
                     ; N2Bv_sized <span class="mi">8</span> <span class="mi">64</span>
                     ; N2Bv_sized <span class="mi">8</span> <span class="mi">128</span>
                   ]]).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= [<span class="mi">255</span>%N]%list
: list N</span></blockquote></div></div></small></span></pre><p>To prove the xor tree circuit correct, we prove that it's equivalent to a
<tt class="docutils literal">fold_left</tt>, which is a native Coq loop. Essentially, this proof says that the
circuit, even with the tree structure, is equivalent to just chaining <tt class="docutils literal">BVxor</tt>
over the input in order (starting with 0, which is the identity for xor).</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk35"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">xor_tree_correct</span> <span class="nv">n</span> <span class="nv">m</span> (<span class="nv">i</span> : list (Vector.t (Vector.t bool n) m)) :
  m &lt;&gt; <span class="mi">0</span> -&gt; <span class="c">(* rule out size-0 tree *)</span>
  simulate xor_tree i = map (<span class="kr">fun</span> <span class="nv">vs</span> =&gt;
                               Vector.fold_left
                                 (BVxor n) (N2Bv_sized n <span class="mi">0</span>) vs) i.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t (Vector.t bool n) m)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">m &lt;&gt; <span class="mi">0</span> -&gt;
simulate xor_tree i =
map
  (<span class="kr">fun</span> <span class="nv">vs</span> : Vector.t (Vector.t bool n) m =&gt;
   Vector.fold_left (BVxor n) (N2Bv_sized n <span class="mi">0</span>) vs) i</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk36"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t (Vector.t bool n) m)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">m &lt;&gt; <span class="mi">0</span> -&gt;
simulate xor_tree i =
map
  (<span class="kr">fun</span> <span class="nv">vs</span> : Vector.t (Vector.t bool n) m =&gt;
   Vector.fold_left (BVxor n) (N2Bv_sized n <span class="mi">0</span>) vs) i</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk37"><span class="highlight"><span class="nb">cbv</span> [xor_tree].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t (Vector.t bool n) m)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">m &lt;&gt; <span class="mi">0</span> -&gt;
simulate (Comb (tree (Vec.map2 xor2))) i =
map
  (<span class="kr">fun</span> <span class="nv">vs</span> : Vector.t (Vector.t bool n) m =&gt;
   Vector.fold_left (BVxor n) (N2Bv_sized n <span class="mi">0</span>) vs) i</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk38"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t (Vector.t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate (Comb (tree (Vec.map2 xor2))) i =
map
  (<span class="kr">fun</span> <span class="nv">vs</span> : Vector.t (Vector.t bool n) m =&gt;
   Vector.fold_left (BVxor n) (N2Bv_sized n <span class="mi">0</span>) vs) i</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk39"><span class="highlight"><span class="nb">autorewrite with</span> push_simulate.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t (Vector.t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map (tree (Vec.map2 xor2)) i =
map
  (<span class="kr">fun</span> <span class="nv">vs</span> : Vector.t (Vector.t bool n) m =&gt;
   Vector.fold_left (BVxor n) (N2Bv_sized n <span class="mi">0</span>) vs) i</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk3a"><span class="highlight"><span class="nb">apply</span> map_ext; <span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t (Vector.t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Vector.t (Vector.t bool n) m</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">tree (Vec.map2 xor2) a =
Vector.fold_left (BVxor n) (N2Bv_sized n <span class="mi">0</span>) a</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="c">(* this rewrite produces side conditions; we&#39;ll handle them later *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk3b"><span class="highlight"><span class="nb">rewrite</span> @tree_equiv <span class="kr">with</span> (t:=Vec Bit n) (id:=N2Bv_sized n <span class="mi">0</span>);
    <span class="nb">intros</span>; <span class="nb">auto</span>; simpl_ident.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t (Vector.t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Vector.t (Vector.t bool n) m</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Vector.fold_left
  (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> : combType (Vec Bit n) =&gt;
   Vec.map2 (<span class="kr">fun</span> &#39;(x, y) =&gt; xorb x y) (a, b))
  (N2Bv_sized n <span class="mi">0</span>) a =
Vector.fold_left (BVxor n) (N2Bv_sized n <span class="mi">0</span>) a</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tutorial-v-chk3c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t (Vector.t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Vector.t (Vector.t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="tutorial-v-chk3c"><hr></label><div class="goal-conclusion"><span class="highlight">Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xorb x y)
  (N2Bv_sized n <span class="mi">0</span>) a0 = a0</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="tutorial-v-chk3d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t (Vector.t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Vector.t (Vector.t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="tutorial-v-chk3d"><hr></label><div class="goal-conclusion"><span class="highlight">Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xorb x y) a0
  (N2Bv_sized n <span class="mi">0</span>) = a0</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="tutorial-v-chk3e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t (Vector.t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Vector.t (Vector.t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0, b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="tutorial-v-chk3e"><hr></label><div class="goal-conclusion"><span class="highlight">Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xorb x y) a0
  (Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xorb x y) b
     c) =
Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xorb x y)
  (Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xorb x y) a0
     b) c</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk3f"><span class="highlight">{ <span class="c">(* xor circuit is equivalent to BVxor *)</span></span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t (Vector.t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Vector.t (Vector.t bool n) m</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Vector.fold_left
  (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> : combType (Vec Bit n) =&gt;
   Vec.map2 (<span class="kr">fun</span> &#39;(x, y) =&gt; xorb x y) (a, b))
  (N2Bv_sized n <span class="mi">0</span>) a =
Vector.fold_left (BVxor n) (N2Bv_sized n <span class="mi">0</span>) a</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk40"><span class="highlight"><span class="nb">cbv</span> [BVxor].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t (Vector.t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Vector.t (Vector.t bool n) m</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Vector.fold_left
  (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> : combType (Vec Bit n) =&gt;
   Vec.map2 (<span class="kr">fun</span> &#39;(x, y) =&gt; xorb x y) (a, b))
  (N2Bv_sized n <span class="mi">0</span>) a =
Vector.fold_left (Vector.map2 xorb) (N2Bv_sized n <span class="mi">0</span>) a</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk41"><span class="highlight"><span class="nb">apply</span> Vector.fold_left_ext; <span class="nb">intros</span>; simpl_ident.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t (Vector.t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Vector.t (Vector.t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Vector.t bool n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xorb x y) b a0 =
Vector.map2 xorb b a0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk42"><span class="highlight"><span class="nb">apply</span> Vector.map2_ext.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t (Vector.t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Vector.t (Vector.t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Vector.t bool n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : combType Bit, xorb a b = xorb a b</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk43"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t (Vector.t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Vector.t (Vector.t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xorb x y)
  (N2Bv_sized n <span class="mi">0</span>) a0 = a0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tutorial-v-chk44" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t (Vector.t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Vector.t (Vector.t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="tutorial-v-chk44"><hr></label><div class="goal-conclusion"><span class="highlight">Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xorb x y) a0
  (N2Bv_sized n <span class="mi">0</span>) = a0</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="tutorial-v-chk45" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t (Vector.t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Vector.t (Vector.t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0, b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="tutorial-v-chk45"><hr></label><div class="goal-conclusion"><span class="highlight">Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xorb x y) a0
  (Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xorb x y) b
     c) =
Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xorb x y)
  (Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xorb x y) a0
     b) c</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="c">(* now, solve the tree_equiv side conditions *)</span>

</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk46"><span class="highlight">{ <span class="c">(* 0 is a left identity *)</span></span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t (Vector.t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Vector.t (Vector.t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xorb x y)
  (N2Bv_sized n <span class="mi">0</span>) a0 = a0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk47"><span class="highlight"><span class="nb">apply</span> Bv2N_inj.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t (Vector.t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Vector.t (Vector.t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Bv2N
  (Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xorb x y)
     (N2Bv_sized n <span class="mi">0</span>) a0) = Bv2N a0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk48"><span class="highlight"><span class="nb">autorewrite with</span> push_Bv2N.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t (Vector.t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Vector.t (Vector.t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N.lxor <span class="mi">0</span> (Bv2N a0) = Bv2N a0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> N.lxor_0_l.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk49"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t (Vector.t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Vector.t (Vector.t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xorb x y) a0
  (N2Bv_sized n <span class="mi">0</span>) = a0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tutorial-v-chk4a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t (Vector.t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Vector.t (Vector.t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0, b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="tutorial-v-chk4a"><hr></label><div class="goal-conclusion"><span class="highlight">Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xorb x y) a0
  (Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xorb x y) b
     c) =
Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xorb x y)
  (Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xorb x y) a0
     b) c</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk4b"><span class="highlight">{ <span class="c">(* 0 is a right identity *)</span></span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t (Vector.t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Vector.t (Vector.t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xorb x y) a0
  (N2Bv_sized n <span class="mi">0</span>) = a0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk4c"><span class="highlight"><span class="nb">apply</span> Bv2N_inj.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t (Vector.t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Vector.t (Vector.t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Bv2N
  (Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xorb x y) a0
     (N2Bv_sized n <span class="mi">0</span>)) = Bv2N a0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk4d"><span class="highlight"><span class="nb">autorewrite with</span> push_Bv2N.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t (Vector.t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Vector.t (Vector.t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N.lxor (Bv2N a0) <span class="mi">0</span> = Bv2N a0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> N.lxor_0_r.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk4e"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t (Vector.t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Vector.t (Vector.t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0, b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xorb x y) a0
  (Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xorb x y) b
     c) =
Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xorb x y)
  (Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xorb x y) a0
     b) c</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk4f"><span class="highlight">{ <span class="c">(* xor is associative *)</span></span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t (Vector.t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Vector.t (Vector.t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0, b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xorb x y) a0
  (Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xorb x y) b
     c) =
Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xorb x y)
  (Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xorb x y) a0
     b) c</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk50"><span class="highlight"><span class="nb">apply</span> Bv2N_inj.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t (Vector.t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Vector.t (Vector.t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0, b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Bv2N
  (Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xorb x y) a0
     (Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xorb x y)
        b c)) =
Bv2N
  (Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xorb x y)
     (Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xorb x y)
        a0 b) c)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk51"><span class="highlight"><span class="nb">autorewrite with</span> push_Bv2N.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t (Vector.t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Vector.t (Vector.t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0, b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N.lxor (Bv2N a0) (N.lxor (Bv2N b) (Bv2N c)) =
N.lxor (N.lxor (Bv2N a0) (Bv2N b)) (Bv2N c)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk52"><span class="highlight"><span class="nb">symmetry</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t (Vector.t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Vector.t (Vector.t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0, b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N.lxor (N.lxor (Bv2N a0) (Bv2N b)) (Bv2N c) =
N.lxor (Bv2N a0) (N.lxor (Bv2N b) (Bv2N c))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk53"><span class="highlight"><span class="nb">cbn</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t (Vector.t bool n) m)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Vector.t (Vector.t bool n) m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0, b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N.lxor (N.lxor (Bv2N a0) (Bv2N b)) (Bv2N c) =
N.lxor (Bv2N a0) (N.lxor (Bv2N b) (Bv2N c))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> N.lxor_assoc.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">}</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>It's worth taking a moment here again to point out just how broad the proof of
correctness is. This proof applies to a circuit that xors two bits, and also
applies to a circuit that xors 1000 1000-bit bitvectors.</p>
<p>As a final touch, we can also prove that, when applied to just two bitvectors
(<tt class="docutils literal">m = 2</tt>), <tt class="docutils literal">xor_tree</tt> is equivalent to <tt class="docutils literal">xor_bitvec</tt>:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk54"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">xor_bitvec_xor_tree_equiv</span>
      <span class="nv">n</span> (<span class="nv">i</span> : list (Vector.t bool n * Vector.t bool n)) :
  simulate (xor_bitvec n) i =
  simulate xor_tree (map (<span class="kr">fun</span> &#39;(v1,v2) =&gt; [v1;v2]) i).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t bool n * Vector.t bool n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate (xor_bitvec n) i =
simulate xor_tree (map (<span class="kr">fun</span> &#39;(v1, v2) =&gt; [v1; v2]) i)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk55"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t bool n * Vector.t bool n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate (xor_bitvec n) i =
simulate xor_tree (map (<span class="kr">fun</span> &#39;(v1, v2) =&gt; [v1; v2]) i)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk56"><span class="highlight"><span class="nb">cbv</span> [xor_bitvec xor_tree]; <span class="nb">autorewrite with</span> push_simulate.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t bool n * Vector.t bool n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map (Vec.map2 xor2) i =
map (tree (Vec.map2 xor2))
  (map (<span class="kr">fun</span> &#39;(v1, v2) =&gt; [v1; v2]) i)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk57"><span class="highlight"><span class="nb">rewrite</span> map_map.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t bool n * Vector.t bool n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map (Vec.map2 xor2) i =
map
  (<span class="kr">fun</span> <span class="nv">x</span> : Vector.t bool n * Vector.t bool n =&gt;
   tree (Vec.map2 xor2)
     (<span class="kr">let</span> &#39;(v1, v2) := x <span class="kr">in</span> [v1; v2])) i</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk58"><span class="highlight"><span class="nb">apply</span> map_ext; <span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t bool n * Vector.t bool n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(Vector.t bool n * Vector.t bool n)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Vec.map2 xor2 a =
tree (Vec.map2 xor2) (<span class="kr">let</span> &#39;(v1, v2) := a <span class="kr">in</span> [v1; v2])</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk59"><span class="highlight">destruct_pair_let.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t bool n * Vector.t bool n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(Vector.t bool n * Vector.t bool n)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Vec.map2 xor2 (fst a, snd a) =
tree (Vec.map2 xor2) [fst a; snd a]</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="c">(* The tree lemma produces the same side conditions as before, but</span>
<span class="c">     we solve them here in a more concise way *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk5a"><span class="highlight"><span class="nb">erewrite</span> @tree_equiv <span class="kr">with</span>
      (t:=Vec Bit n) (id:=N2Bv_sized n <span class="mi">0</span>)
    <span class="bp">by</span> (<span class="nb">intros</span>; <span class="nb">auto</span>; simpl_ident; <span class="nb">apply</span> Bv2N_inj;
        <span class="nb">autorewrite with</span> push_Bv2N;
        <span class="nb">auto using</span> N.lxor_0_r, N.lxor_0_l, N.lxor_assoc).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t bool n * Vector.t bool n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(Vector.t bool n * Vector.t bool n)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Vec.map2 xor2 (fst a, snd a) =
Vector.fold_left
  (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> : combType (Vec Bit n) =&gt;
   Vec.map2 xor2 (a, b)) (N2Bv_sized n <span class="mi">0</span>)
  [fst a; snd a]</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk5b"><span class="highlight"><span class="nb">autorewrite with</span> push_vector_fold vsimpl.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t bool n * Vector.t bool n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(Vector.t bool n * Vector.t bool n)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Vec.map2 xor2 (fst a, snd a) =
Vec.map2 xor2
  (Vec.map2 xor2 (N2Bv_sized n <span class="mi">0</span>, fst a), snd a)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk5c"><span class="highlight">simpl_ident.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t bool n * Vector.t bool n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(Vector.t bool n * Vector.t bool n)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xorb x y)
  (fst a) (snd a) =
Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xorb x y)
  (Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xorb x y)
     (N2Bv_sized n <span class="mi">0</span>) (fst a)) (snd a)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk5d"><span class="highlight"><span class="nb">apply</span> Bv2N_inj.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t bool n * Vector.t bool n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(Vector.t bool n * Vector.t bool n)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Bv2N
  (Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xorb x y)
     (fst a) (snd a)) =
Bv2N
  (Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xorb x y)
     (Vector.map2 (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> : combType Bit =&gt; xorb x y)
        (N2Bv_sized n <span class="mi">0</span>) (fst a)) (snd a))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk5e"><span class="highlight"><span class="nb">autorewrite with</span> push_Bv2N.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t bool n * Vector.t bool n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(Vector.t bool n * Vector.t bool n)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N.lxor (Bv2N (fst a)) (Bv2N (snd a)) =
N.lxor (N.lxor <span class="mi">0</span> (Bv2N (fst a))) (Bv2N (snd a))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk5f"><span class="highlight"><span class="nb">rewrite</span> N.lxor_0_l.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (Vector.t bool n * Vector.t bool n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(Vector.t bool n * Vector.t bool n)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N.lxor (Bv2N (fst a)) (Bv2N (snd a)) =
N.lxor (Bv2N (fst a)) (Bv2N (snd a))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>At this point, we've covered pretty much everything you need to start building
<em>combinational</em> circuits in Cava -- circuits that don't have any
timing-dependent elements like loops or registers. In the next example, we'll
show how to build <em>sequential</em> circuits.</p>
</div>
<div class="section" id="example-5-delay-for-three-timesteps">
<h1>Example 5 : Delay for Three Timesteps</h1>
<p>The simplest sequential element is a unit delay (register). The delay takes in a
value at the end of the clock cycle, and then outputs the same value at the
start of the next clock cycle. So if we want to write a circuit that delays the
input stream by three timesteps, we can write three delays in a row:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">  </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">three_delays</span> {<span class="nv">t</span> : SignalType}
    : Circuit (signal t) (signal t) :=
    Delay &gt;==&gt; Delay &gt;==&gt; Delay.</span></span></span></pre><p>Note that this circuit definition will delay a signal <em>of any type</em>. The <tt class="docutils literal">t</tt>
argument can be anything, although to generate a concrete netlist or simulation
it will need to be plugged in. We'll do simulations and netlist generations with
a few different types.</p>
<p>The <tt class="docutils literal"><span class="pre">&gt;==&gt;</span></tt> notation means &quot;compose these circuits&quot;, i.e connect the output
ports of the left-hand circuit to the input ports of the second. It's short for
<tt class="docutils literal">Compose</tt>, which can also be used directly.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk60"><span class="highlight"><span class="kn">Locate</span> <span class="s2">&quot;&gt;==&gt;&quot;</span>. <span class="c">(* print the definition of the notation *)</span></span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight"><span class="kn">Notation</span>
<span class="s2">&quot;x &gt;==&gt; y&quot;</span> := Compose x y (default interpretation)</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="c">(* Exactly the same thing as three_delays, just without notation *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">three_delays_verbose</span> {<span class="nv">t</span> : SignalType}
    : Circuit (signal t) (signal t) :=
    Compose (Compose Delay Delay) Delay.</span></span></span></pre><p><tt class="docutils literal">Compose</tt> and <tt class="docutils literal">Delay</tt> are like <tt class="docutils literal">Comb</tt>; they are definitions that create
<tt class="docutils literal">Circuit</tt>s. You can find a full list of <tt class="docutils literal">Circuit</tt> constructors in the
<a class="reference external" href="/reference">reference</a>.</p>
<p>Here's the netlist for <tt class="docutils literal">three_delays</tt>, generated for two different signal
types:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">three_delays_interface</span> {<span class="nv">t</span> : SignalType}
  := sequentialInterface <span class="s2">&quot;three_delays_interface&quot;</span>
     <span class="s2">&quot;clk&quot;</span> PositiveEdge <span class="s2">&quot;rst&quot;</span> PositiveEdge
     [mkPort <span class="s2">&quot;i&quot;</span> t]
     [mkPort <span class="s2">&quot;o&quot;</span> t].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* delay a stream of bits *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk61"><span class="highlight"><span class="kn">Compute</span>
  (makeCircuitNetlist three_delays_interface
                      (three_delays (t:=Bit))).(module).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= {|
  moduleName := <span class="s2">&quot;three_delays_interface&quot;</span>;
  netlist := [AssignSignal (NamedWire <span class="s2">&quot;o&quot;</span>)
                (Wire <span class="mi">2</span>);
             DelayEnable Bit false Vcc (Wire <span class="mi">1</span>)
               (Wire <span class="mi">2</span>);
             DelayEnable Bit false Vcc (Wire <span class="mi">0</span>)
               (Wire <span class="mi">1</span>);
             DelayEnable Bit false Vcc
               (NamedWire <span class="s2">&quot;i&quot;</span>) (Wire <span class="mi">0</span>)];
  inputs := [{|
             port_name := <span class="s2">&quot;i&quot;</span>;
             port_type := Bit |};
            {|
            port_name := <span class="s2">&quot;rst&quot;</span>;
            port_type := Bit |};
            {|
            port_name := <span class="s2">&quot;clk&quot;</span>;
            port_type := Bit |}];
  outputs := [{|
              port_name := <span class="s2">&quot;o&quot;</span>;
              port_type := Bit |}] |}
: <span class="kn">Module</span></span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* delay a stream of bytes *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk62"><span class="highlight"><span class="kn">Compute</span>
  (makeCircuitNetlist three_delays_interface
                      (three_delays (t:=Vec Bit <span class="mi">8</span>))).(module).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= {|
  moduleName := <span class="s2">&quot;three_delays_interface&quot;</span>;
  netlist := [AssignSignal
                (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;o&quot;</span>)
                (LocalVec Bit <span class="mi">8</span> <span class="mi">2</span>);
             DelayEnable (Vec Bit <span class="mi">8</span>)
               [false; false; false; false;
               false; false; false; false]%vector
               Vcc (LocalVec Bit <span class="mi">8</span> <span class="mi">1</span>)
               (LocalVec Bit <span class="mi">8</span> <span class="mi">2</span>);
             DelayEnable (Vec Bit <span class="mi">8</span>)
               [false; false; false; false;
               false; false; false; false]%vector
               Vcc (LocalVec Bit <span class="mi">8</span> <span class="mi">0</span>)
               (LocalVec Bit <span class="mi">8</span> <span class="mi">1</span>);
             DelayEnable (Vec Bit <span class="mi">8</span>)
               [false; false; false; false;
               false; false; false; false]%vector
               Vcc (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;i&quot;</span>)
               (LocalVec Bit <span class="mi">8</span> <span class="mi">0</span>)];
  inputs := [{|
             port_name := <span class="s2">&quot;i&quot;</span>;
             port_type := Vec Bit <span class="mi">8</span> |};
            {|
            port_name := <span class="s2">&quot;rst&quot;</span>;
            port_type := Bit |};
            {|
            port_name := <span class="s2">&quot;clk&quot;</span>;
            port_type := Bit |}];
  outputs := [{|
              port_name := <span class="s2">&quot;o&quot;</span>;
              port_type := Vec Bit <span class="mi">8</span> |}] |}
: <span class="kn">Module</span></span></blockquote></div></div></small></span></pre><p>Let's simulate the circuit, first using a sequence of 1s:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk63"><span class="highlight"><span class="kn">Compute</span> simulate (three_delays (t:=Bit)) (<span class="kp">repeat</span> true <span class="mi">10</span>).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= [false; false; false; true; true; true; true;
  true; true; true]
: list (combType Bit)</span></blockquote></div></div></small></span></pre><p>You can see that we get three <tt class="docutils literal">false</tt> outputs before getting the stream of
<tt class="docutils literal">true</tt> values. The initial state of <tt class="docutils literal">Delay</tt> is always &quot;zeroed out&quot;; for a
custom initial state, you can use the alternative constructor <tt class="docutils literal">DelayInit</tt>,
which takes an initial value.</p>
<p>We can also simulate the circuit with bytes. To make the simulations a little
more interesting, we'll use a small convenience definition that creates a
list of bytes counting up in sequence.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight"><span class="c">(* convenience definition for a sequence of numbers as bytes *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">byte_seq</span> <span class="nv">start</span> <span class="nv">len</span> : list (combType (Vec Bit <span class="mi">8</span>)) :=
  map (nat_to_bitvec_sized <span class="mi">8</span>) (seq start len).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk64"><span class="highlight"><span class="kn">Compute</span> map Bv2N (byte_seq <span class="mi">1</span> <span class="mi">10</span>). <span class="c">(* bytes from 1..10 *)</span></span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= [<span class="mi">1</span>%N; <span class="mi">2</span>%N; <span class="mi">3</span>%N; <span class="mi">4</span>%N; <span class="mi">5</span>%N; <span class="mi">6</span>%N; <span class="mi">7</span>%N; <span class="mi">8</span>%N; <span class="mi">9</span>%N;
  <span class="mi">10</span>%N]
: list N</span></blockquote></div></div></small></span></pre><p>Now, when we run the simulations, it's easier to follow the timesteps:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk65"><span class="highlight"><span class="kn">Compute</span> map Bv2N
        (simulate three_delays (byte_seq <span class="mi">1</span> <span class="mi">10</span>)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= [<span class="mi">0</span>%N; <span class="mi">0</span>%N; <span class="mi">0</span>%N; <span class="mi">1</span>%N; <span class="mi">2</span>%N; <span class="mi">3</span>%N; <span class="mi">4</span>%N; <span class="mi">5</span>%N; <span class="mi">6</span>%N;
  <span class="mi">7</span>%N]
: list N</span></blockquote></div></div></small></span></pre><p>We can also compose <tt class="docutils literal">three_delays</tt> with itself to get six delays:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk66"><span class="highlight"><span class="kn">Compute</span> map Bv2N
        (simulate (three_delays &gt;==&gt; three_delays) (byte_seq <span class="mi">1</span> <span class="mi">10</span>)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= [<span class="mi">0</span>%N; <span class="mi">0</span>%N; <span class="mi">0</span>%N; <span class="mi">0</span>%N; <span class="mi">0</span>%N; <span class="mi">0</span>%N; <span class="mi">1</span>%N; <span class="mi">2</span>%N; <span class="mi">3</span>%N;
  <span class="mi">4</span>%N]
: list N</span></blockquote></div></div></small></span></pre><p>Finally, the correctness proof for <tt class="docutils literal">three_delays</tt> says that it prepends three
<tt class="docutils literal">defaultSignal</tt> values (the generic name for &quot;a zeroed-out value of the
correct signal type&quot;) to the input, then truncates the new list to the length of
the original input.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk67"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">three_delays_correct</span> <span class="nv">t</span> (<span class="nv">input</span> : list (combType t)) :
  simulate three_delays input
  = firstn (length input)
           (defaultSignal :: defaultSignal :: defaultSignal :: input).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SignalType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType t)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate three_delays input =
firstn (Datatypes.length input)
  (defaultSignal
   :: defaultSignal :: defaultSignal :: input)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk68"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SignalType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType t)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate three_delays input =
firstn (Datatypes.length input)
  (defaultSignal
   :: defaultSignal :: defaultSignal :: input)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk69"><span class="highlight"><span class="nb">cbv</span> [three_delays]; <span class="nb">autorewrite with</span> push_simulate.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SignalType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType t)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">firstn
  (Datatypes.length
     (firstn
        (Datatypes.length
           (firstn (Datatypes.length input)
              (defaultSignal :: input)))
        (defaultSignal
         :: firstn (Datatypes.length input)
              (defaultSignal :: input))))
  (defaultSignal
   :: firstn
        (Datatypes.length
           (firstn (Datatypes.length input)
              (defaultSignal :: input)))
        (defaultSignal
         :: firstn (Datatypes.length input)
              (defaultSignal :: input))) =
firstn (Datatypes.length input)
  (defaultSignal
   :: defaultSignal :: defaultSignal :: input)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk6a"><span class="highlight"><span class="nb">autorewrite with</span> push_length natsimpl.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SignalType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType t)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">firstn (Datatypes.length input)
  (defaultSignal
   :: firstn (Datatypes.length input)
        (defaultSignal
         :: firstn (Datatypes.length input)
              (defaultSignal :: input))) =
firstn (Datatypes.length input)
  (defaultSignal
   :: defaultSignal :: defaultSignal :: input)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk6b"><span class="highlight"><span class="nb">rewrite</span> &lt;-!firstn_cons.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SignalType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType t)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">firstn (Datatypes.length input)
  (firstn (S (Datatypes.length input))
     (firstn (S (S (Datatypes.length input)))
        (defaultSignal
         :: defaultSignal :: defaultSignal :: input))) =
firstn (Datatypes.length input)
  (defaultSignal
   :: defaultSignal :: defaultSignal :: input)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk6c"><span class="highlight"><span class="nb">rewrite</span> !firstn_firstn.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SignalType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType t)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">firstn
  (Init.Nat.min
     (Init.Nat.min (Datatypes.length input)
        (S (Datatypes.length input)))
     (S (S (Datatypes.length input))))
  (defaultSignal
   :: defaultSignal :: defaultSignal :: input) =
firstn (Datatypes.length input)
  (defaultSignal
   :: defaultSignal :: defaultSignal :: input)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk6d"><span class="highlight"><span class="nb">autorewrite with</span> natsimpl.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SignalType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType t)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">firstn (Datatypes.length input)
  (defaultSignal
   :: defaultSignal :: defaultSignal :: input) =
firstn (Datatypes.length input)
  (defaultSignal
   :: defaultSignal :: defaultSignal :: input)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre></div>
<div class="section" id="example-6-sum-the-input-stream">
<h1>Example 6 : Sum the Input Stream</h1>
<p>This example will introduce <tt class="docutils literal">Loop</tt>, a circuit constructor that connects the
output port of a circuit to its own input port with a delay in the middle. This
creates <em>internal state</em> values, which can be referenced from inside the loop
but are not visible outside it. Visually, a loop looks like this:</p>
<img alt="Circuit diagram showing a loop." src="loop.png" />
<p>The following circuit gets a stream of bit-vectors as input, and uses <tt class="docutils literal">Loop</tt>
to provides the rolling sum as output:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">  </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">sum</span> {<span class="nv">n</span> : nat}
    : Circuit (signal (Vec Bit n)) (signal (Vec Bit n)) :=
    Loop
      <span class="c">(* The combinational circuit that makes up the loop body *)</span>
      (Comb
         (<span class="kr">fun</span> &#39;(input, state) =&gt;
            sum &lt;- addN (input, state) ;;
            <span class="c">(* return output and new state (the same in our case) *)</span>
            ret (sum, sum))).</span></span></span></pre><p>The body of this loop is a combinational circuit whose input is the loop input
signal and the internal state, and whose output is the loop output signal and
the new state.</p>
<p>As discussed in the very first example, the <tt class="docutils literal">_ &lt;- _ ;; _</tt> notation is a
monadic bind; it's like a <tt class="docutils literal">let</tt> binder or variable assignment, except that it
helps Cava track resource sharing. <tt class="docutils literal">ret</tt> means &quot;return&quot;. You can read in much
more detail about monad notations in the <a class="reference external" href="/reference">reference</a>.</p>
<p>For the purposes of the tutorial, we'll introduce just one more monad notation:
monad composition, represented by <tt class="docutils literal">&gt;=&gt;</tt>. Assuming <tt class="docutils literal">f</tt> and <tt class="docutils literal">g</tt> are monadic
functions, writing <tt class="docutils literal">f &gt;=&gt; g</tt> is the same as writing <tt class="docutils literal">fun x =&gt; y &lt;- f x ;; g
y</tt>. This is very similar to the notation for <tt class="docutils literal">Compose</tt> (<tt class="docutils literal"><span class="pre">&gt;==&gt;</span></tt>) shown
earlier, except that it works for the bodies of combinational circuits rather
than for sequential circuits.</p>
<p>Using <tt class="docutils literal">&gt;=&gt;</tt>, we can rewrite <tt class="docutils literal">sum</tt> as:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">  <span class="c">(* Means exactly the same thing as sum *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">sum_concise</span> {<span class="nv">n</span> : nat}
    : Circuit (signal (Vec Bit n)) (signal (Vec Bit n)) :=
    Loop (Comb (addN &gt;=&gt; fork2)).</span></span></span></pre><p>The <tt class="docutils literal">fork2</tt> combinator simply duplicates its input (like a fork in a wire).</p>
<p>As written, the <tt class="docutils literal">sum</tt> and <tt class="docutils literal">sum_concise</tt> circuits will start with an initial
state of zero (or <tt class="docutils literal">defaultSignal</tt>). If we want to pull in a specific initial
value, we can use <tt class="docutils literal">LoopInit</tt> instead and plug in a compile-time constant:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">  </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">sum_init</span> {<span class="nv">n</span> : nat} (<span class="nv">init</span> : combType (Vec Bit n)) :=
    LoopInit init (Comb (addN &gt;=&gt; fork2)).</span></span></span></pre><p>Here's the netlist for <tt class="docutils literal">sum</tt>. You can see that no &quot;loop&quot; appears in the final
version, just a delay connecting the loop's output to its own input.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">sum_interface</span> {<span class="nv">n</span> : nat}
  := sequentialInterface <span class="s2">&quot;sum_interface&quot;</span>
     <span class="s2">&quot;clk&quot;</span> PositiveEdge <span class="s2">&quot;rst&quot;</span> PositiveEdge
     [mkPort <span class="s2">&quot;i&quot;</span> (Vec Bit n)]
     [mkPort <span class="s2">&quot;o&quot;</span> (Vec Bit n)].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk6e"><span class="highlight"><span class="kn">Compute</span>
  (makeCircuitNetlist sum_interface (sum (n:=<span class="mi">8</span>))).(module).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= {|
  moduleName := <span class="s2">&quot;sum_interface&quot;</span>;
  netlist := [AssignSignal
                (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;o&quot;</span>)
                (LocalVec Bit <span class="mi">8</span> <span class="mi">1</span>);
             DelayEnable (Vec Bit <span class="mi">8</span>)
               [false; false; false; false;
               false; false; false; false]%vector
               Vcc (LocalVec Bit <span class="mi">8</span> <span class="mi">1</span>)
               (LocalVec Bit <span class="mi">8</span> <span class="mi">0</span>);
             AssignSignal (LocalVec Bit <span class="mi">8</span> <span class="mi">1</span>)
               (VecLit
                  [Wire <span class="mi">18</span>; Wire <span class="mi">23</span>; Wire <span class="mi">28</span>;
                  Wire <span class="mi">33</span>; Wire <span class="mi">38</span>; Wire <span class="mi">43</span>;
                  Wire <span class="mi">48</span>; Wire <span class="mi">53</span>]);
             Or (Wire <span class="mi">52</span>) (Wire <span class="mi">54</span>) (Wire <span class="mi">55</span>);
             And (Wire <span class="mi">51</span>) (Wire <span class="mi">50</span>) (Wire <span class="mi">54</span>);
             Xor (Wire <span class="mi">51</span>) (Wire <span class="mi">50</span>) (Wire <span class="mi">53</span>);
             And (Wire <span class="mi">7</span>) (Wire <span class="mi">15</span>) (Wire <span class="mi">52</span>);
             Xor (Wire <span class="mi">7</span>) (Wire <span class="mi">15</span>) (Wire <span class="mi">51</span>);
             Or (Wire <span class="mi">47</span>) (Wire <span class="mi">49</span>) (Wire <span class="mi">50</span>);
             And (Wire <span class="mi">46</span>) (Wire <span class="mi">45</span>) (Wire <span class="mi">49</span>);
             Xor (Wire <span class="mi">46</span>) (Wire <span class="mi">45</span>) (Wire <span class="mi">48</span>);
             And (Wire <span class="mi">6</span>) (Wire <span class="mi">14</span>) (Wire <span class="mi">47</span>);
             Xor (Wire <span class="mi">6</span>) (Wire <span class="mi">14</span>) (Wire <span class="mi">46</span>);
             Or (Wire <span class="mi">42</span>) (Wire <span class="mi">44</span>) (Wire <span class="mi">45</span>);
             And (Wire <span class="mi">41</span>) (Wire <span class="mi">40</span>) (Wire <span class="mi">44</span>);
             Xor (Wire <span class="mi">41</span>) (Wire <span class="mi">40</span>) (Wire <span class="mi">43</span>);
             And (Wire <span class="mi">5</span>) (Wire <span class="mi">13</span>) (Wire <span class="mi">42</span>);
             Xor (Wire <span class="mi">5</span>) (Wire <span class="mi">13</span>) (Wire <span class="mi">41</span>);
             Or (Wire <span class="mi">37</span>) (Wire <span class="mi">39</span>) (Wire <span class="mi">40</span>);
             And (Wire <span class="mi">36</span>) (Wire <span class="mi">35</span>) (Wire <span class="mi">39</span>);
             Xor (Wire <span class="mi">36</span>) (Wire <span class="mi">35</span>) (Wire <span class="mi">38</span>);
             And (Wire <span class="mi">4</span>) (Wire <span class="mi">12</span>) (Wire <span class="mi">37</span>);
             Xor (Wire <span class="mi">4</span>) (Wire <span class="mi">12</span>) (Wire <span class="mi">36</span>);
             Or (Wire <span class="mi">32</span>) (Wire <span class="mi">34</span>) (Wire <span class="mi">35</span>);
             And (Wire <span class="mi">31</span>) (Wire <span class="mi">30</span>) (Wire <span class="mi">34</span>);
             Xor (Wire <span class="mi">31</span>) (Wire <span class="mi">30</span>) (Wire <span class="mi">33</span>);
             And (Wire <span class="mi">3</span>) (Wire <span class="mi">11</span>) (Wire <span class="mi">32</span>);
             Xor (Wire <span class="mi">3</span>) (Wire <span class="mi">11</span>) (Wire <span class="mi">31</span>);
             Or (Wire <span class="mi">27</span>) (Wire <span class="mi">29</span>) (Wire <span class="mi">30</span>);
             And (Wire <span class="mi">26</span>) (Wire <span class="mi">25</span>) (Wire <span class="mi">29</span>);
             Xor (Wire <span class="mi">26</span>) (Wire <span class="mi">25</span>) (Wire <span class="mi">28</span>);
             And (Wire <span class="mi">2</span>) (Wire <span class="mi">10</span>) (Wire <span class="mi">27</span>);
             Xor (Wire <span class="mi">2</span>) (Wire <span class="mi">10</span>) (Wire <span class="mi">26</span>);
             Or (Wire <span class="mi">22</span>) (Wire <span class="mi">24</span>) (Wire <span class="mi">25</span>);
             And (Wire <span class="mi">21</span>) (Wire <span class="mi">20</span>) (Wire <span class="mi">24</span>);
             Xor (Wire <span class="mi">21</span>) (Wire <span class="mi">20</span>) (Wire <span class="mi">23</span>);
             And (Wire <span class="mi">1</span>) (Wire <span class="mi">9</span>) (Wire <span class="mi">22</span>);
             Xor (Wire <span class="mi">1</span>) (Wire <span class="mi">9</span>) (Wire <span class="mi">21</span>);
             Or (Wire <span class="mi">17</span>) (Wire <span class="mi">19</span>) (Wire <span class="mi">20</span>);
             And (Wire <span class="mi">16</span>) Gnd (Wire <span class="mi">19</span>);
             Xor (Wire <span class="mi">16</span>) Gnd (Wire <span class="mi">18</span>);
             And (Wire <span class="mi">0</span>) (Wire <span class="mi">8</span>) (Wire <span class="mi">17</span>);
             Xor (Wire <span class="mi">0</span>) (Wire <span class="mi">8</span>) (Wire <span class="mi">16</span>);
             AssignSignal (Wire <span class="mi">15</span>)
               (IndexConst (LocalVec Bit <span class="mi">8</span> <span class="mi">0</span>) <span class="mi">7</span>);
             AssignSignal (Wire <span class="mi">14</span>)
               (IndexConst (LocalVec Bit <span class="mi">8</span> <span class="mi">0</span>) <span class="mi">6</span>);
             AssignSignal (Wire <span class="mi">13</span>)
               (IndexConst (LocalVec Bit <span class="mi">8</span> <span class="mi">0</span>) <span class="mi">5</span>);
             AssignSignal (Wire <span class="mi">12</span>)
               (IndexConst (LocalVec Bit <span class="mi">8</span> <span class="mi">0</span>) <span class="mi">4</span>);
             AssignSignal (Wire <span class="mi">11</span>)
               (IndexConst (LocalVec Bit <span class="mi">8</span> <span class="mi">0</span>) <span class="mi">3</span>);
             AssignSignal (Wire <span class="mi">10</span>)
               (IndexConst (LocalVec Bit <span class="mi">8</span> <span class="mi">0</span>) <span class="mi">2</span>);
             AssignSignal (Wire <span class="mi">9</span>)
               (IndexConst (LocalVec Bit <span class="mi">8</span> <span class="mi">0</span>) <span class="mi">1</span>);
             AssignSignal (Wire <span class="mi">8</span>)
               (IndexConst (LocalVec Bit <span class="mi">8</span> <span class="mi">0</span>) <span class="mi">0</span>);
             AssignSignal (Wire <span class="mi">7</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;i&quot;</span>) <span class="mi">7</span>);
             AssignSignal (Wire <span class="mi">6</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;i&quot;</span>) <span class="mi">6</span>);
             AssignSignal (Wire <span class="mi">5</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;i&quot;</span>) <span class="mi">5</span>);
             AssignSignal (Wire <span class="mi">4</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;i&quot;</span>) <span class="mi">4</span>);
             AssignSignal (Wire <span class="mi">3</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;i&quot;</span>) <span class="mi">3</span>);
             AssignSignal (Wire <span class="mi">2</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;i&quot;</span>) <span class="mi">2</span>);
             AssignSignal (Wire <span class="mi">1</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;i&quot;</span>) <span class="mi">1</span>);
             AssignSignal (Wire <span class="mi">0</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;i&quot;</span>) <span class="mi">0</span>)];
  inputs := [{|
             port_name := <span class="s2">&quot;i&quot;</span>;
             port_type := Vec Bit <span class="mi">8</span> |};
            {|
            port_name := <span class="s2">&quot;rst&quot;</span>;
            port_type := Bit |};
            {|
            port_name := <span class="s2">&quot;clk&quot;</span>;
            port_type := Bit |}];
  outputs := [{|
              port_name := <span class="s2">&quot;o&quot;</span>;
              port_type := Vec Bit <span class="mi">8</span> |}] |}
: <span class="kn">Module</span></span></blockquote></div></div></small></span></pre><p>The netlist for <tt class="docutils literal">sum_init</tt> can use the same interface, but needs an extra
argument for the initial value:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk6f"><span class="highlight"><span class="kn">Compute</span>
  (makeCircuitNetlist sum_interface
                      (sum_init (N2Bv_sized <span class="mi">8</span> <span class="mi">10</span>))).(module).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= {|
  moduleName := <span class="s2">&quot;sum_interface&quot;</span>;
  netlist := [AssignSignal
                (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;o&quot;</span>)
                (LocalVec Bit <span class="mi">8</span> <span class="mi">1</span>);
             DelayEnable (Vec Bit <span class="mi">8</span>)
               [false; true; false; true; false;
               false; false; false]%vector Vcc
               (LocalVec Bit <span class="mi">8</span> <span class="mi">1</span>)
               (LocalVec Bit <span class="mi">8</span> <span class="mi">0</span>);
             AssignSignal (LocalVec Bit <span class="mi">8</span> <span class="mi">1</span>)
               (VecLit
                  [Wire <span class="mi">18</span>; Wire <span class="mi">23</span>; Wire <span class="mi">28</span>;
                  Wire <span class="mi">33</span>; Wire <span class="mi">38</span>; Wire <span class="mi">43</span>;
                  Wire <span class="mi">48</span>; Wire <span class="mi">53</span>]);
             Or (Wire <span class="mi">52</span>) (Wire <span class="mi">54</span>) (Wire <span class="mi">55</span>);
             And (Wire <span class="mi">51</span>) (Wire <span class="mi">50</span>) (Wire <span class="mi">54</span>);
             Xor (Wire <span class="mi">51</span>) (Wire <span class="mi">50</span>) (Wire <span class="mi">53</span>);
             And (Wire <span class="mi">7</span>) (Wire <span class="mi">15</span>) (Wire <span class="mi">52</span>);
             Xor (Wire <span class="mi">7</span>) (Wire <span class="mi">15</span>) (Wire <span class="mi">51</span>);
             Or (Wire <span class="mi">47</span>) (Wire <span class="mi">49</span>) (Wire <span class="mi">50</span>);
             And (Wire <span class="mi">46</span>) (Wire <span class="mi">45</span>) (Wire <span class="mi">49</span>);
             Xor (Wire <span class="mi">46</span>) (Wire <span class="mi">45</span>) (Wire <span class="mi">48</span>);
             And (Wire <span class="mi">6</span>) (Wire <span class="mi">14</span>) (Wire <span class="mi">47</span>);
             Xor (Wire <span class="mi">6</span>) (Wire <span class="mi">14</span>) (Wire <span class="mi">46</span>);
             Or (Wire <span class="mi">42</span>) (Wire <span class="mi">44</span>) (Wire <span class="mi">45</span>);
             And (Wire <span class="mi">41</span>) (Wire <span class="mi">40</span>) (Wire <span class="mi">44</span>);
             Xor (Wire <span class="mi">41</span>) (Wire <span class="mi">40</span>) (Wire <span class="mi">43</span>);
             And (Wire <span class="mi">5</span>) (Wire <span class="mi">13</span>) (Wire <span class="mi">42</span>);
             Xor (Wire <span class="mi">5</span>) (Wire <span class="mi">13</span>) (Wire <span class="mi">41</span>);
             Or (Wire <span class="mi">37</span>) (Wire <span class="mi">39</span>) (Wire <span class="mi">40</span>);
             And (Wire <span class="mi">36</span>) (Wire <span class="mi">35</span>) (Wire <span class="mi">39</span>);
             Xor (Wire <span class="mi">36</span>) (Wire <span class="mi">35</span>) (Wire <span class="mi">38</span>);
             And (Wire <span class="mi">4</span>) (Wire <span class="mi">12</span>) (Wire <span class="mi">37</span>);
             Xor (Wire <span class="mi">4</span>) (Wire <span class="mi">12</span>) (Wire <span class="mi">36</span>);
             Or (Wire <span class="mi">32</span>) (Wire <span class="mi">34</span>) (Wire <span class="mi">35</span>);
             And (Wire <span class="mi">31</span>) (Wire <span class="mi">30</span>) (Wire <span class="mi">34</span>);
             Xor (Wire <span class="mi">31</span>) (Wire <span class="mi">30</span>) (Wire <span class="mi">33</span>);
             And (Wire <span class="mi">3</span>) (Wire <span class="mi">11</span>) (Wire <span class="mi">32</span>);
             Xor (Wire <span class="mi">3</span>) (Wire <span class="mi">11</span>) (Wire <span class="mi">31</span>);
             Or (Wire <span class="mi">27</span>) (Wire <span class="mi">29</span>) (Wire <span class="mi">30</span>);
             And (Wire <span class="mi">26</span>) (Wire <span class="mi">25</span>) (Wire <span class="mi">29</span>);
             Xor (Wire <span class="mi">26</span>) (Wire <span class="mi">25</span>) (Wire <span class="mi">28</span>);
             And (Wire <span class="mi">2</span>) (Wire <span class="mi">10</span>) (Wire <span class="mi">27</span>);
             Xor (Wire <span class="mi">2</span>) (Wire <span class="mi">10</span>) (Wire <span class="mi">26</span>);
             Or (Wire <span class="mi">22</span>) (Wire <span class="mi">24</span>) (Wire <span class="mi">25</span>);
             And (Wire <span class="mi">21</span>) (Wire <span class="mi">20</span>) (Wire <span class="mi">24</span>);
             Xor (Wire <span class="mi">21</span>) (Wire <span class="mi">20</span>) (Wire <span class="mi">23</span>);
             And (Wire <span class="mi">1</span>) (Wire <span class="mi">9</span>) (Wire <span class="mi">22</span>);
             Xor (Wire <span class="mi">1</span>) (Wire <span class="mi">9</span>) (Wire <span class="mi">21</span>);
             Or (Wire <span class="mi">17</span>) (Wire <span class="mi">19</span>) (Wire <span class="mi">20</span>);
             And (Wire <span class="mi">16</span>) Gnd (Wire <span class="mi">19</span>);
             Xor (Wire <span class="mi">16</span>) Gnd (Wire <span class="mi">18</span>);
             And (Wire <span class="mi">0</span>) (Wire <span class="mi">8</span>) (Wire <span class="mi">17</span>);
             Xor (Wire <span class="mi">0</span>) (Wire <span class="mi">8</span>) (Wire <span class="mi">16</span>);
             AssignSignal (Wire <span class="mi">15</span>)
               (IndexConst (LocalVec Bit <span class="mi">8</span> <span class="mi">0</span>) <span class="mi">7</span>);
             AssignSignal (Wire <span class="mi">14</span>)
               (IndexConst (LocalVec Bit <span class="mi">8</span> <span class="mi">0</span>) <span class="mi">6</span>);
             AssignSignal (Wire <span class="mi">13</span>)
               (IndexConst (LocalVec Bit <span class="mi">8</span> <span class="mi">0</span>) <span class="mi">5</span>);
             AssignSignal (Wire <span class="mi">12</span>)
               (IndexConst (LocalVec Bit <span class="mi">8</span> <span class="mi">0</span>) <span class="mi">4</span>);
             AssignSignal (Wire <span class="mi">11</span>)
               (IndexConst (LocalVec Bit <span class="mi">8</span> <span class="mi">0</span>) <span class="mi">3</span>);
             AssignSignal (Wire <span class="mi">10</span>)
               (IndexConst (LocalVec Bit <span class="mi">8</span> <span class="mi">0</span>) <span class="mi">2</span>);
             AssignSignal (Wire <span class="mi">9</span>)
               (IndexConst (LocalVec Bit <span class="mi">8</span> <span class="mi">0</span>) <span class="mi">1</span>);
             AssignSignal (Wire <span class="mi">8</span>)
               (IndexConst (LocalVec Bit <span class="mi">8</span> <span class="mi">0</span>) <span class="mi">0</span>);
             AssignSignal (Wire <span class="mi">7</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;i&quot;</span>) <span class="mi">7</span>);
             AssignSignal (Wire <span class="mi">6</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;i&quot;</span>) <span class="mi">6</span>);
             AssignSignal (Wire <span class="mi">5</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;i&quot;</span>) <span class="mi">5</span>);
             AssignSignal (Wire <span class="mi">4</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;i&quot;</span>) <span class="mi">4</span>);
             AssignSignal (Wire <span class="mi">3</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;i&quot;</span>) <span class="mi">3</span>);
             AssignSignal (Wire <span class="mi">2</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;i&quot;</span>) <span class="mi">2</span>);
             AssignSignal (Wire <span class="mi">1</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;i&quot;</span>) <span class="mi">1</span>);
             AssignSignal (Wire <span class="mi">0</span>)
               (IndexConst
                  (NamedVector Bit <span class="mi">8</span> <span class="s2">&quot;i&quot;</span>) <span class="mi">0</span>)];
  inputs := [{|
             port_name := <span class="s2">&quot;i&quot;</span>;
             port_type := Vec Bit <span class="mi">8</span> |};
            {|
            port_name := <span class="s2">&quot;rst&quot;</span>;
            port_type := Bit |};
            {|
            port_name := <span class="s2">&quot;clk&quot;</span>;
            port_type := Bit |}];
  outputs := [{|
              port_name := <span class="s2">&quot;o&quot;</span>;
              port_type := Vec Bit <span class="mi">8</span> |}] |}
: <span class="kn">Module</span></span></blockquote></div></div></small></span></pre><p>Let's run a few simulations to see the circuit in action:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight"><span class="c">(* sum of 10 1s = 1,2,3,...10 *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk70"><span class="highlight"><span class="kn">Compute</span> map Bv2N
        (simulate sum (<span class="kp">repeat</span> (N2Bv_sized <span class="mi">8</span> <span class="mi">1</span>) <span class="mi">10</span>)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= [<span class="mi">1</span>%N; <span class="mi">2</span>%N; <span class="mi">3</span>%N; <span class="mi">4</span>%N; <span class="mi">5</span>%N; <span class="mi">6</span>%N; <span class="mi">7</span>%N; <span class="mi">8</span>%N; <span class="mi">9</span>%N;
  <span class="mi">10</span>%N]
: list N</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* sum of 1..10 = 1, 3, 6, 10, 15, 21, 28, 36, 45, 55 *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk71"><span class="highlight"><span class="kn">Compute</span> map Bv2N
        (simulate sum (byte_seq <span class="mi">1</span> <span class="mi">10</span>)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= [<span class="mi">1</span>%N; <span class="mi">3</span>%N; <span class="mi">6</span>%N; <span class="mi">10</span>%N; <span class="mi">15</span>%N; <span class="mi">21</span>%N; <span class="mi">28</span>%N; <span class="mi">36</span>%N;
  <span class="mi">45</span>%N; <span class="mi">55</span>%N]
: list N</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* sum of 10 1s starting at 10 = 11,12,13,...20 *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk72"><span class="highlight"><span class="kn">Compute</span> map Bv2N
        (simulate (sum_init (N2Bv_sized <span class="mi">8</span> <span class="mi">10</span>))
                  (<span class="kp">repeat</span> (N2Bv_sized <span class="mi">8</span> <span class="mi">1</span>) <span class="mi">10</span>)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= [<span class="mi">11</span>%N; <span class="mi">12</span>%N; <span class="mi">13</span>%N; <span class="mi">14</span>%N; <span class="mi">15</span>%N; <span class="mi">16</span>%N; <span class="mi">17</span>%N;
  <span class="mi">18</span>%N; <span class="mi">19</span>%N; <span class="mi">20</span>%N]
: list N</span></blockquote></div></div></small></span></pre><p>To write a correctness proof for <tt class="docutils literal">sum</tt>, we first need to describe its
behavior. There are many ways to do this, but one way is shown below.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight"><span class="c">(* computes the sum of a list of numbers (as a single number, not the</span>
<span class="c">   rolling sum) *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">sum_list_N</span> (<span class="nv">input</span> : list N) : N :=
  fold_left N.add input <span class="mi">0</span>%N.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* computes the *rolling* sum; the nth element of the output represents</span>
<span class="c">   the sum of the input up to index n *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">rolling_sum</span> (<span class="nv">input</span> : list N) : list N :=
  map (<span class="kr">fun</span> <span class="nv">i</span> =&gt; sum_list_N (firstn (S i) input)) (seq <span class="mi">0</span> (length input)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* example to show the behavior of rolling_sum *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk73"><span class="highlight"><span class="kn">Compute</span> rolling_sum [<span class="mi">5</span>;<span class="mi">6</span>;<span class="mi">7</span>]%N.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">= [<span class="mi">5</span>%N; <span class="mi">11</span>%N; <span class="mi">18</span>%N]
: list N</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* specification for the sum circuit : convert to N, get rolling_sum,</span>
<span class="c">   convert back to bit-vectors *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">spec_of_sum</span> {<span class="nv">n</span>} (<span class="nv">input</span> : list (combType (Vec Bit n)))
  : list (combType (Vec Bit n))
  := map (N2Bv_sized n) (rolling_sum (map Bv2N input)).</span></span></span></pre><p>To reason about loops, we can use loop-invariant lemmas like this one:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk74"><span class="highlight"><span class="kn">Check</span> simulate_Loop_invariant.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">simulate_Loop_invariant
     : <span class="kr">forall</span>
         (<span class="nv">body</span> : Circuit (<span class="nl">?i</span> * combType <span class="nl">?s</span>)
                   (<span class="nl">?o</span> * combType <span class="nl">?s</span>))
         (<span class="nv">I</span> : nat -&gt;
              combType <span class="nl">?s</span> -&gt;
              circuit_state body -&gt; list <span class="nl">?o</span> -&gt; <span class="kt">Prop</span>)
         (<span class="nv">P</span> : list <span class="nl">?o</span> -&gt; <span class="kt">Prop</span>) (<span class="nv">input</span> : list <span class="nl">?i</span>),
       I <span class="mi">0</span> (defaultCombValue <span class="nl">?s</span>) (reset_state body) [] -&gt;
       (<span class="kr">forall</span> (<span class="nv">t</span> : nat) (<span class="nv">acc</span> : list <span class="nl">?o</span>)
          (<span class="nv">st</span> : combType <span class="nl">?s</span>)
          (<span class="nv">bodyst</span> : circuit_state body) (<span class="nv">d</span> : <span class="nl">?i</span>),
        I t st bodyst acc -&gt;
        <span class="mi">0</span> &lt;= t &lt; Datatypes.length input -&gt;
        <span class="kr">let</span> <span class="nv">out_st&#39;_bodyst&#39;</span> :=
          step body bodyst (nth t input d, st) <span class="kr">in</span>
        <span class="kr">let</span> <span class="nv">out</span> := fst (fst out_st&#39;_bodyst&#39;) <span class="kr">in</span>
        <span class="kr">let</span> <span class="nv">st&#39;</span> := snd (fst out_st&#39;_bodyst&#39;) <span class="kr">in</span>
        <span class="kr">let</span> <span class="nv">bodyst&#39;</span> := snd out_st&#39;_bodyst&#39; <span class="kr">in</span>
        I (S t) st&#39; bodyst&#39; (acc ++ [out])) -&gt;
       (<span class="kr">forall</span> (<span class="nv">acc</span> : list <span class="nl">?o</span>) (<span class="nv">st</span> : combType <span class="nl">?s</span>)
          (<span class="nv">bodyst</span> : circuit_state body),
        I (Datatypes.length input) st bodyst acc -&gt;
        P acc) -&gt; P (simulate (Loop body) input)
<span class="kn">where</span>
<span class="nl">?i</span> : [ |- <span class="kt">Type</span>]
<span class="nl">?s</span> : [ |- SignalType]
<span class="nl">?o</span> : [ |- <span class="kt">Type</span>]</span></blockquote></div></div></small></span></pre><p>To use the loop-invariant lemma, though, we need to figure out what the
invariant of <tt class="docutils literal">sum</tt> should be. The invariant of a loop takes four arguments:
the timestep (a <tt class="docutils literal">nat</tt>), the current loop state (i.e. the value held by the
delay at this timestep), the state of the loop-body circuit, and the output
accumulator (a list of the outputs generated so far). Because the <tt class="docutils literal">sum</tt>
circuit has a purely combinational body, it has no internal state, so the body
state in our case is just Coq's <tt class="docutils literal">unit</tt> type. Here's the invariant statement:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">sum_invariant</span> {<span class="nv">n</span>} (<span class="nv">input</span> : list (combType (Vec Bit n)))
           (<span class="nv">t</span> : nat)
           (<span class="nv">loop_state</span> : combType (Vec Bit n))
           (<span class="nv">body_circuit_state</span> : unit)
           (<span class="nv">output_accumulator</span> : list (combType (Vec Bit n))) : <span class="kt">Prop</span> :=
  <span class="c">(* at timestep t... *)</span>
  <span class="c">(* ...the loop state holds the sum of the inputs so far (that is,</span>
<span class="c">     the first t inputs) *)</span>
  loop_state = N2Bv_sized n (sum_list_N (map Bv2N (firstn t input)))
  <span class="c">(* ... and the output accumulator matches the rolling-sum spec</span>
<span class="c">     applied to the inputs so far *)</span>
  /\ output_accumulator = spec_of_sum (firstn t input).</span></span></span></pre><p>Now, we can use the invariant to prove a correctness lemma. This proof could
certainly be a little more elegant and automated, but the steps are left
explicit here for those who are curious to follow the reasoning in detail.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight"><span class="c">(* This lemma is helpful for sum_correct *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk75"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">sum_list_N_snoc_bitvec</span> <span class="nv">n</span> <span class="nv">l</span> (<span class="nv">v</span> : Vector.t bool n) :
  N2Bv_sized n (sum_list_N (l ++ [Bv2N v]))
  = N2Bv_sized n (Bv2N v + Bv2N (N2Bv_sized n (sum_list_N l)))%N.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Vector.t bool n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N2Bv_sized n (sum_list_N (l ++ [Bv2N v])) =
N2Bv_sized n
  (Bv2N v + Bv2N (N2Bv_sized n (sum_list_N l)))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk76"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Vector.t bool n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N2Bv_sized n (sum_list_N (l ++ [Bv2N v])) =
N2Bv_sized n
  (Bv2N v + Bv2N (N2Bv_sized n (sum_list_N l)))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk77"><span class="highlight"><span class="nb">cbv</span> [sum_list_N].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Vector.t bool n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N2Bv_sized n (fold_left N.add (l ++ [Bv2N v]) <span class="mi">0</span>%N) =
N2Bv_sized n
  (Bv2N v +
   Bv2N (N2Bv_sized n (fold_left N.add l <span class="mi">0</span>%N)))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk78"><span class="highlight"><span class="nb">autorewrite with</span> pull_snoc.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Vector.t bool n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N2Bv_sized n (fold_left N.add l <span class="mi">0</span>%N + Bv2N v) =
N2Bv_sized n
  (Bv2N v +
   Bv2N (N2Bv_sized n (fold_left N.add l <span class="mi">0</span>%N)))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">  <span class="c">(* use Bv2N to bring the goal into the N realm, where it&#39;s</span>
<span class="c">     easier to solve using modular arithmetic rules *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk79"><span class="highlight"><span class="nb">apply</span> Bv2N_inj.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Vector.t bool n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Bv2N (N2Bv_sized n (fold_left N.add l <span class="mi">0</span>%N + Bv2N v)) =
Bv2N
  (N2Bv_sized n
     (Bv2N v +
      Bv2N (N2Bv_sized n (fold_left N.add l <span class="mi">0</span>%N))))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk7a"><span class="highlight"><span class="nb">rewrite</span> !Bv2N_N2Bv_sized_modulo.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Vector.t bool n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">((fold_left N.add l <span class="mi">0</span> + Bv2N v) mod <span class="mi">2</span> ^ N.of_nat n)%N =
((Bv2N v + fold_left N.add l <span class="mi">0</span> mod <span class="mi">2</span> ^ N.of_nat n)
 mod <span class="mi">2</span> ^ N.of_nat n)%N</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk7b"><span class="highlight"><span class="nb">rewrite</span> N.add_mod_idemp_r <span class="bp">by</span> (<span class="nb">apply</span> N.pow_nonzero; <span class="bp">lia</span>).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Vector.t bool n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">((fold_left N.add l <span class="mi">0</span> + Bv2N v) mod <span class="mi">2</span> ^ N.of_nat n)%N =
((Bv2N v + fold_left N.add l <span class="mi">0</span>) mod <span class="mi">2</span> ^ N.of_nat n)%N</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk7c"><span class="highlight"><span class="nb">rewrite</span> N.add_comm.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">l</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list N</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Vector.t bool n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">((Bv2N v + fold_left N.add l <span class="mi">0</span>) mod <span class="mi">2</span> ^ N.of_nat n)%N =
((Bv2N v + fold_left N.add l <span class="mi">0</span>) mod <span class="mi">2</span> ^ N.of_nat n)%N</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* Correctness lemma for sum *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk7d"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">sum_correct</span> <span class="nv">n</span> (<span class="nv">input</span> : list (combType (Vec Bit n))):
  simulate sum input = spec_of_sum input.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate sum input = spec_of_sum input</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk7e"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate sum input = spec_of_sum input</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk7f"><span class="highlight"><span class="nb">cbv</span> [sum].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate
  (Loop
     (Comb
        (<span class="kr">fun</span> &#39;(input, state) =&gt;
         sum &lt;- addN (input, state);; ret (sum, sum))))
  input = spec_of_sum input</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">  <span class="c">(* apply loop invariant lemma using sum_invariant; generates three</span>
<span class="c">     side conditions *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk80"><span class="highlight"><span class="nb">apply</span> simulate_Loop_invariant <span class="kr">with</span>
      (body:=Comb _) (I:=sum_invariant input).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">sum_invariant input <span class="mi">0</span> (defaultCombValue (Vec Bit n))
  (reset_state
     (Comb
        (<span class="kr">fun</span> &#39;(input, state) =&gt;
         sum &lt;- addN (input, state);; ret (sum, sum))))
  []</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tutorial-v-chk81" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="tutorial-v-chk81"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">t</span> : nat) (<span class="nv">acc</span> : list (combType (Vec Bit n)))
  (<span class="nv">st</span> : combType (Vec Bit n))
  (<span class="nv">bodyst</span> : circuit_state
              (Comb
                 (<span class="kr">fun</span> &#39;(input, state) =&gt;
                  sum &lt;- 
                  addN (input, state);; 
                  ret (sum, sum))))
  (<span class="nv">d</span> : combType (Vec Bit n)),
sum_invariant input t st bodyst acc -&gt;
<span class="mi">0</span> &lt;= t &lt; Datatypes.length input -&gt;
<span class="kr">let</span> <span class="nv">out_st&#39;_bodyst&#39;</span> :=
  step
    (Comb
       (<span class="kr">fun</span> &#39;(input, state) =&gt;
        sum &lt;- addN (input, state);; ret (sum, sum)))
    bodyst (nth t input d, st) <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">out</span> := fst (fst out_st&#39;_bodyst&#39;) <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">st&#39;</span> := snd (fst out_st&#39;_bodyst&#39;) <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">bodyst&#39;</span> := snd out_st&#39;_bodyst&#39; <span class="kr">in</span>
sum_invariant input (S t) st&#39; bodyst&#39; (acc ++ [out])</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="tutorial-v-chk82" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="tutorial-v-chk82"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">acc</span> : list (combType (Vec Bit n)))
  (<span class="nv">st</span> : combType (Vec Bit n))
  (<span class="nv">bodyst</span> : circuit_state
              (Comb
                 (<span class="kr">fun</span> &#39;(input, state) =&gt;
                  sum &lt;- 
                  addN (input, state);; 
                  ret (sum, sum)))),
sum_invariant input (Datatypes.length input) st bodyst
  acc -&gt; acc = spec_of_sum input</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk83"><span class="highlight">{ <span class="c">(* prove that invariant holds at the start of the loop *)</span></span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">sum_invariant input <span class="mi">0</span> (defaultCombValue (Vec Bit n))
  (reset_state
     (Comb
        (<span class="kr">fun</span> &#39;(input, state) =&gt;
         sum &lt;- addN (input, state);; ret (sum, sum))))
  []</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk84"><span class="highlight"><span class="nb">cbv</span> [sum_invariant].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">defaultCombValue (Vec Bit n) =
N2Bv_sized n (sum_list_N (map Bv2N (firstn <span class="mi">0</span> input))) /\
[] = spec_of_sum (firstn <span class="mi">0</span> input)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk85"><span class="highlight"><span class="nb">cbn</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Vector.const false n = Bvect_false n /\ [] = []</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">split</span>; <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk86"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">t</span> : nat) (<span class="nv">acc</span> : list (combType (Vec Bit n)))
  (<span class="nv">st</span> : combType (Vec Bit n))
  (<span class="nv">bodyst</span> : circuit_state
              (Comb
                 (<span class="kr">fun</span> &#39;(input, state) =&gt;
                  sum &lt;- 
                  addN (input, state);; 
                  ret (sum, sum))))
  (<span class="nv">d</span> : combType (Vec Bit n)),
sum_invariant input t st bodyst acc -&gt;
<span class="mi">0</span> &lt;= t &lt; Datatypes.length input -&gt;
<span class="kr">let</span> <span class="nv">out_st&#39;_bodyst&#39;</span> :=
  step
    (Comb
       (<span class="kr">fun</span> &#39;(input, state) =&gt;
        sum &lt;- addN (input, state);; ret (sum, sum)))
    bodyst (nth t input d, st) <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">out</span> := fst (fst out_st&#39;_bodyst&#39;) <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">st&#39;</span> := snd (fst out_st&#39;_bodyst&#39;) <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">bodyst&#39;</span> := snd out_st&#39;_bodyst&#39; <span class="kr">in</span>
sum_invariant input (S t) st&#39; bodyst&#39; (acc ++ [out])</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tutorial-v-chk87" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="tutorial-v-chk87"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">acc</span> : list (combType (Vec Bit n)))
  (<span class="nv">st</span> : combType (Vec Bit n))
  (<span class="nv">bodyst</span> : circuit_state
              (Comb
                 (<span class="kr">fun</span> &#39;(input, state) =&gt;
                  sum &lt;- 
                  addN (input, state);; 
                  ret (sum, sum)))),
sum_invariant input (Datatypes.length input) st bodyst
  acc -&gt; acc = spec_of_sum input</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk88"><span class="highlight">{</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">t</span> : nat) (<span class="nv">acc</span> : list (combType (Vec Bit n)))
  (<span class="nv">st</span> : combType (Vec Bit n))
  (<span class="nv">bodyst</span> : circuit_state
              (Comb
                 (<span class="kr">fun</span> &#39;(input, state) =&gt;
                  sum &lt;- 
                  addN (input, state);; 
                  ret (sum, sum))))
  (<span class="nv">d</span> : combType (Vec Bit n)),
sum_invariant input t st bodyst acc -&gt;
<span class="mi">0</span> &lt;= t &lt; Datatypes.length input -&gt;
<span class="kr">let</span> <span class="nv">out_st&#39;_bodyst&#39;</span> :=
  step
    (Comb
       (<span class="kr">fun</span> &#39;(input, state) =&gt;
        sum &lt;- addN (input, state);; ret (sum, sum)))
    bodyst (nth t input d, st) <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">out</span> := fst (fst out_st&#39;_bodyst&#39;) <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">st&#39;</span> := snd (fst out_st&#39;_bodyst&#39;) <span class="kr">in</span>
<span class="kr">let</span> <span class="nv">bodyst&#39;</span> := snd out_st&#39;_bodyst&#39; <span class="kr">in</span>
sum_invariant input (S t) st&#39; bodyst&#39; (acc ++ [out])</span></div></blockquote></div></div></small></span><span class="alectryon-wsp"><span class="highlight"> <span class="c">(* prove that, if the invariant holds at the beginning of the loop</span>
<span class="c">       body for timestep t, it holds at the end of the loop body for</span>
<span class="c">       timestep t + 1 *)</span>
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk89"><span class="highlight"><span class="nb">cbv</span> [sum_invariant step].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">t</span> : nat) (<span class="nv">acc</span> : list (combType (Vec Bit n)))
  (<span class="nv">st</span> : combType (Vec Bit n)),
circuit_state
  (Comb
     (<span class="kr">fun</span> &#39;(input, state) =&gt;
      sum &lt;- addN (input, state);; ret (sum, sum))) -&gt;
<span class="kr">forall</span> <span class="nv">d</span> : combType (Vec Bit n),
st =
N2Bv_sized n (sum_list_N (map Bv2N (firstn t input))) /\
acc = spec_of_sum (firstn t input) -&gt;
<span class="mi">0</span> &lt;= t &lt; Datatypes.length input -&gt;
snd
  (fst
     (sum &lt;- addN (nth t input d, st);; ret (sum, sum),
     tt)) =
N2Bv_sized n
  (sum_list_N (map Bv2N (firstn (S t) input))) /\
acc ++
[fst
   (fst
      (sum &lt;- addN (nth t input d, st);;
       ret (sum, sum), tt))] =
spec_of_sum (firstn (S t) input)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk8a"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">acc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">st</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bodyst</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state
  (Comb
     (<span class="kr">fun</span> &#39;(input, state) =&gt;
      sum &lt;- addN (input, state);;
      ret (sum, sum)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st =
N2Bv_sized n
  (sum_list_N (map Bv2N (firstn t input))) /\
acc = spec_of_sum (firstn t input)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= t &lt; Datatypes.length input</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">snd
  (fst
     (sum &lt;- addN (nth t input d, st);; ret (sum, sum),
     tt)) =
N2Bv_sized n
  (sum_list_N (map Bv2N (firstn (S t) input))) /\
acc ++
[fst
   (fst
      (sum &lt;- addN (nth t input d, st);;
       ret (sum, sum), tt))] =
spec_of_sum (firstn (S t) input)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk8b"><span class="highlight">simpl_ident.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">acc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">st</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bodyst</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state
  (Comb
     (<span class="kr">fun</span> &#39;(input, state) =&gt;
      sum &lt;- addN (input, state);;
      ret (sum, sum)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st =
N2Bv_sized n
  (sum_list_N (map Bv2N (firstn t input))) /\
acc = spec_of_sum (firstn t input)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= t &lt; Datatypes.length input</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N2Bv_sized n (Bv2N (nth t input d) + Bv2N st) =
N2Bv_sized n
  (sum_list_N (map Bv2N (firstn (S t) input))) /\
acc ++ [N2Bv_sized n (Bv2N (nth t input d) + Bv2N st)] =
spec_of_sum (firstn (S t) input)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk8c"><span class="highlight">logical_simplify; <span class="nb">subst</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bodyst</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state
  (Comb
     (<span class="kr">fun</span> &#39;(input, state) =&gt;
      sum &lt;- addN (input, state);;
      ret (sum, sum)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t &lt; Datatypes.length input</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N2Bv_sized n
  (Bv2N (nth t input d) +
   Bv2N
     (N2Bv_sized n
        (sum_list_N (map Bv2N (firstn t input))))) =
N2Bv_sized n
  (sum_list_N (map Bv2N (firstn (S t) input))) /\
spec_of_sum (firstn t input) ++
[N2Bv_sized n
   (Bv2N (nth t input d) +
    Bv2N
      (N2Bv_sized n
         (sum_list_N (map Bv2N (firstn t input)))))] =
spec_of_sum (firstn (S t) input)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk8d"><span class="highlight"><span class="nb">split</span>. <span class="c">(* separate the two invariant clauses *)</span></span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bodyst</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state
  (Comb
     (<span class="kr">fun</span> &#39;(input, state) =&gt;
      sum &lt;- addN (input, state);;
      ret (sum, sum)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t &lt; Datatypes.length input</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N2Bv_sized n
  (Bv2N (nth t input d) +
   Bv2N
     (N2Bv_sized n
        (sum_list_N (map Bv2N (firstn t input))))) =
N2Bv_sized n
  (sum_list_N (map Bv2N (firstn (S t) input)))</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tutorial-v-chk8e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bodyst</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state
  (Comb
     (<span class="kr">fun</span> &#39;(input, state) =&gt;
      sum &lt;- addN (input, state);;
      ret (sum, sum)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t &lt; Datatypes.length input</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="tutorial-v-chk8e"><hr></label><div class="goal-conclusion"><span class="highlight">spec_of_sum (firstn t input) ++
[N2Bv_sized n
   (Bv2N (nth t input d) +
    Bv2N
      (N2Bv_sized n
         (sum_list_N (map Bv2N (firstn t input)))))] =
spec_of_sum (firstn (S t) input)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk8f"><span class="highlight">{</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bodyst</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state
  (Comb
     (<span class="kr">fun</span> &#39;(input, state) =&gt;
      sum &lt;- addN (input, state);;
      ret (sum, sum)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t &lt; Datatypes.length input</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N2Bv_sized n
  (Bv2N (nth t input d) +
   Bv2N
     (N2Bv_sized n
        (sum_list_N (map Bv2N (firstn t input))))) =
N2Bv_sized n
  (sum_list_N (map Bv2N (firstn (S t) input)))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk90"><span class="highlight"><span class="nb">rewrite</span> firstn_succ_snoc <span class="kr">with</span> (d0:=d) <span class="bp">by</span> <span class="bp">lia</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bodyst</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state
  (Comb
     (<span class="kr">fun</span> &#39;(input, state) =&gt;
      sum &lt;- addN (input, state);;
      ret (sum, sum)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t &lt; Datatypes.length input</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N2Bv_sized n
  (Bv2N (nth t input d) +
   Bv2N
     (N2Bv_sized n
        (sum_list_N (map Bv2N (firstn t input))))) =
N2Bv_sized n
  (sum_list_N
     (map Bv2N (firstn t input ++ [nth t input d])))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk91"><span class="highlight"><span class="nb">autorewrite with</span> pull_snoc.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bodyst</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state
  (Comb
     (<span class="kr">fun</span> &#39;(input, state) =&gt;
      sum &lt;- addN (input, state);;
      ret (sum, sum)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t &lt; Datatypes.length input</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N2Bv_sized n
  (Bv2N (nth t input d) +
   Bv2N
     (N2Bv_sized n
        (sum_list_N (map Bv2N (firstn t input))))) =
N2Bv_sized n
  (sum_list_N
     (map Bv2N (firstn t input) ++
      [Bv2N (nth t input d)]))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk92"><span class="highlight"><span class="nb">rewrite</span> sum_list_N_snoc_bitvec.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bodyst</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state
  (Comb
     (<span class="kr">fun</span> &#39;(input, state) =&gt;
      sum &lt;- addN (input, state);;
      ret (sum, sum)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t &lt; Datatypes.length input</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N2Bv_sized n
  (Bv2N (nth t input d) +
   Bv2N
     (N2Bv_sized n
        (sum_list_N (map Bv2N (firstn t input))))) =
N2Bv_sized n
  (Bv2N (nth t input d) +
   Bv2N
     (N2Bv_sized n
        (sum_list_N (map Bv2N (firstn t input)))))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk93"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bodyst</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state
  (Comb
     (<span class="kr">fun</span> &#39;(input, state) =&gt;
      sum &lt;- addN (input, state);;
      ret (sum, sum)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t &lt; Datatypes.length input</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">spec_of_sum (firstn t input) ++
[N2Bv_sized n
   (Bv2N (nth t input d) +
    Bv2N
      (N2Bv_sized n
         (sum_list_N (map Bv2N (firstn t input)))))] =
spec_of_sum (firstn (S t) input)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk94"><span class="highlight">{</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bodyst</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state
  (Comb
     (<span class="kr">fun</span> &#39;(input, state) =&gt;
      sum &lt;- addN (input, state);;
      ret (sum, sum)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t &lt; Datatypes.length input</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">spec_of_sum (firstn t input) ++
[N2Bv_sized n
   (Bv2N (nth t input d) +
    Bv2N
      (N2Bv_sized n
         (sum_list_N (map Bv2N (firstn t input)))))] =
spec_of_sum (firstn (S t) input)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk95"><span class="highlight"><span class="nb">cbv</span> [spec_of_sum rolling_sum].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bodyst</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state
  (Comb
     (<span class="kr">fun</span> &#39;(input, state) =&gt;
      sum &lt;- addN (input, state);;
      ret (sum, sum)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t &lt; Datatypes.length input</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map (N2Bv_sized n)
  (map
     (<span class="kr">fun</span> <span class="nv">i</span> : nat =&gt;
      sum_list_N
        (firstn (S i) (map Bv2N (firstn t input))))
     (seq <span class="mi">0</span>
        (Datatypes.length (map Bv2N (firstn t input))))) ++
[N2Bv_sized n
   (Bv2N (nth t input d) +
    Bv2N
      (N2Bv_sized n
         (sum_list_N (map Bv2N (firstn t input)))))] =
map (N2Bv_sized n)
  (map
     (<span class="kr">fun</span> <span class="nv">i</span> : nat =&gt;
      sum_list_N
        (firstn (S i) (map Bv2N (firstn (S t) input))))
     (seq <span class="mi">0</span>
        (Datatypes.length
           (map Bv2N (firstn (S t) input)))))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">      <span class="c">(* simplify expression using list lemmas *)</span>
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk96"><span class="highlight"><span class="nb">rewrite</span> !map_map.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bodyst</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state
  (Comb
     (<span class="kr">fun</span> &#39;(input, state) =&gt;
      sum &lt;- addN (input, state);;
      ret (sum, sum)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t &lt; Datatypes.length input</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map
  (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt;
   N2Bv_sized n
     (sum_list_N
        (firstn (S x) (map Bv2N (firstn t input)))))
  (seq <span class="mi">0</span>
     (Datatypes.length (map Bv2N (firstn t input)))) ++
[N2Bv_sized n
   (Bv2N (nth t input d) +
    Bv2N
      (N2Bv_sized n
         (sum_list_N (map Bv2N (firstn t input)))))] =
map
  (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt;
   N2Bv_sized n
     (sum_list_N
        (firstn (S x) (map Bv2N (firstn (S t) input)))))
  (seq <span class="mi">0</span>
     (Datatypes.length (map Bv2N (firstn (S t) input))))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk97"><span class="highlight"><span class="nb">autorewrite with</span> push_length natsimpl.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bodyst</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state
  (Comb
     (<span class="kr">fun</span> &#39;(input, state) =&gt;
      sum &lt;- addN (input, state);;
      ret (sum, sum)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t &lt; Datatypes.length input</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map
  (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt;
   N2Bv_sized n
     (sum_list_N
        (firstn (S x) (map Bv2N (firstn t input)))))
  (seq <span class="mi">0</span> t) ++
[N2Bv_sized n
   (Bv2N (nth t input d) +
    Bv2N
      (N2Bv_sized n
         (sum_list_N (map Bv2N (firstn t input)))))] =
map
  (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt;
   N2Bv_sized n
     (sum_list_N
        (firstn (S x) (map Bv2N (firstn (S t) input)))))
  (seq <span class="mi">0</span> (S t))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk98"><span class="highlight"><span class="nb">rewrite</span> firstn_succ_snoc <span class="kr">with</span> (d0:=d) <span class="bp">by</span> <span class="bp">lia</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bodyst</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state
  (Comb
     (<span class="kr">fun</span> &#39;(input, state) =&gt;
      sum &lt;- addN (input, state);;
      ret (sum, sum)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t &lt; Datatypes.length input</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map
  (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt;
   N2Bv_sized n
     (sum_list_N
        (firstn (S x) (map Bv2N (firstn t input)))))
  (seq <span class="mi">0</span> t) ++
[N2Bv_sized n
   (Bv2N (nth t input d) +
    Bv2N
      (N2Bv_sized n
         (sum_list_N (map Bv2N (firstn t input)))))] =
map
  (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt;
   N2Bv_sized n
     (sum_list_N
        (firstn (S x)
           (map Bv2N
              (firstn t input ++ [nth t input d])))))
  (seq <span class="mi">0</span> (S t))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk99"><span class="highlight"><span class="nb">autorewrite with</span> pull_snoc natsimpl.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bodyst</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state
  (Comb
     (<span class="kr">fun</span> &#39;(input, state) =&gt;
      sum &lt;- addN (input, state);;
      ret (sum, sum)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t &lt; Datatypes.length input</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map
  (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt;
   N2Bv_sized n
     (sum_list_N
        (firstn (S x) (map Bv2N (firstn t input)))))
  (seq <span class="mi">0</span> t) ++
[N2Bv_sized n
   (Bv2N (nth t input d) +
    Bv2N
      (N2Bv_sized n
         (sum_list_N (map Bv2N (firstn t input)))))] =
map
  (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt;
   N2Bv_sized n
     (sum_list_N
        (firstn (S x)
           (map Bv2N (firstn t input) ++
            [Bv2N (nth t input d)])))) 
  (seq <span class="mi">0</span> t) ++
[N2Bv_sized n
   (sum_list_N
      (firstn (S t)
         (map Bv2N (firstn t input) ++
          [Bv2N (nth t input d)])))]</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk9a"><span class="highlight"><span class="nb">apply</span> f_equal2. <span class="c">(* split front of lists from last elements *)</span></span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bodyst</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state
  (Comb
     (<span class="kr">fun</span> &#39;(input, state) =&gt;
      sum &lt;- addN (input, state);;
      ret (sum, sum)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t &lt; Datatypes.length input</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map
  (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt;
   N2Bv_sized n
     (sum_list_N
        (firstn (S x) (map Bv2N (firstn t input)))))
  (seq <span class="mi">0</span> t) =
map
  (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt;
   N2Bv_sized n
     (sum_list_N
        (firstn (S x)
           (map Bv2N (firstn t input) ++
            [Bv2N (nth t input d)])))) 
  (seq <span class="mi">0</span> t)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="tutorial-v-chk9b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bodyst</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state
  (Comb
     (<span class="kr">fun</span> &#39;(input, state) =&gt;
      sum &lt;- addN (input, state);;
      ret (sum, sum)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t &lt; Datatypes.length input</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="tutorial-v-chk9b"><hr></label><div class="goal-conclusion"><span class="highlight">[N2Bv_sized n
   (Bv2N (nth t input d) +
    Bv2N
      (N2Bv_sized n
         (sum_list_N (map Bv2N (firstn t input)))))] =
[N2Bv_sized n
   (sum_list_N
      (firstn (S t)
         (map Bv2N (firstn t input) ++
          [Bv2N (nth t input d)])))]</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk9c"><span class="highlight">{</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bodyst</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state
  (Comb
     (<span class="kr">fun</span> &#39;(input, state) =&gt;
      sum &lt;- addN (input, state);;
      ret (sum, sum)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t &lt; Datatypes.length input</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">map
  (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt;
   N2Bv_sized n
     (sum_list_N
        (firstn (S x) (map Bv2N (firstn t input)))))
  (seq <span class="mi">0</span> t) =
map
  (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt;
   N2Bv_sized n
     (sum_list_N
        (firstn (S x)
           (map Bv2N (firstn t input) ++
            [Bv2N (nth t input d)])))) 
  (seq <span class="mi">0</span> t)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk9d"><span class="highlight"><span class="nb">apply</span> map_ext_in; <span class="nb">intro</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bodyst</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state
  (Comb
     (<span class="kr">fun</span> &#39;(input, state) =&gt;
      sum &lt;- addN (input, state);;
      ret (sum, sum)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t &lt; Datatypes.length input</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In a (seq <span class="mi">0</span> t) -&gt;
N2Bv_sized n
  (sum_list_N
     (firstn (S a) (map Bv2N (firstn t input)))) =
N2Bv_sized n
  (sum_list_N
     (firstn (S a)
        (map Bv2N (firstn t input) ++
         [Bv2N (nth t input d)])))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk9e"><span class="highlight"><span class="nb">rewrite</span> in_seq; <span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bodyst</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state
  (Comb
     (<span class="kr">fun</span> &#39;(input, state) =&gt;
      sum &lt;- addN (input, state);;
      ret (sum, sum)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t &lt; Datatypes.length input</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= a &lt; <span class="mi">0</span> + t</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N2Bv_sized n
  (sum_list_N
     (firstn (S a) (map Bv2N (firstn t input)))) =
N2Bv_sized n
  (sum_list_N
     (firstn (S a)
        (map Bv2N (firstn t input) ++
         [Bv2N (nth t input d)])))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chk9f"><span class="highlight"><span class="nb">autorewrite with</span> push_firstn push_length natsimpl listsimpl.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bodyst</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state
  (Comb
     (<span class="kr">fun</span> &#39;(input, state) =&gt;
      sum &lt;- addN (input, state);;
      ret (sum, sum)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t &lt; Datatypes.length input</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= a &lt; <span class="mi">0</span> + t</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">N2Bv_sized n
  (sum_list_N (map Bv2N (firstn (S a) input))) =
N2Bv_sized n
  (sum_list_N (map Bv2N (firstn (S a) input)))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chka0"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bodyst</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state
  (Comb
     (<span class="kr">fun</span> &#39;(input, state) =&gt;
      sum &lt;- addN (input, state);;
      ret (sum, sum)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t &lt; Datatypes.length input</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[N2Bv_sized n
   (Bv2N (nth t input d) +
    Bv2N
      (N2Bv_sized n
         (sum_list_N (map Bv2N (firstn t input)))))] =
[N2Bv_sized n
   (sum_list_N
      (firstn (S t)
         (map Bv2N (firstn t input) ++
          [Bv2N (nth t input d)])))]</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chka1"><span class="highlight">{</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bodyst</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state
  (Comb
     (<span class="kr">fun</span> &#39;(input, state) =&gt;
      sum &lt;- addN (input, state);;
      ret (sum, sum)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t &lt; Datatypes.length input</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[N2Bv_sized n
   (Bv2N (nth t input d) +
    Bv2N
      (N2Bv_sized n
         (sum_list_N (map Bv2N (firstn t input)))))] =
[N2Bv_sized n
   (sum_list_N
      (firstn (S t)
         (map Bv2N (firstn t input) ++
          [Bv2N (nth t input d)])))]</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chka2"><span class="highlight"><span class="nb">autorewrite with</span> push_firstn push_length natsimpl listsimpl.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bodyst</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state
  (Comb
     (<span class="kr">fun</span> &#39;(input, state) =&gt;
      sum &lt;- addN (input, state);;
      ret (sum, sum)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t &lt; Datatypes.length input</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[N2Bv_sized n
   (Bv2N (nth t input d) +
    Bv2N
      (N2Bv_sized n
         (sum_list_N (map Bv2N (firstn t input)))))] =
[N2Bv_sized n
   (sum_list_N
      (map Bv2N (firstn t input) ++
       [Bv2N (nth t input d)]))]</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chka3"><span class="highlight"><span class="nb">rewrite</span> sum_list_N_snoc_bitvec.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bodyst</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state
  (Comb
     (<span class="kr">fun</span> &#39;(input, state) =&gt;
      sum &lt;- addN (input, state);;
      ret (sum, sum)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="mi">0</span> &lt;= t</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t &lt; Datatypes.length input</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[N2Bv_sized n
   (Bv2N (nth t input d) +
    Bv2N
      (N2Bv_sized n
         (sum_list_N (map Bv2N (firstn t input)))))] =
[N2Bv_sized n
   (Bv2N (nth t input d) +
    Bv2N
      (N2Bv_sized n
         (sum_list_N (map Bv2N (firstn t input)))))]</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">}</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">}</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chka4"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">acc</span> : list (combType (Vec Bit n)))
  (<span class="nv">st</span> : combType (Vec Bit n))
  (<span class="nv">bodyst</span> : circuit_state
              (Comb
                 (<span class="kr">fun</span> &#39;(input, state) =&gt;
                  sum &lt;- 
                  addN (input, state);; 
                  ret (sum, sum)))),
sum_invariant input (Datatypes.length input) st bodyst
  acc -&gt; acc = spec_of_sum input</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chka5"><span class="highlight">{ <span class="c">(* prove that the invariant implies the postcondition *)</span></span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">acc</span> : list (combType (Vec Bit n)))
  (<span class="nv">st</span> : combType (Vec Bit n))
  (<span class="nv">bodyst</span> : circuit_state
              (Comb
                 (<span class="kr">fun</span> &#39;(input, state) =&gt;
                  sum &lt;- 
                  addN (input, state);; 
                  ret (sum, sum)))),
sum_invariant input (Datatypes.length input) st bodyst
  acc -&gt; acc = spec_of_sum input</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chka6"><span class="highlight"><span class="nb">cbv</span> [sum_invariant]; <span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input, acc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">st</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">combType (Vec Bit n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bodyst</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state
  (Comb
     (<span class="kr">fun</span> &#39;(input, state) =&gt;
      sum &lt;- addN (input, state);;
      ret (sum, sum)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">st =
N2Bv_sized n
  (sum_list_N
     (map Bv2N
        (firstn (Datatypes.length input) input))) /\
acc =
spec_of_sum
  (firstn (Datatypes.length input) input)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">acc = spec_of_sum input</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chka7"><span class="highlight">logical_simplify; <span class="nb">subst</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bodyst</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state
  (Comb
     (<span class="kr">fun</span> &#39;(input, state) =&gt;
      sum &lt;- addN (input, state);;
      ret (sum, sum)))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">spec_of_sum (firstn (Datatypes.length input) input) =
spec_of_sum input</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chka8"><span class="highlight"><span class="nb">autorewrite with</span> push_firstn.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bodyst</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">circuit_state
  (Comb
     (<span class="kr">fun</span> &#39;(input, state) =&gt;
      sum &lt;- addN (input, state);;
      ret (sum, sum)))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">spec_of_sum input = spec_of_sum input</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">}</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>To wrap up our <tt class="docutils literal">sum</tt> proofs, here's a quick demonstration that <tt class="docutils literal">sum_concise</tt>
is equivalent to <tt class="docutils literal">sum</tt>:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chka9"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">sum_concise_correct</span> <span class="nv">n</span> (<span class="nv">input</span> : list (combType (Vec Bit n))):
  simulate sum_concise input = simulate sum input.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate sum_concise input = simulate sum input</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-v-chkaa"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">input</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">list (combType (Vec Bit n))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">simulate sum_concise input = simulate sum input</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre></div>
</div>
</div></body>
</html>
