# An Open Source Flow from Circuits in Coq to a running FPGA circuit on a Lattice iCEstick

This directory contains an example flow which uses only open source tools to map a simple
circuit design in Coq (an interactive theorem prover) all the way to a working circuit on
a circuit board called a Lattice Semiconductor [iCEstick](https://www.latticesemi.com/icestick)
which contains a Lattice Semiconductor [iCE40HX-1k](http://www.latticesemi.com/en/Products/FPGAandCPLD/iCE40) FPGA. The flow works on Linux and **Mac OS X**!

Another directory in this repository contains a
[similar example](https://github.com/project-oak/oak-hardware/tree/master/kami/counter)
that uses a commercial Bluspec compiler and the commercial Xilinx tools as part of another Coq to FPGA flow that targets a Xilinx FPGA board.

We make use of the [Kami](https://github.com/mit-plv/kami) system to specify a simple counter circuit in Coq
and drive it through the point where we can generate a Verilog netlist which can be implemented and a Lattice Semiconductor [iCEstick](https://www.latticesemi.com/icestick) is used to run the design using only open source tools:
* The [Coq](https://coq.inria.fr/) interactive theorem prover is open source.
* The [Kami](https://github.com/mit-plv/kami) DSL for a Bluespec subset is open source.
* The [Ocaml](https://ocaml.org/) compiler used as part of the Coq to Bluespec extraction process is open source.
* An open source Bluespec compiler is used to synthesize the Bluespec circuit description extracted from
  Coq to a Verilog circuit description. We use an open source Bluespec compiler
  [CBG-BSV](https://www.cl.cam.ac.uk/~djg11/wwwhpr/toy-bluespec-compiler.html)
  from David Greaves which is described in the paper [An Open-Source Bluespec Compiler](https://arxiv.org/abs/1905.03746) and also in the upcoming [MEMOCODE 2019](https://memocode.github.io/2019/) paper *Further Sub-cycle and Multi-cycle Schedulling support for Bluespec Verilog*.
* The [Yosys](http://www.clifford.at/yosys/) Verilog synthesis system that synthesizes the high level Verilog   generated by the Bluespec compiler into a low level structural netlist is open source.
* The [nextpnr-ice40](https://github.com/YosysHQ/nextpnr) program used to place and routed the gate level 
  netlist onto a iCE40HX-1k FPGA is open source.
* The [icestorm](http://www.clifford.at/icestorm/) system is used to produce the programming bitstream needed 
  to configure the iCE40HX-1k FPGA and is open source.

The counter design controls five LEDs on the board which are made
to flash in the binary sequence 0..15.
The entire flow from circuit extraction from Coq to FPGA bitstream generation can be run by
just typing `make` in this directory. Typing `make configure` will actually configure a connected
iCEstick board and make the LEDs flash in the 0..15 sequence.

The example we start with is a simple 5-bit counter [Counter.v](Counter.v):
```coq
Require Import Kami.
Require Import Kami.Syntax.
Require Import Kami.Synthesize.
Require Import Ext.BSyntax.
Require Import ExtrOcamlNatInt ExtrOcamlString.

Definition count := MethodSig ("counter" -- "count_value") (Bit 4) : Void.

Definition counter5 := MODULE {
    Register "counterReg" : Bit 5 <- $0

    with Rule "incrementAndOutput" :=
       Read val <- "counterReg";
       Write "counterReg" <- #val + ($1 :: Bit 5);
       Retv

    with Method "count_value" () : (Bit 5) :=
       Read counterValue <- "counterReg";
       Ret #counterValue

  }.

Hint Unfold count : MethDefs.
Hint Unfold counter5 : ModuleDefs.

Extraction Language Ocaml.

Set Extraction Optimize.
Set Extraction KeepSingleton.
Unset Extraction AutoInline.

Definition targetCounter5 := ModulesSToBModules (getModuleS counter5).

Extraction "Counter.ml" targetCounter5.

```

The Coq code here describes a simple 5-bit counter circuit which increments the counter every clock cycle.
When the circuit is reset the counter is initialized with the value 0. This Coq description is cast in terms
of a DSL based on the Bluespec language. We could have written the counter in Bluespec as:

```
interface Counter;
  method Bit#(5) count();
endinterface

(* synthesize *)
module mkCounter5(Counter);
   Reg#(Bit#(5)) value <- mkReg(0);

   rule counter;
     value <= value + 1;
   endrule

   method int count();
    return value;
   endmethod

endmodule: mkCounter5
```
The Kami code shown above is a representation of this Bluespec in Coq with a DSL.

When the Kami code for the counter is evaluated an OCaml program `Counter4.ml` is extracted from Coq.
This program is linked with a suitable pretty-printing module for Bluespec code
generation and when executed generates the corresponding Bluespec module `Counter4.bsv`:

```
import Vector::*;
import BuildVector::*;
import RegFile::*;

interface Module1; method ActionValue#(Bit#(5)) count_value ();
endinterface

module mkModule1 (Module1);
    Reg#(Bit#(5)) counterReg <- mkReg(5'h0);
    
    rule incrementAndOutput;
        let x_0 = (counterReg);
        counterReg <= (x_0) + ((Bit#(5))'(5'h1));
        
    endrule
    
    
    method ActionValue#(Bit#(5)) count_value ();
        let x_1 = (counterReg);
        return x_1;
    endmethod
    
endmodule

module mkTop (Empty);Module1 m1 <- mkModule1 ();
                     
endmodule
```

The CBG-BSV open source Bluespec compiler can be used to synthesize this Bluespec description into a Verilog implementation.
The generated Verilog file (`mkModule1.v`) contains a circuit module with the following interface ports:

```verilog
// CBG Orangepath HPR L/S System

// Verilog output file generated at 9/19/2019 4:27:20 PM
// CBG-BSV TOY COMPILER VERSION 0.47 ALPHA 18th-Sept-2019
//  /usr/local/google/home/satnam/bitbucket-hprls2/bsvc/priv_distro/lib/bsv.exe -incdir=/usr/local/google/home/satnam/bitbucket-hprls2/bsvc/priv_distro/libs/camlib Counter5.bsv -g mkModule1 -vnl=mkModule1.v -conerefine=disable
`timescale 1ns/1ns


module mkModule1(    
/* portgroup= abstractionName=nokind */
    output RDY_count_value,
    input EN_count_value,
    output reg [4:0] count_value,
    
/* portgroup= abstractionName=nokind pi_name=shemits10 */

/* portgroup= abstractionName=L2590-vg pi_name=net2batchdirectoratenets10 */
input CLK,
    input RST_N);

function [4:0] rtl_unsigned_bitextract0;
   input [31:0] arg;
   rtl_unsigned_bitextract0 = $unsigned(arg[4:0]);
   endfunction

// abstractionName=nokind pi_name=sigmash10
  reg [4:0] counterReg_read;
  reg EN_counterReg_write;
  reg [4:0] counterReg_write_din;
// abstractionName=nokind pi_name=mainmash10
  reg mkModule1_incrementAndOutput_FIRE;
 always   @(posedge CLK )  begin 
      //Start structure cvtToVerilogmkModule1/1.0
      if (!RST_N)  counterReg_read <= 32'd0;
           else if (EN_counterReg_write)  counterReg_read <= counterReg_write_din;
              //End structure cvtToVerilogmkModule1/1.0


       end 
      

assign RDY_count_value = 32'd1;

always @(*) mkModule1_incrementAndOutput_FIRE = RST_N;

always @(*) EN_counterReg_write = mkModule1_incrementAndOutput_FIRE;

always @(*) counterReg_write_din = rtl_unsigned_bitextract0(5'd1+counterReg_read);

always @(*) count_value = counterReg_read;

// Structural Resource (FU) inventory for mkModule1:// 2 vectors of width 1
// 2 vectors of width 5
// Total state bits in module = 12 bits.
// Total number of leaf cells = 0
endmodule
```

We can use this counter to control the flashing of the five LEDs on the iCEstick board. We need to
produce a top-level circuit that wires up the pins for the LEDs and the reset button to the core counter
circuit generated from Kami. So we can see the LEDs flash at a frequency suitable for human consumption
we take one of the clock inputs to the FPGA and divide it down to approximately 1Hz to
control the sequencing of the LED flashes. The code for this top level circuit is in the VHDL file
[counter5_top.v](counter5_top.v) which instantiates the generated `mkModule1` module and wires
it up appropriately. Along with a file that specifies the location of the pins to be used on FPGA chip
[counter5_top.pcf](counter5_top.pcf) we can use the icestorm tools to convert this source (partly generated from
Kami/Coq and partly written by us) into a programming bitstream for the FPGA on the iCEstick.

The entire flow from the Coq extraction to the programming of the iCEstick can be done by typing `make configure` once all the necessary tools have been installed. The LSB bit-5 LED is in the center and is green.

![iCEstick](icestick.gif)

```
$ make configure
coq_makefile -f _CoqProject -o Makefile.coq
Warning: install rule assumes that -R/-Q . _ is the only -R/-Q option
Warning: install rule assumes that -R/-Q . _ is the only -R/-Q option
Warning: -R/-Q options don't have a correct common prefix,
 install-doc will put anything in $INSTALLDEFAULTROOT
make -f Makefile.coq
make[1]: Entering directory '/usr/local/google/home/satnam/oak-hardware/kami/icestick-counter'
COQDEP Counter.v
COQC Counter.v
make[1]: Leaving directory '/usr/local/google/home/satnam/oak-hardware/kami/icestick-counter'
cp ../../../kami/Kami/Ext/Ocaml/PP.ml .
sed -i 's/Target/Counter/' PP.ml
ocamlbuild -use-ocamlfind Main.native Counter.v 
+ ocamlfind ocamlc -c -o PP.cmo PP.ml
File "PP.ml", line 54, characters 13-32:
Warning 3: deprecated: String.uncapitalize
Use String.uncapitalize_ascii instead.
File "PP.ml", line 370, characters 2-387:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
Array (_, _)
File "PP.ml", line 400, characters 2-497:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
ConstArray (_, _, _)
File "PP.ml", line 425, characters 2-6682:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(BUniBit
   (_, _, (ConstExtractPf (_, _, _, _)|TruncPf (_, _)|TruncLsbPf (_, _)), _)|
BBinBit (_, _, _, ConcatPf (_, _, _), _, _)|BReadArrayIndex (_, _)|
BBuildArray (_, _)|BUpdateArray (_, _, _))
+ ocamlfind ocamlopt -c -o Counter.cmx Counter.ml
File "Counter.ml", line 458, characters 54-56:
Warning 20: this argument will not be used by the function.
+ ocamlfind ocamlopt -c -o PP.cmx PP.ml
File "PP.ml", line 54, characters 13-32:
Warning 3: deprecated: String.uncapitalize
Use String.uncapitalize_ascii instead.
File "PP.ml", line 370, characters 2-387:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
Array (_, _)
File "PP.ml", line 400, characters 2-497:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
ConstArray (_, _, _)
File "PP.ml", line 425, characters 2-6682:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(BUniBit
   (_, _, (ConstExtractPf (_, _, _, _)|TruncPf (_, _)|TruncLsbPf (_, _)), _)|
BBinBit (_, _, _, ConcatPf (_, _, _), _, _)|BReadArrayIndex (_, _)|
BBuildArray (_, _)|BUpdateArray (_, _, _))
Finished, 11 targets (0 cached) in 00:00:01.
./Main.native Counter5.bsv
sed -i -e '/RegFileZero/d' -e '/MulDiv/d' Counter5.bsv
/usr/local/google/home/satnam/bitbucket-hprls2/bsvc/priv_distro/bin/bsvc -incdir=/usr/local/google/home/satnam/bitbucket-hprls2/bsvc/priv_distro/libs/camlib Counter5.bsv -g mkModule1 -vnl=mkModule1.v -conerefine=disable
Vector.Vector +++ defined more than once error [L8980]. TODO a spurious errror ? <old definition>
yosys -p 'synth_ice40 -top counter5_top -json counter5_top.json' mkModule1.v counter5_top.v 

 /----------------------------------------------------------------------------\
 |                                                                            |
 |  yosys -- Yosys Open SYnthesis Suite                                       |
 |                                                                            |
 |  Copyright (C) 2012 - 2019  Clifford Wolf <clifford@clifford.at>           |
 |                                                                            |
 |  Permission to use, copy, modify, and/or distribute this software for any  |
 |  purpose with or without fee is hereby granted, provided that the above    |
 |  copyright notice and this permission notice appear in all copies.         |
 |                                                                            |
 |  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  |
 |  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF          |
 |  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR   |
 |  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES    |
 |  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN     |
 |  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF   |
 |  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.            |
 |                                                                            |
 \----------------------------------------------------------------------------/

 Yosys 0.9+431 (git sha1 36df37a7, clang 6.0.1-10 -fPIC -Os)


-- Parsing `mkModule1.v' using frontend `verilog' --

1. Executing Verilog-2005 frontend: mkModule1.v
Parsing Verilog input from `mkModule1.v' to AST representation.
Generating RTLIL representation for module `\mkModule1'.
Successfully finished Verilog frontend.

-- Parsing `counter5_top.v' using frontend `verilog' --

2. Executing Verilog-2005 frontend: counter5_top.v
Parsing Verilog input from `counter5_top.v' to AST representation.
Generating RTLIL representation for module `\counter5_top'.
counter5_top.v:12: Warning: Identifier `\clk' is implicitly declared.
Successfully finished Verilog frontend.

-- Running command `synth_ice40 -top counter5_top -json counter5_top.json' --

3. Executing SYNTH_ICE40 pass.

3.1. Executing Verilog-2005 frontend: /usr/local/bin/../share/yosys/ice40/cells_sim.v
Parsing Verilog input from `/usr/local/bin/../share/yosys/ice40/cells_sim.v' to AST representation.
Generating RTLIL representation for module `\SB_IO'.
Generating RTLIL representation for module `\SB_GB_IO'.
Generating RTLIL representation for module `\SB_GB'.
Generating RTLIL representation for module `\SB_LUT4'.
Generating RTLIL representation for module `\SB_CARRY'.
Generating RTLIL representation for module `$__ICE40_CARRY_WRAPPER'.
Generating RTLIL representation for module `\SB_DFF'.
Generating RTLIL representation for module `\SB_DFFE'.
Generating RTLIL representation for module `\SB_DFFSR'.
Generating RTLIL representation for module `\SB_DFFR'.
Generating RTLIL representation for module `\SB_DFFSS'.
Generating RTLIL representation for module `\SB_DFFS'.
Generating RTLIL representation for module `\SB_DFFESR'.
Generating RTLIL representation for module `\SB_DFFER'.
Generating RTLIL representation for module `\SB_DFFESS'.
Generating RTLIL representation for module `\SB_DFFES'.
Generating RTLIL representation for module `\SB_DFFN'.
Generating RTLIL representation for module `\SB_DFFNE'.
Generating RTLIL representation for module `\SB_DFFNSR'.
Generating RTLIL representation for module `\SB_DFFNR'.
Generating RTLIL representation for module `\SB_DFFNSS'.
Generating RTLIL representation for module `\SB_DFFNS'.
Generating RTLIL representation for module `\SB_DFFNESR'.
Generating RTLIL representation for module `\SB_DFFNER'.
Generating RTLIL representation for module `\SB_DFFNESS'.
Generating RTLIL representation for module `\SB_DFFNES'.
Generating RTLIL representation for module `\SB_RAM40_4K'.
Generating RTLIL representation for module `\SB_RAM40_4KNR'.
Generating RTLIL representation for module `\SB_RAM40_4KNW'.
Generating RTLIL representation for module `\SB_RAM40_4KNRNW'.
Generating RTLIL representation for module `\ICESTORM_LC'.
Generating RTLIL representation for module `\SB_PLL40_CORE'.
Generating RTLIL representation for module `\SB_PLL40_PAD'.
Generating RTLIL representation for module `\SB_PLL40_2_PAD'.
Generating RTLIL representation for module `\SB_PLL40_2F_CORE'.
Generating RTLIL representation for module `\SB_PLL40_2F_PAD'.
Generating RTLIL representation for module `\SB_WARMBOOT'.
Generating RTLIL representation for module `\SB_SPRAM256KA'.
Generating RTLIL representation for module `\SB_HFOSC'.
Generating RTLIL representation for module `\SB_LFOSC'.
Generating RTLIL representation for module `\SB_RGBA_DRV'.
Generating RTLIL representation for module `\SB_LED_DRV_CUR'.
Generating RTLIL representation for module `\SB_RGB_DRV'.
Generating RTLIL representation for module `\SB_I2C'.
Generating RTLIL representation for module `\SB_SPI'.
Generating RTLIL representation for module `\SB_LEDDA_IP'.
Generating RTLIL representation for module `\SB_FILTER_50NS'.
Generating RTLIL representation for module `\SB_IO_I3C'.
Generating RTLIL representation for module `\SB_IO_OD'.
Generating RTLIL representation for module `\SB_MAC16'.
Successfully finished Verilog frontend.

3.2. Executing HIERARCHY pass (managing design hierarchy).

3.2.1. Analyzing design hierarchy..
Top module:  \counter5_top
Used module:     \mkModule1

3.2.2. Analyzing design hierarchy..
Top module:  \counter5_top
Used module:     \mkModule1
Removed 0 unused modules.

3.3. Executing PROC pass (convert processes to netlists).

3.3.1. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

3.3.2. Executing PROC_RMDEAD pass (remove dead branches from decision trees).
Marked 1 switch rules as full_case in process $proc$mkModule1.v:34$2 in module mkModule1.
Removed a total of 0 dead cases.

3.3.3. Executing PROC_PRUNE pass (remove redundant assignments in processes).
Removed 0 redundant assignments.
Promoted 8 assignments to connections.

3.3.4. Executing PROC_INIT pass (extract init attributes).
Found init rule in `\counter5_top.$proc$counter5_top.v:20$13'.
  Set init value: \slowdown = 23'00000000000000000000000

3.3.5. Executing PROC_ARST pass (detect async resets in processes).

3.3.6. Executing PROC_MUX pass (convert decision trees to multiplexers).
Creating decoders for process `\counter5_top.$proc$counter5_top.v:20$13'.
Creating decoders for process `\counter5_top.$proc$counter5_top.v:22$11'.
Creating decoders for process `\mkModule1.$proc$mkModule1.v:52$10'.
Creating decoders for process `\mkModule1.$proc$mkModule1.v:50$6'.
Creating decoders for process `\mkModule1.$proc$mkModule1.v:48$5'.
Creating decoders for process `\mkModule1.$proc$mkModule1.v:46$4'.
Creating decoders for process `\mkModule1.$proc$mkModule1.v:34$2'.
     1/1: $0\counterReg_read[4:0]

3.3.7. Executing PROC_DLATCH pass (convert process syncs to latches).
No latch inferred for signal `\mkModule1.\count_value' from process `\mkModule1.$proc$mkModule1.v:52$10'.
No latch inferred for signal `\mkModule1.\counterReg_write_din' from process `\mkModule1.$proc$mkModule1.v:50$6'.
No latch inferred for signal `\mkModule1.$func$\rtl_unsigned_bitextract0$mkModule1.v:50$1$\rtl_unsigned_bitextract0' from process `\mkModule1.$proc$mkModule1.v:50$6'.
No latch inferred for signal `\mkModule1.$func$\rtl_unsigned_bitextract0$mkModule1.v:50$1$\arg' from process `\mkModule1.$proc$mkModule1.v:50$6'.
No latch inferred for signal `\mkModule1.\EN_counterReg_write' from process `\mkModule1.$proc$mkModule1.v:48$5'.
No latch inferred for signal `\mkModule1.\mkModule1_incrementAndOutput_FIRE' from process `\mkModule1.$proc$mkModule1.v:46$4'.

3.3.8. Executing PROC_DFF pass (convert process syncs to FFs).
Creating register for signal `\counter5_top.\slowdown' using process `\counter5_top.$proc$counter5_top.v:22$11'.
  created $dff cell `$procdff$27' with positive edge clock.
Creating register for signal `\mkModule1.\counterReg_read' using process `\mkModule1.$proc$mkModule1.v:34$2'.
  created $dff cell `$procdff$28' with positive edge clock.

3.3.9. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Removing empty process `counter5_top.$proc$counter5_top.v:20$13'.
Removing empty process `counter5_top.$proc$counter5_top.v:22$11'.
Removing empty process `mkModule1.$proc$mkModule1.v:52$10'.
Removing empty process `mkModule1.$proc$mkModule1.v:50$6'.
Removing empty process `mkModule1.$proc$mkModule1.v:48$5'.
Removing empty process `mkModule1.$proc$mkModule1.v:46$4'.
Found and cleaned up 2 empty switches in `\mkModule1.$proc$mkModule1.v:34$2'.
Removing empty process `mkModule1.$proc$mkModule1.v:34$2'.
Cleaned up 2 empty switches.

3.4. Executing FLATTEN pass (flatten design).
Using template mkModule1 for cells of type mkModule1.
<suppressed ~1 debug messages>
No more expansions possible.
Deleting now unused module mkModule1.

3.5. Executing TRIBUF pass.

3.6. Executing DEMINOUT pass (demote inout ports to input or output).

3.7. Executing OPT_EXPR pass (perform const folding).
Optimizing module counter5_top.
<suppressed ~3 debug messages>

3.8. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \counter5_top..
Removed 0 unused cells and 15 unused wires.
<suppressed ~1 debug messages>

3.9. Executing CHECK pass (checking for obvious problems).
checking module counter5_top..
found and reported 0 problems.

3.10. Executing OPT pass (performing simple optimizations).

3.10.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module counter5_top.

3.10.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\counter5_top'.
Removed a total of 0 cells.

3.10.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \counter5_top..
  Creating internal representation of mux trees.
  No muxes found in this module.
Removed 0 multiplexer ports.

3.10.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \counter5_top.
Performed a total of 0 changes.

3.10.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\counter5_top'.
Removed a total of 0 cells.

3.10.6. Executing OPT_RMDFF pass (remove dff with constant values).

3.10.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \counter5_top..

3.10.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module counter5_top.

3.10.9. Finished OPT passes. (There is nothing left to do.)

3.11. Executing WREDUCE pass (reducing word size of cells).
Removed top 31 bits (of 32) from port B of cell counter5_top.$add$counter5_top.v:23$12 ($add).
Removed top 9 bits (of 32) from port Y of cell counter5_top.$add$counter5_top.v:23$12 ($add).
Removed top 4 bits (of 5) from port A of cell counter5_top.$techmap\COUNTER.$add$mkModule1.v:50$9 ($add).
Removed top 27 bits (of 32) from port Y of cell counter5_top.$techmap\COUNTER.$add$mkModule1.v:50$9 ($add).

3.12. Executing PEEPOPT pass (run peephole optimizers).

3.13. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \counter5_top..
Removed 0 unused cells and 2 unused wires.
<suppressed ~1 debug messages>

3.14. Executing SHARE pass (SAT-based resource sharing).

3.15. Executing TECHMAP pass (map to technology primitives).

3.15.1. Executing Verilog-2005 frontend: /usr/local/bin/../share/yosys/cmp2lut.v
Parsing Verilog input from `/usr/local/bin/../share/yosys/cmp2lut.v' to AST representation.
Generating RTLIL representation for module `\_90_lut_cmp_'.
Successfully finished Verilog frontend.

3.15.2. Continuing TECHMAP pass.
No more expansions possible.

3.16. Executing OPT_EXPR pass (perform const folding).
Optimizing module counter5_top.

3.17. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \counter5_top..

3.18. Executing ALUMACC pass (create $alu and $macc cells).
Extracting $alu and $macc cells in module counter5_top:
  creating $macc model for $add$counter5_top.v:23$12 ($add).
  creating $macc model for $techmap\COUNTER.$add$mkModule1.v:50$9 ($add).
  creating $alu model for $macc $techmap\COUNTER.$add$mkModule1.v:50$9.
  creating $alu model for $macc $add$counter5_top.v:23$12.
  creating $alu cell for $add$counter5_top.v:23$12: $auto$alumacc.cc:485:replace_alu$29
  creating $alu cell for $techmap\COUNTER.$add$mkModule1.v:50$9: $auto$alumacc.cc:485:replace_alu$32
  created 2 $alu and 0 $macc cells.

3.19. Executing OPT pass (performing simple optimizations).

3.19.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module counter5_top.

3.19.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\counter5_top'.
Removed a total of 0 cells.

3.19.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \counter5_top..
  Creating internal representation of mux trees.
  No muxes found in this module.
Removed 0 multiplexer ports.

3.19.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \counter5_top.
Performed a total of 0 changes.

3.19.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\counter5_top'.
Removed a total of 0 cells.

3.19.6. Executing OPT_RMDFF pass (remove dff with constant values).

3.19.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \counter5_top..

3.19.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module counter5_top.

3.19.9. Finished OPT passes. (There is nothing left to do.)

3.20. Executing FSM pass (extract and optimize FSM).

3.20.1. Executing FSM_DETECT pass (finding FSMs in design).

3.20.2. Executing FSM_EXTRACT pass (extracting FSM from design).

3.20.3. Executing FSM_OPT pass (simple optimizations of FSMs).

3.20.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \counter5_top..

3.20.5. Executing FSM_OPT pass (simple optimizations of FSMs).

3.20.6. Executing FSM_RECODE pass (re-assigning FSM state encoding).

3.20.7. Executing FSM_INFO pass (dumping all available information on FSM cells).

3.20.8. Executing FSM_MAP pass (mapping FSMs to basic logic).

3.21. Executing OPT pass (performing simple optimizations).

3.21.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module counter5_top.

3.21.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\counter5_top'.
Removed a total of 0 cells.

3.21.3. Executing OPT_RMDFF pass (remove dff with constant values).

3.21.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \counter5_top..

3.21.5. Finished fast OPT passes.

3.22. Executing MEMORY pass.

3.22.1. Executing MEMORY_DFF pass (merging $dff cells to $memrd and $memwr).

3.22.2. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \counter5_top..

3.22.3. Executing MEMORY_SHARE pass (consolidating $memrd/$memwr cells).

3.22.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \counter5_top..

3.22.5. Executing MEMORY_COLLECT pass (generating $mem cells).

3.23. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \counter5_top..

3.24. Executing MEMORY_BRAM pass (mapping $mem cells to block memories).

3.25. Executing TECHMAP pass (map to technology primitives).

3.25.1. Executing Verilog-2005 frontend: /usr/local/bin/../share/yosys/ice40/brams_map.v
Parsing Verilog input from `/usr/local/bin/../share/yosys/ice40/brams_map.v' to AST representation.
Generating RTLIL representation for module `\$__ICE40_RAM4K'.
Generating RTLIL representation for module `\$__ICE40_RAM4K_M0'.
Generating RTLIL representation for module `\$__ICE40_RAM4K_M123'.
Successfully finished Verilog frontend.

3.25.2. Continuing TECHMAP pass.
No more expansions possible.

3.26. Executing ICE40_BRAMINIT pass.

3.27. Executing OPT pass (performing simple optimizations).

3.27.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module counter5_top.

3.27.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\counter5_top'.
Removed a total of 0 cells.

3.27.3. Executing OPT_RMDFF pass (remove dff with constant values).

3.27.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \counter5_top..

3.27.5. Finished fast OPT passes.

3.28. Executing MEMORY_MAP pass (converting $mem cells to logic and flip-flops).

3.29. Executing OPT pass (performing simple optimizations).

3.29.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module counter5_top.

3.29.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\counter5_top'.
Removed a total of 0 cells.

3.29.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \counter5_top..
  Creating internal representation of mux trees.
  No muxes found in this module.
Removed 0 multiplexer ports.

3.29.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
  Optimizing cells in module \counter5_top.
Performed a total of 0 changes.

3.29.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\counter5_top'.
Removed a total of 0 cells.

3.29.6. Executing OPT_RMDFF pass (remove dff with constant values).

3.29.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \counter5_top..

3.29.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module counter5_top.

3.29.9. Finished OPT passes. (There is nothing left to do.)

3.30. Executing ICE40_WRAPCARRY pass (wrap carries).

3.31. Executing TECHMAP pass (map to technology primitives).

3.31.1. Executing Verilog-2005 frontend: /usr/local/bin/../share/yosys/techmap.v
Parsing Verilog input from `/usr/local/bin/../share/yosys/techmap.v' to AST representation.
Generating RTLIL representation for module `\_90_simplemap_bool_ops'.
Generating RTLIL representation for module `\_90_simplemap_reduce_ops'.
Generating RTLIL representation for module `\_90_simplemap_logic_ops'.
Generating RTLIL representation for module `\_90_simplemap_compare_ops'.
Generating RTLIL representation for module `\_90_simplemap_various'.
Generating RTLIL representation for module `\_90_simplemap_registers'.
Generating RTLIL representation for module `\_90_shift_ops_shr_shl_sshl_sshr'.
Generating RTLIL representation for module `\_90_shift_shiftx'.
Generating RTLIL representation for module `\_90_fa'.
Generating RTLIL representation for module `\_90_lcu'.
Generating RTLIL representation for module `\_90_alu'.
Generating RTLIL representation for module `\_90_macc'.
Generating RTLIL representation for module `\_90_alumacc'.
Generating RTLIL representation for module `\$__div_mod_u'.
Generating RTLIL representation for module `\$__div_mod'.
Generating RTLIL representation for module `\_90_div'.
Generating RTLIL representation for module `\_90_mod'.
Generating RTLIL representation for module `\_90_pow'.
Generating RTLIL representation for module `\_90_pmux'.
Generating RTLIL representation for module `\_90_lut'.
Successfully finished Verilog frontend.

3.31.2. Executing Verilog-2005 frontend: /usr/local/bin/../share/yosys/ice40/arith_map.v
Parsing Verilog input from `/usr/local/bin/../share/yosys/ice40/arith_map.v' to AST representation.
Generating RTLIL representation for module `\_80_ice40_alu'.
Successfully finished Verilog frontend.

3.31.3. Continuing TECHMAP pass.
Using template $paramod\_80_ice40_alu\A_SIGNED=0\B_SIGNED=0\A_WIDTH=1\B_WIDTH=5\Y_WIDTH=5 for cells of type $alu.
Using extmapper simplemap for cells of type $dff.
Using template $paramod\_80_ice40_alu\A_SIGNED=0\B_SIGNED=0\A_WIDTH=1\B_WIDTH=23\Y_WIDTH=23 for cells of type $alu.
Using extmapper simplemap for cells of type $xor.
Using extmapper simplemap for cells of type $mux.
Using extmapper simplemap for cells of type $not.
Using extmapper simplemap for cells of type $pos.
No more expansions possible.
<suppressed ~42 debug messages>

3.32. Executing ICE40_OPT pass (performing simple optimizations).

3.32.1. Running ICE40 specific optimizations.

3.32.2. Executing OPT_EXPR pass (perform const folding).
Optimizing module counter5_top.
<suppressed ~54 debug messages>

3.32.3. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\counter5_top'.
Removed a total of 0 cells.

3.32.4. Executing OPT_RMDFF pass (remove dff with constant values).

3.32.5. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \counter5_top..
Removed 30 unused cells and 32 unused wires.
<suppressed ~31 debug messages>

3.32.6. Rerunning OPT passes. (Removed registers in this run.)

3.32.7. Running ICE40 specific optimizations.
Optimized $__ICE40_CARRY_WRAPPER cell back to logic (without SB_CARRY) counter5_top.$auto$alumacc.cc:485:replace_alu$29.slice[0].fadd: CO=\slowdown [0]
Optimized $__ICE40_CARRY_WRAPPER cell back to logic (without SB_CARRY) counter5_top.$auto$alumacc.cc:485:replace_alu$32.slice[0].fadd: CO=\COUNTER.counterReg_read [0]

3.32.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module counter5_top.

3.32.9. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\counter5_top'.
Removed a total of 0 cells.

3.32.10. Executing OPT_RMDFF pass (remove dff with constant values).

3.32.11. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \counter5_top..

3.32.12. Rerunning OPT passes. (Removed registers in this run.)

3.32.13. Running ICE40 specific optimizations.

3.32.14. Executing OPT_EXPR pass (perform const folding).
Optimizing module counter5_top.

3.32.15. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\counter5_top'.
Removed a total of 0 cells.

3.32.16. Executing OPT_RMDFF pass (remove dff with constant values).

3.32.17. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \counter5_top..

3.32.18. Finished OPT passes. (There is nothing left to do.)

3.33. Executing DFFSR2DFF pass (mapping DFFSR cells to simpler FFs).

3.34. Executing DFF2DFFE pass (transform $dff to $dffe where applicable).
Selected cell types for direct conversion:
  $_DFF_PP1_ -> $__DFFE_PP1
  $_DFF_PP0_ -> $__DFFE_PP0
  $_DFF_PN1_ -> $__DFFE_PN1
  $_DFF_PN0_ -> $__DFFE_PN0
  $_DFF_NP1_ -> $__DFFE_NP1
  $_DFF_NP0_ -> $__DFFE_NP0
  $_DFF_NN1_ -> $__DFFE_NN1
  $_DFF_NN0_ -> $__DFFE_NN0
  $_DFF_N_ -> $_DFFE_NP_
  $_DFF_P_ -> $_DFFE_PP_
Transforming FF to FF+Enable cells in module counter5_top:

3.35. Executing TECHMAP pass (map to technology primitives).

3.35.1. Executing Verilog-2005 frontend: /usr/local/bin/../share/yosys/ice40/cells_map.v
Parsing Verilog input from `/usr/local/bin/../share/yosys/ice40/cells_map.v' to AST representation.
Generating RTLIL representation for module `\$_DFF_N_'.
Generating RTLIL representation for module `\$_DFF_P_'.
Generating RTLIL representation for module `\$_DFFE_NN_'.
Generating RTLIL representation for module `\$_DFFE_PN_'.
Generating RTLIL representation for module `\$_DFFE_NP_'.
Generating RTLIL representation for module `\$_DFFE_PP_'.
Generating RTLIL representation for module `\$_DFF_NN0_'.
Generating RTLIL representation for module `\$_DFF_NN1_'.
Generating RTLIL representation for module `\$_DFF_PN0_'.
Generating RTLIL representation for module `\$_DFF_PN1_'.
Generating RTLIL representation for module `\$_DFF_NP0_'.
Generating RTLIL representation for module `\$_DFF_NP1_'.
Generating RTLIL representation for module `\$_DFF_PP0_'.
Generating RTLIL representation for module `\$_DFF_PP1_'.
Generating RTLIL representation for module `\$__DFFE_NN0'.
Generating RTLIL representation for module `\$__DFFE_NN1'.
Generating RTLIL representation for module `\$__DFFE_PN0'.
Generating RTLIL representation for module `\$__DFFE_PN1'.
Generating RTLIL representation for module `\$__DFFE_NP0'.
Generating RTLIL representation for module `\$__DFFE_NP1'.
Generating RTLIL representation for module `\$__DFFE_PP0'.
Generating RTLIL representation for module `\$__DFFE_PP1'.
Successfully finished Verilog frontend.

3.35.2. Continuing TECHMAP pass.
Using template \$_DFF_P_ for cells of type $_DFF_P_.
No more expansions possible.
<suppressed ~28 debug messages>

3.36. Executing OPT_EXPR pass (perform const folding).
Optimizing module counter5_top.

3.37. Executing SIMPLEMAP pass (map simple cells to gate primitives).
Mapping counter5_top.$auto$alumacc.cc:485:replace_alu$32.slice[0].fadd ($lut).
Mapping counter5_top.$auto$alumacc.cc:485:replace_alu$29.slice[0].fadd ($lut).

3.38. Executing ICE40_FFINIT pass (implement FF init values).
Handling FF init values in counter5_top.
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$99 (SB_DFF): \slowdown [11] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$100 (SB_DFF): \slowdown [12] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$101 (SB_DFF): \slowdown [13] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$102 (SB_DFF): \slowdown [14] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$103 (SB_DFF): \slowdown [15] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$104 (SB_DFF): \slowdown [16] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$105 (SB_DFF): \slowdown [17] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$106 (SB_DFF): \slowdown [18] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$107 (SB_DFF): \slowdown [19] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$108 (SB_DFF): \slowdown [20] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$109 (SB_DFF): \slowdown [21] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$110 (SB_DFF): \slowdown [22] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$95 (SB_DFF): \slowdown [7] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$88 (SB_DFF): \slowdown [0] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$89 (SB_DFF): \slowdown [1] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$90 (SB_DFF): \slowdown [2] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$91 (SB_DFF): \slowdown [3] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$92 (SB_DFF): \slowdown [4] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$93 (SB_DFF): \slowdown [5] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$94 (SB_DFF): \slowdown [6] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$96 (SB_DFF): \slowdown [8] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$97 (SB_DFF): \slowdown [9] = 0
FF init value for cell $auto$simplemap.cc:420:simplemap_dff$98 (SB_DFF): \slowdown [10] = 0

3.39. Executing ICE40_FFSSR pass (merge synchronous set/reset into FF cells).
Merging set/reset $_MUX_ cells into SB_FFs in counter5_top.

3.40. Executing ICE40_OPT pass (performing simple optimizations).

3.40.1. Running ICE40 specific optimizations.

3.40.2. Executing OPT_EXPR pass (perform const folding).
Optimizing module counter5_top.
<suppressed ~26 debug messages>

3.40.3. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\counter5_top'.
<suppressed ~6 debug messages>
Removed a total of 2 cells.

3.40.4. Executing OPT_RMDFF pass (remove dff with constant values).

3.40.5. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \counter5_top..
Removed 0 unused cells and 92 unused wires.
<suppressed ~1 debug messages>

3.40.6. Rerunning OPT passes. (Removed registers in this run.)

3.40.7. Running ICE40 specific optimizations.

3.40.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module counter5_top.

3.40.9. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\counter5_top'.
Removed a total of 0 cells.

3.40.10. Executing OPT_RMDFF pass (remove dff with constant values).

3.40.11. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \counter5_top..

3.40.12. Finished OPT passes. (There is nothing left to do.)

3.41. Executing TECHMAP pass (map to technology primitives).

3.41.1. Executing Verilog-2005 frontend: /usr/local/bin/../share/yosys/ice40/latches_map.v
Parsing Verilog input from `/usr/local/bin/../share/yosys/ice40/latches_map.v' to AST representation.
Generating RTLIL representation for module `\$_DLATCH_N_'.
Generating RTLIL representation for module `\$_DLATCH_P_'.
Successfully finished Verilog frontend.

3.41.2. Continuing TECHMAP pass.
No more expansions possible.

3.42. Executing ABC pass (technology mapping using ABC).

3.42.1. Extracting gate netlist of module `\counter5_top' to `<abc-temp-dir>/input.blif'..
Extracted 2 gates and 4 wires to a netlist network with 2 inputs and 2 outputs.

3.42.1.1. Executing ABC.
Running ABC command: <yosys-exe-dir>/yosys-abc -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC: 
ABC: + read_blif <abc-temp-dir>/input.blif 
ABC: + read_lut <abc-temp-dir>/lutdefs.txt 
ABC: + strash 
ABC: + ifraig 
ABC: + scorr 
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + dc2 
ABC: + dretime 
ABC: + retime 
ABC: + strash 
ABC: + dch -f 
ABC: + if 
ABC: + mfs2 
ABC: + lutpack -S 1 
ABC: + dress 
ABC: Total number of equiv classes                =       3.
ABC: Participating nodes from both networks       =       4.
ABC: Participating nodes from the first network   =       2. (  66.67 % of nodes)
ABC: Participating nodes from the second network  =       2. (  66.67 % of nodes)
ABC: Node pairs (any polarity)                    =       2. (  66.67 % of names can be moved)
ABC: Node pairs (same polarity)                   =       2. (  66.67 % of names can be moved)
ABC: Total runtime =     0.00 sec
ABC: + write_blif <abc-temp-dir>/output.blif 

3.42.1.2. Re-integrating ABC results.
ABC RESULTS:              $lut cells:        2
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:        2
ABC RESULTS:          output signals:        2
Removing temp directory.

3.43. Executing TECHMAP pass (map to technology primitives).

3.43.1. Executing Verilog-2005 frontend: /usr/local/bin/../share/yosys/ice40/cells_map.v
Parsing Verilog input from `/usr/local/bin/../share/yosys/ice40/cells_map.v' to AST representation.
Generating RTLIL representation for module `\$_DFF_N_'.
Generating RTLIL representation for module `\$_DFF_P_'.
Generating RTLIL representation for module `\$_DFFE_NN_'.
Generating RTLIL representation for module `\$_DFFE_PN_'.
Generating RTLIL representation for module `\$_DFFE_NP_'.
Generating RTLIL representation for module `\$_DFFE_PP_'.
Generating RTLIL representation for module `\$_DFF_NN0_'.
Generating RTLIL representation for module `\$_DFF_NN1_'.
Generating RTLIL representation for module `\$_DFF_PN0_'.
Generating RTLIL representation for module `\$_DFF_PN1_'.
Generating RTLIL representation for module `\$_DFF_NP0_'.
Generating RTLIL representation for module `\$_DFF_NP1_'.
Generating RTLIL representation for module `\$_DFF_PP0_'.
Generating RTLIL representation for module `\$_DFF_PP1_'.
Generating RTLIL representation for module `\$__DFFE_NN0'.
Generating RTLIL representation for module `\$__DFFE_NN1'.
Generating RTLIL representation for module `\$__DFFE_PN0'.
Generating RTLIL representation for module `\$__DFFE_PN1'.
Generating RTLIL representation for module `\$__DFFE_NP0'.
Generating RTLIL representation for module `\$__DFFE_NP1'.
Generating RTLIL representation for module `\$__DFFE_PP0'.
Generating RTLIL representation for module `\$__DFFE_PP1'.
Generating RTLIL representation for module `\$__ICE40_CARRY_WRAPPER'.
Successfully finished Verilog frontend.

3.43.2. Continuing TECHMAP pass.
Using template $paramod\$__ICE40_CARRY_WRAPPER\LUT=16'0110100110010110 for cells of type $__ICE40_CARRY_WRAPPER.
No more expansions possible.
<suppressed ~36 debug messages>
Removed 2 unused cells and 188 unused wires.

3.44. Executing OPT_LUT pass (optimize LUTs).
Discovering LUTs.
Number of LUTs:       28
  1-LUT                2
  2-LUT                2
  3-LUT               24
  with \SB_CARRY      24

Eliminating LUTs.
Number of LUTs:       28
  1-LUT                2
  2-LUT                2
  3-LUT               24
  with \SB_CARRY      24

Combining LUTs.
Number of LUTs:       28
  1-LUT                2
  2-LUT                2
  3-LUT               24
  with \SB_CARRY      24

Eliminated 0 LUTs.
Combined 0 LUTs.
<suppressed ~84 debug messages>

3.45. Executing TECHMAP pass (map to technology primitives).

3.45.1. Executing Verilog-2005 frontend: /usr/local/bin/../share/yosys/ice40/cells_map.v
Parsing Verilog input from `/usr/local/bin/../share/yosys/ice40/cells_map.v' to AST representation.
Generating RTLIL representation for module `\$_DFF_N_'.
Generating RTLIL representation for module `\$_DFF_P_'.
Generating RTLIL representation for module `\$_DFFE_NN_'.
Generating RTLIL representation for module `\$_DFFE_PN_'.
Generating RTLIL representation for module `\$_DFFE_NP_'.
Generating RTLIL representation for module `\$_DFFE_PP_'.
Generating RTLIL representation for module `\$_DFF_NN0_'.
Generating RTLIL representation for module `\$_DFF_NN1_'.
Generating RTLIL representation for module `\$_DFF_PN0_'.
Generating RTLIL representation for module `\$_DFF_PN1_'.
Generating RTLIL representation for module `\$_DFF_NP0_'.
Generating RTLIL representation for module `\$_DFF_NP1_'.
Generating RTLIL representation for module `\$_DFF_PP0_'.
Generating RTLIL representation for module `\$_DFF_PP1_'.
Generating RTLIL representation for module `\$__DFFE_NN0'.
Generating RTLIL representation for module `\$__DFFE_NN1'.
Generating RTLIL representation for module `\$__DFFE_PN0'.
Generating RTLIL representation for module `\$__DFFE_PN1'.
Generating RTLIL representation for module `\$__DFFE_NP0'.
Generating RTLIL representation for module `\$__DFFE_NP1'.
Generating RTLIL representation for module `\$__DFFE_PP0'.
Generating RTLIL representation for module `\$__DFFE_PP1'.
Generating RTLIL representation for module `\$lut'.
Generating RTLIL representation for module `\$__ICE40_CARRY_WRAPPER'.
Successfully finished Verilog frontend.

3.45.2. Continuing TECHMAP pass.
Using template $paramod\$lut\WIDTH=4\LUT=16'0110100110010110 for cells of type $lut.
Using template $paramod\$lut\WIDTH=1\LUT=2'01 for cells of type $lut.
No more expansions possible.
<suppressed ~50 debug messages>
Removed 0 unused cells and 56 unused wires.

3.46. Executing HIERARCHY pass (managing design hierarchy).

3.46.1. Analyzing design hierarchy..
Top module:  \counter5_top

3.46.2. Analyzing design hierarchy..
Top module:  \counter5_top
Removed 0 unused modules.

3.47. Printing statistics.

=== counter5_top ===

   Number of wires:                 24
   Number of wire bits:            110
   Number of public wires:          21
   Number of public wire bits:      59
   Number of memories:               0
   Number of memory bits:            0
   Number of processes:              0
   Number of cells:                 81
     SB_CARRY                       24
     SB_DFF                         28
     SB_GB                           1
     SB_LUT4                        28

3.48. Executing CHECK pass (checking for obvious problems).
checking module counter5_top..
found and reported 0 problems.

3.49. Executing JSON backend.

Warnings: 1 unique messages, 1 total
End of script. Logfile hash: 9a05d9f763
CPU: user 0.19s system 0.04s, MEM: 75.55 MB total, 47.02 MB resident
Yosys 0.9+431 (git sha1 36df37a7, clang 6.0.1-10 -fPIC -Os)
Time spent: 49% 12x read_verilog (0 sec), 11% 1x share (0 sec), ...
nextpnr-ice40 --hx1k --json counter5_top.json --pcf counter5_top.pcf --asc counter5_top.asc 
Warning: Use of default value for --package is deprecated. Please add '--package tq144' to arguments.
Info: Importing module counter5_top
Info: Rule checker, verifying imported design
Info: Checksum: 0xef5e31c4

Info: constrained 'led1' to bel 'X13/Y12/io1'
Info: constrained 'led2' to bel 'X13/Y12/io0'
Info: constrained 'led3' to bel 'X13/Y11/io1'
Info: constrained 'led4' to bel 'X13/Y11/io0'
Info: constrained 'led5' to bel 'X13/Y9/io1'
Info: constrained 'clki' to bel 'X0/Y8/io1'

Info: Packing constants..
Info: Packing IOs..
Info: Packing LUT-FFs..
Info:        0 LCs used as LUT4 only
Info:       28 LCs used as LUT4 and DFF
Info: Packing non-LUT FFs..
Info:        0 LCs used as DFF only
Info: Packing carries..
Info:        2 LCs used as CARRY only
Info: Packing RAMs..
Info: Placing PLLs..
Info: Packing special functions..
Info: Promoting globals..
Info: promoting slowdown[22] (fanout 5)
Info: Constraining chains...
Info:        2 LCs used to legalise carry chains.
Info: Checksum: 0x714982d6

Info: Annotating ports with timing budgets for target frequency 12.00 MHz
Info: Checksum: 0x0a272475

Info: Device utilisation:
Info: 	         ICESTORM_LC:    34/ 1280     2%
Info: 	        ICESTORM_RAM:     0/   16     0%
Info: 	               SB_IO:     6/  112     5%
Info: 	               SB_GB:     2/    8    25%
Info: 	        ICESTORM_PLL:     0/    1     0%
Info: 	         SB_WARMBOOT:     0/    1     0%

Info: Placed 6 cells based on constraints.
Info: Creating initial placement for remaining 36 cells.
Info:   initial placement placed 36/36 cells
Info: Initial placement time 0.00s
Info: Running simulated annealing placer.
Info:   at iteration #1: temp = 1.000000, timing cost = 10, wirelen = 313
Info:   at iteration #5: temp = 0.656100, timing cost = 14, wirelen = 383
Info:   at iteration #10: temp = 0.454382, timing cost = 11, wirelen = 302
Info:   at iteration #15: temp = 0.370097, timing cost = 15, wirelen = 307
Info:   at iteration #20: temp = 0.317312, timing cost = 12, wirelen = 262
Info:   at iteration #25: temp = 0.301446, timing cost = 13, wirelen = 238
Info:   at iteration #30: temp = 0.272055, timing cost = 10, wirelen = 199
Info:   at iteration #35: temp = 0.245530, timing cost = 10, wirelen = 160
Info:   at iteration #40: temp = 0.245530, timing cost = 11, wirelen = 138
Info:   at iteration #45: temp = 0.210511, timing cost = 11, wirelen = 155
Info:   at iteration #50: temp = 0.199986, timing cost = 10, wirelen = 145
Info: Legalising relative constraints...
Info:     moved 26 cells, 1 unplaced (after legalising chains)
Info:        average distance 1.111266
Info:        maximum distance 2.236068
Info:     moved 27 cells, 0 unplaced (after replacing ripped up cells)
Info:        average distance 1.292330
Info:        maximum distance 6.000000
Info:   at iteration #55: temp = 0.162438, timing cost = 9, wirelen = 124
Info:   at iteration #60: temp = 0.146195, timing cost = 6, wirelen = 74
Info:   at iteration #65: temp = 0.118418, timing cost = 6, wirelen = 69
Info:   at iteration #70: temp = 0.101528, timing cost = 6, wirelen = 81
Info:   at iteration #75: temp = 0.087048, timing cost = 6, wirelen = 52
Info:   at iteration #80: temp = 0.078561, timing cost = 6, wirelen = 57
Info:   at iteration #85: temp = 0.060789, timing cost = 6, wirelen = 64
Info:   at iteration #90: temp = 0.047037, timing cost = 4, wirelen = 51
Info:   at iteration #95: temp = 0.047037, timing cost = 4, wirelen = 32
Info:   at iteration #100: temp = 0.038312, timing cost = 4, wirelen = 33
Info:   at iteration #105: temp = 0.038312, timing cost = 3, wirelen = 26
Info:   at iteration #110: temp = 0.036396, timing cost = 4, wirelen = 25
Info:   at iteration #115: temp = 0.031205, timing cost = 4, wirelen = 24
Info:   at iteration #120: temp = 0.026755, timing cost = 4, wirelen = 22
Info:   at iteration #125: temp = 0.020702, timing cost = 4, wirelen = 21
Info:   at iteration #130: temp = 0.016862, timing cost = 3, wirelen = 24
Info:   at iteration #135: temp = 0.013048, timing cost = 3, wirelen = 19
Info:   at iteration #140: temp = 0.010096, timing cost = 3, wirelen = 20
Info:   at iteration #145: temp = 0.007812, timing cost = 3, wirelen = 20
Info:   at iteration #150: temp = 0.006045, timing cost = 3, wirelen = 20
Info:   at iteration #155: temp = 0.004677, timing cost = 3, wirelen = 20
Info:   at iteration #160: temp = 0.003619, timing cost = 3, wirelen = 19
Info:   at iteration #165: temp = 0.002801, timing cost = 3, wirelen = 19
Info:   at iteration #170: temp = 0.002167, timing cost = 3, wirelen = 19
Info:   at iteration #175: temp = 0.001677, timing cost = 3, wirelen = 19
Info:   at iteration #180: temp = 0.001297, timing cost = 3, wirelen = 19
Info:   at iteration #185: temp = 0.001004, timing cost = 3, wirelen = 19
Info:   at iteration #190: temp = 0.000777, timing cost = 3, wirelen = 19
Info:   at iteration #195: temp = 0.000601, timing cost = 3, wirelen = 19
Info:   at iteration #200: temp = 0.000465, timing cost = 3, wirelen = 19
Info:   at iteration #205: temp = 0.000360, timing cost = 3, wirelen = 19
Info:   at iteration #210: temp = 0.000278, timing cost = 3, wirelen = 19
Info:   at iteration #215: temp = 0.000215, timing cost = 3, wirelen = 19
Info:   at iteration #220: temp = 0.000167, timing cost = 3, wirelen = 19
Info:   at iteration #225: temp = 0.000129, timing cost = 3, wirelen = 19
Info:   at iteration #230: temp = 0.000100, timing cost = 3, wirelen = 19
Info:   at iteration #235: temp = 0.000077, timing cost = 3, wirelen = 19
Info:   at iteration #240: temp = 0.000060, timing cost = 3, wirelen = 19
Info:   at iteration #245: temp = 0.000046, timing cost = 3, wirelen = 19
Info:   at iteration #250: temp = 0.000036, timing cost = 3, wirelen = 19
Info:   at iteration #255: temp = 0.000028, timing cost = 3, wirelen = 19
Info:   at iteration #260: temp = 0.000021, timing cost = 3, wirelen = 19
Info:   at iteration #265: temp = 0.000017, timing cost = 3, wirelen = 19
Info:   at iteration #270: temp = 0.000013, timing cost = 3, wirelen = 19
Info:   at iteration #275: temp = 0.000010, timing cost = 3, wirelen = 19
Info:   at iteration #280: temp = 0.000008, timing cost = 3, wirelen = 19
Info:   at iteration #285: temp = 0.000006, timing cost = 3, wirelen = 19
Info:   at iteration #290: temp = 0.000005, timing cost = 3, wirelen = 19
Info:   at iteration #295: temp = 0.000004, timing cost = 3, wirelen = 19
Info:   at iteration #300: temp = 0.000003, timing cost = 3, wirelen = 19
Info:   at iteration #305: temp = 0.000002, timing cost = 3, wirelen = 19
Info:   at iteration #310: temp = 0.000002, timing cost = 3, wirelen = 19
Info:   at iteration #315: temp = 0.000001, timing cost = 3, wirelen = 19
Info:   at iteration #320: temp = 0.000001, timing cost = 3, wirelen = 19
Info:   at iteration #325: temp = 0.000001, timing cost = 3, wirelen = 19
Info:   at iteration #330: temp = 0.000001, timing cost = 3, wirelen = 19
Info:   at iteration #335: temp = 0.000000, timing cost = 3, wirelen = 19
Info:   at iteration #340: temp = 0.000000, timing cost = 3, wirelen = 19
Info:   at iteration #345: temp = 0.000000, timing cost = 3, wirelen = 19
Info:   at iteration #350: temp = 0.000000, timing cost = 3, wirelen = 19
Info:   at iteration #355: temp = 0.000000, timing cost = 3, wirelen = 19
Info:   at iteration #360: temp = 0.000000, timing cost = 3, wirelen = 19
Info:   at iteration #365: temp = 0.000000, timing cost = 3, wirelen = 19
Info:   at iteration #365: temp = 0.000000, timing cost = 3, wirelen = 19 
Info: SA placement time 0.21s

Info: Max frequency for clock                   'clk': 195.01 MHz (PASS at 12.00 MHz)
Info: Max frequency for clock 'slowdown[22]_$glb_clk': 423.73 MHz (PASS at 12.00 MHz)

Info: Max delay posedge slowdown[22]_$glb_clk -> <async>: 1.75 ns

Info: Slack histogram:
Info:  legend: * represents 1 endpoint(s)
Info:          + represents [1,1) endpoint(s)
Info: [ 78205,  78406) |** 
Info: [ 78406,  78607) |** 
Info: [ 78607,  78808) |* 
Info: [ 78808,  79009) |** 
Info: [ 79009,  79210) | 
Info: [ 79210,  79411) |* 
Info: [ 79411,  79612) |** 
Info: [ 79612,  79813) |* 
Info: [ 79813,  80014) |** 
Info: [ 80014,  80215) |** 
Info: [ 80215,  80416) | 
Info: [ 80416,  80617) |* 
Info: [ 80617,  80818) |* 
Info: [ 80818,  81019) |*** 
Info: [ 81019,  81220) |** 
Info: [ 81220,  81421) |** 
Info: [ 81421,  81622) |* 
Info: [ 81622,  81823) |************************** 
Info: [ 81823,  82024) |**** 
Info: [ 82024,  82225) |**** 
Info: Checksum: 0x93ac5bd6

Info: Routing..
Info: Setting up routing queue.
Info: Routing 95 arcs.
Info:            |   (re-)routed arcs  |   delta    | remaining
Info:    IterCnt |  w/ripup   wo/ripup |  w/r  wo/r |      arcs
Info:         95 |        0         95 |    0    95 |         0
Info: Routing complete.
Info: Route time 0.00s
Info: Checksum: 0xbd7d5836

Info: Critical path report for clock 'clk' (posedge -> posedge):
Info: curr total
Info:  0.5  0.5  Source $abc$282$auto$blifparse.cc:492:parse_blif$284_LC.O
Info:  0.6  1.1    Net slowdown[0] budget 72.672997 ns (7,8) -> (7,9)
Info:                Sink $nextpnr_ICESTORM_LC_0.I1
Info:  0.3  1.4  Source $nextpnr_ICESTORM_LC_0.COUT
Info:  0.0  1.4    Net $nextpnr_ICESTORM_LC_0$O budget 0.000000 ns (7,9) -> (7,9)
Info:                Sink $auto$alumacc.cc:485:replace_alu$29.slice[1].fadd.carry$CARRY.CIN
Info:  0.1  1.5  Source $auto$alumacc.cc:485:replace_alu$29.slice[1].fadd.carry$CARRY.COUT
Info:  0.0  1.5    Net $auto$alumacc.cc:485:replace_alu$29.C[2] budget 0.000000 ns (7,9) -> (7,9)
Info:                Sink $auto$alumacc.cc:485:replace_alu$29.slice[2].fadd.lut_LC.CIN
Info:  0.1  1.6  Source $auto$alumacc.cc:485:replace_alu$29.slice[2].fadd.lut_LC.COUT
Info:  0.0  1.6    Net $auto$alumacc.cc:485:replace_alu$29.C[3] budget 0.000000 ns (7,9) -> (7,9)
Info:                Sink $auto$alumacc.cc:485:replace_alu$29.slice[3].fadd.lut_LC.CIN
Info:  0.1  1.8  Source $auto$alumacc.cc:485:replace_alu$29.slice[3].fadd.lut_LC.COUT
Info:  0.0  1.8    Net $auto$alumacc.cc:485:replace_alu$29.C[4] budget 0.000000 ns (7,9) -> (7,9)
Info:                Sink $auto$alumacc.cc:485:replace_alu$29.slice[4].fadd.lut_LC.CIN
Info:  0.1  1.9  Source $auto$alumacc.cc:485:replace_alu$29.slice[4].fadd.lut_LC.COUT
Info:  0.0  1.9    Net $auto$alumacc.cc:485:replace_alu$29.C[5] budget 0.000000 ns (7,9) -> (7,9)
Info:                Sink $auto$alumacc.cc:485:replace_alu$29.slice[5].fadd.lut_LC.CIN
Info:  0.1  2.0  Source $auto$alumacc.cc:485:replace_alu$29.slice[5].fadd.lut_LC.COUT
Info:  0.0  2.0    Net $auto$alumacc.cc:485:replace_alu$29.C[6] budget 0.000000 ns (7,9) -> (7,9)
Info:                Sink $auto$alumacc.cc:485:replace_alu$29.slice[6].fadd.lut_LC.CIN
Info:  0.1  2.1  Source $auto$alumacc.cc:485:replace_alu$29.slice[6].fadd.lut_LC.COUT
Info:  0.0  2.1    Net $auto$alumacc.cc:485:replace_alu$29.C[7] budget 0.000000 ns (7,9) -> (7,9)
Info:                Sink $auto$alumacc.cc:485:replace_alu$29.slice[7].fadd.lut_LC.CIN
Info:  0.1  2.3  Source $auto$alumacc.cc:485:replace_alu$29.slice[7].fadd.lut_LC.COUT
Info:  0.2  2.5    Net $auto$alumacc.cc:485:replace_alu$29.C[8] budget 0.190000 ns (7,9) -> (7,10)
Info:                Sink $auto$alumacc.cc:485:replace_alu$29.slice[8].fadd.lut_LC.CIN
Info:  0.1  2.6  Source $auto$alumacc.cc:485:replace_alu$29.slice[8].fadd.lut_LC.COUT
Info:  0.0  2.6    Net $auto$alumacc.cc:485:replace_alu$29.C[9] budget 0.000000 ns (7,10) -> (7,10)
Info:                Sink $auto$alumacc.cc:485:replace_alu$29.slice[9].fadd.lut_LC.CIN
Info:  0.1  2.7  Source $auto$alumacc.cc:485:replace_alu$29.slice[9].fadd.lut_LC.COUT
Info:  0.0  2.7    Net $auto$alumacc.cc:485:replace_alu$29.C[10] budget 0.000000 ns (7,10) -> (7,10)
Info:                Sink $auto$alumacc.cc:485:replace_alu$29.slice[10].fadd.lut_LC.CIN
Info:  0.1  2.8  Source $auto$alumacc.cc:485:replace_alu$29.slice[10].fadd.lut_LC.COUT
Info:  0.0  2.8    Net $auto$alumacc.cc:485:replace_alu$29.C[11] budget 0.000000 ns (7,10) -> (7,10)
Info:                Sink $auto$alumacc.cc:485:replace_alu$29.slice[11].fadd.lut_LC.CIN
Info:  0.1  3.0  Source $auto$alumacc.cc:485:replace_alu$29.slice[11].fadd.lut_LC.COUT
Info:  0.0  3.0    Net $auto$alumacc.cc:485:replace_alu$29.C[12] budget 0.000000 ns (7,10) -> (7,10)
Info:                Sink $auto$alumacc.cc:485:replace_alu$29.slice[12].fadd.lut_LC.CIN
Info:  0.1  3.1  Source $auto$alumacc.cc:485:replace_alu$29.slice[12].fadd.lut_LC.COUT
Info:  0.0  3.1    Net $auto$alumacc.cc:485:replace_alu$29.C[13] budget 0.000000 ns (7,10) -> (7,10)
Info:                Sink $auto$alumacc.cc:485:replace_alu$29.slice[13].fadd.lut_LC.CIN
Info:  0.1  3.2  Source $auto$alumacc.cc:485:replace_alu$29.slice[13].fadd.lut_LC.COUT
Info:  0.0  3.2    Net $auto$alumacc.cc:485:replace_alu$29.C[14] budget 0.000000 ns (7,10) -> (7,10)
Info:                Sink $auto$alumacc.cc:485:replace_alu$29.slice[14].fadd.lut_LC.CIN
Info:  0.1  3.3  Source $auto$alumacc.cc:485:replace_alu$29.slice[14].fadd.lut_LC.COUT
Info:  0.0  3.3    Net $auto$alumacc.cc:485:replace_alu$29.C[15] budget 0.000000 ns (7,10) -> (7,10)
Info:                Sink $auto$alumacc.cc:485:replace_alu$29.slice[15].fadd.lut_LC.CIN
Info:  0.1  3.5  Source $auto$alumacc.cc:485:replace_alu$29.slice[15].fadd.lut_LC.COUT
Info:  0.2  3.7    Net $auto$alumacc.cc:485:replace_alu$29.C[16] budget 0.190000 ns (7,10) -> (7,11)
Info:                Sink $auto$alumacc.cc:485:replace_alu$29.slice[16].fadd.lut_LC.CIN
Info:  0.1  3.8  Source $auto$alumacc.cc:485:replace_alu$29.slice[16].fadd.lut_LC.COUT
Info:  0.0  3.8    Net $auto$alumacc.cc:485:replace_alu$29.C[17] budget 0.000000 ns (7,11) -> (7,11)
Info:                Sink $auto$alumacc.cc:485:replace_alu$29.slice[17].fadd.lut_LC.CIN
Info:  0.1  3.9  Source $auto$alumacc.cc:485:replace_alu$29.slice[17].fadd.lut_LC.COUT
Info:  0.0  3.9    Net $auto$alumacc.cc:485:replace_alu$29.C[18] budget 0.000000 ns (7,11) -> (7,11)
Info:                Sink $auto$alumacc.cc:485:replace_alu$29.slice[18].fadd.lut_LC.CIN
Info:  0.1  4.0  Source $auto$alumacc.cc:485:replace_alu$29.slice[18].fadd.lut_LC.COUT
Info:  0.0  4.0    Net $auto$alumacc.cc:485:replace_alu$29.C[19] budget 0.000000 ns (7,11) -> (7,11)
Info:                Sink $auto$alumacc.cc:485:replace_alu$29.slice[19].fadd.lut_LC.CIN
Info:  0.1  4.2  Source $auto$alumacc.cc:485:replace_alu$29.slice[19].fadd.lut_LC.COUT
Info:  0.0  4.2    Net $auto$alumacc.cc:485:replace_alu$29.C[20] budget 0.000000 ns (7,11) -> (7,11)
Info:                Sink $auto$alumacc.cc:485:replace_alu$29.slice[20].fadd.lut_LC.CIN
Info:  0.1  4.3  Source $auto$alumacc.cc:485:replace_alu$29.slice[20].fadd.lut_LC.COUT
Info:  0.0  4.3    Net $auto$alumacc.cc:485:replace_alu$29.C[21] budget 0.000000 ns (7,11) -> (7,11)
Info:                Sink $auto$alumacc.cc:485:replace_alu$29.slice[21].fadd.lut_LC.CIN
Info:  0.1  4.4  Source $auto$alumacc.cc:485:replace_alu$29.slice[21].fadd.lut_LC.COUT
Info:  0.3  4.7    Net $auto$alumacc.cc:485:replace_alu$29.C[22] budget 0.260000 ns (7,11) -> (7,11)
Info:                Sink $auto$alumacc.cc:485:replace_alu$29.slice[22].fadd.lut_LC.I3
Info:  0.3  5.0  Setup $auto$alumacc.cc:485:replace_alu$29.slice[22].fadd.lut_LC.I3
Info: 3.8 ns logic, 1.2 ns routing

Info: Critical path report for clock 'slowdown[22]_$glb_clk' (posedge -> posedge):
Info: curr total
Info:  0.5  0.5  Source $abc$282$auto$blifparse.cc:492:parse_blif$283_LC.O
Info:  0.6  1.1    Net led1 budget 80.252998 ns (12,12) -> (12,11)
Info:                Sink $nextpnr_ICESTORM_LC_1.I1
Info:  0.3  1.4  Source $nextpnr_ICESTORM_LC_1.COUT
Info:  0.0  1.4    Net $nextpnr_ICESTORM_LC_1$O budget 0.000000 ns (12,11) -> (12,11)
Info:                Sink $auto$alumacc.cc:485:replace_alu$32.slice[1].fadd.carry$CARRY.CIN
Info:  0.1  1.5  Source $auto$alumacc.cc:485:replace_alu$32.slice[1].fadd.carry$CARRY.COUT
Info:  0.0  1.5    Net $auto$alumacc.cc:485:replace_alu$32.C[2] budget 0.000000 ns (12,11) -> (12,11)
Info:                Sink $auto$alumacc.cc:485:replace_alu$32.slice[2].fadd.lut_LC.CIN
Info:  0.1  1.6  Source $auto$alumacc.cc:485:replace_alu$32.slice[2].fadd.lut_LC.COUT
Info:  0.0  1.6    Net $auto$alumacc.cc:485:replace_alu$32.C[3] budget 0.000000 ns (12,11) -> (12,11)
Info:                Sink $auto$alumacc.cc:485:replace_alu$32.slice[3].fadd.lut_LC.CIN
Info:  0.1  1.8  Source $auto$alumacc.cc:485:replace_alu$32.slice[3].fadd.lut_LC.COUT
Info:  0.3  2.0    Net $auto$alumacc.cc:485:replace_alu$32.C[4] budget 0.260000 ns (12,11) -> (12,11)
Info:                Sink $auto$alumacc.cc:485:replace_alu$32.slice[4].fadd.lut_LC.I3
Info:  0.3  2.4  Setup $auto$alumacc.cc:485:replace_alu$32.slice[4].fadd.lut_LC.I3
Info: 1.5 ns logic, 0.8 ns routing

Info: Critical path report for cross-domain path 'posedge slowdown[22]_$glb_clk' -> '<async>':
Info: curr total
Info:  0.5  0.5  Source $auto$alumacc.cc:485:replace_alu$32.slice[4].fadd.lut_LC.O
Info:  1.5  2.0    Net led5 budget 82.792999 ns (12,11) -> (13,9)
Info:                Sink led5$sb_io.D_OUT_0
Info: 0.5 ns logic, 1.5 ns routing

Info: Max frequency for clock                   'clk': 199.20 MHz (PASS at 12.00 MHz)
Info: Max frequency for clock 'slowdown[22]_$glb_clk': 423.73 MHz (PASS at 12.00 MHz)

Info: Max delay posedge slowdown[22]_$glb_clk -> <async>: 2.03 ns

Info: Slack histogram:
Info:  legend: * represents 1 endpoint(s)
Info:          + represents [1,1) endpoint(s)
Info: [ 78313,  78508) |** 
Info: [ 78508,  78703) |** 
Info: [ 78703,  78898) |* 
Info: [ 78898,  79093) |** 
Info: [ 79093,  79288) | 
Info: [ 79288,  79483) |* 
Info: [ 79483,  79678) |** 
Info: [ 79678,  79873) |* 
Info: [ 79873,  80068) |** 
Info: [ 80068,  80263) |** 
Info: [ 80263,  80458) | 
Info: [ 80458,  80653) |* 
Info: [ 80653,  80848) |** 
Info: [ 80848,  81043) |** 
Info: [ 81043,  81238) |**** 
Info: [ 81238,  81433) |* 
Info: [ 81433,  81628) | 
Info: [ 81628,  81823) |************************** 
Info: [ 81823,  82018) |**** 
Info: [ 82018,  82213) |**** 
1 warning, 0 errors
icepack counter5_top.asc counter5_top.bin
iceprog counter5_top.bin
init..
cdone: high
reset..
cdone: low
flash ID: 0x20 0xBA 0x16 0x10 0x00 0x00 0x23 0x71 0x32 0x74 0x10 0x00 0x44 0x00 0x40 0x17 0x05 0x17 0x25 0xDC
file size: 32220
erase 64kB sector at 0x000000..
programming..
reading..
VERIFY OK
cdone: high
Bye.

```