Require Import Coq.Lists.List.
Require Import Coq.Strings.String.
Require Import Coq.ZArith.ZArith.
Require Import Coq.Lists.List.
Require Import bedrock2.Semantics.
Require Import bedrock2.Syntax.
Require Import coqutil.Word.Interface.
Require Import Bedrock2Experiments.Word.
Require Import Bedrock2Experiments.ConstantFields.

Import ListNotations.
Local Open Scope string_scope.
Local Open Scope list_scope.

(**** This file defines global constants for the AES firmware, such as register
      addresses and enum values. ****)

(* Core class : defines all the constants*)
Class aes_constants T :=
  { (* Constants from autogenerated aes_regs.h *)
  AES_KEY0 : T; (* first key register address *)
  AES_IV0 : T; (* first initialization vector register address *)
  AES_DATA_IN0 : T; (* first input data register address *)
  AES_DATA_OUT0 : T; (* first output data register address *)
  AES_CTRL : T; (* control register address *)
  AES_CTRL_OPERATION : T; (* control flag position *)
  AES_CTRL_MODE_MASK : T; (* mask for control mode *)
  AES_CTRL_MODE_OFFSET : T; (* offset for control mode *)
  AES_CTRL_KEY_LEN_MASK : T; (* mask for control key length *)
  AES_CTRL_KEY_LEN_OFFSET : T; (* offset for control key length *)
  AES_CTRL_MANUAL_OPERATION :T; (* control flag position *)
  AES_STATUS : T; (* status register address *)
  AES_STATUS_IDLE : T; (* status flag position *)
  AES_STATUS_STALL : T; (* status flag position *)
  AES_STATUS_OUTPUT_VALID : T; (* status flag position *)
  AES_STATUS_INPUT_READY : T; (* status flag position *)

  (* Constants defined in aes.c *)
  AES_NUM_REGS_KEY : T; (* number of key registers *)
  AES_NUM_REGS_IV : T; (* number of initialization vector registers *)
  AES_NUM_REGS_DATA : T; (* number of in/out data registers *)

  (* Enum option definitions from aes.h *)
  kAesEnc : T; (* aes_op enum value *)
  kAesDec : T; (* aes_op enum value *)
  kAesEcb : T; (* aes_mode enum value *)
  kAesCbc : T; (* aes_mode enum value *)
  kAesCtr : T; (* aes_mode enum value *)
  kAes128 : T; (* aes_key_len enum value *)
  kAes192 : T; (* aes_key_len enum value *)
  kAes256 : T; (* aes_key_len enum value *)
  }.

(* Given the string names of all the constants, coerce them to bedrock2
   expressions with expr.var *)
Definition constant_vars
           {names : aes_constants string}
  : aes_constants expr :=
  {| AES_KEY0 := expr.var AES_KEY0;
     AES_IV0 := expr.var AES_IV0;
     AES_DATA_IN0 := expr.var AES_DATA_IN0;
     AES_DATA_OUT0 := expr.var AES_DATA_OUT0;
     AES_CTRL := expr.var AES_CTRL;
     AES_CTRL_OPERATION := expr.var AES_CTRL_OPERATION;
     AES_CTRL_MODE_MASK := expr.var AES_CTRL_MODE_MASK;
     AES_CTRL_MODE_OFFSET := expr.var AES_CTRL_MODE_OFFSET;
     AES_CTRL_KEY_LEN_MASK := expr.var AES_CTRL_KEY_LEN_MASK;
     AES_CTRL_KEY_LEN_OFFSET := expr.var AES_CTRL_KEY_LEN_OFFSET;
     AES_CTRL_MANUAL_OPERATION := expr.var AES_CTRL_MANUAL_OPERATION;
     AES_STATUS := expr.var AES_STATUS;
     AES_STATUS_IDLE := expr.var AES_STATUS_IDLE;
     AES_STATUS_STALL := expr.var AES_STATUS_STALL;
     AES_STATUS_OUTPUT_VALID := expr.var AES_STATUS_OUTPUT_VALID;
     AES_STATUS_INPUT_READY := expr.var AES_STATUS_INPUT_READY;
     AES_NUM_REGS_KEY := expr.var AES_NUM_REGS_KEY;
     AES_NUM_REGS_IV := expr.var AES_NUM_REGS_IV;
     AES_NUM_REGS_DATA := expr.var AES_NUM_REGS_DATA;
     kAesEnc := expr.var kAesEnc;
     kAesDec := expr.var kAesDec;
     kAesEcb := expr.var kAesEcb;
     kAesCbc := expr.var kAesCbc;
     kAesCtr := expr.var kAesCtr;
     kAes128 := expr.var kAes128;
     kAes192 := expr.var kAes192;
     kAes256 := expr.var kAes256;
  |}.

(* Given the Z values of all the constants, coerce them to bedrock2
   expressions with expr.literal *)
Definition constant_literals
           {vals : aes_constants Z}
  : aes_constants expr :=
  {| AES_KEY0 := expr.literal AES_KEY0;
     AES_IV0 := expr.literal AES_IV0;
     AES_DATA_IN0 := expr.literal AES_DATA_IN0;
     AES_DATA_OUT0 := expr.literal AES_DATA_OUT0;
     AES_CTRL := expr.literal AES_CTRL;
     AES_CTRL_OPERATION := expr.literal AES_CTRL_OPERATION;
     AES_CTRL_MODE_MASK := expr.literal AES_CTRL_MODE_MASK;
     AES_CTRL_MODE_OFFSET := expr.literal AES_CTRL_MODE_OFFSET;
     AES_CTRL_KEY_LEN_MASK := expr.literal AES_CTRL_KEY_LEN_MASK;
     AES_CTRL_KEY_LEN_OFFSET := expr.literal AES_CTRL_KEY_LEN_OFFSET;
     AES_CTRL_MANUAL_OPERATION := expr.literal AES_CTRL_MANUAL_OPERATION;
     AES_STATUS := expr.literal AES_STATUS;
     AES_STATUS_IDLE := expr.literal AES_STATUS_IDLE;
     AES_STATUS_STALL := expr.literal AES_STATUS_STALL;
     AES_STATUS_OUTPUT_VALID := expr.literal AES_STATUS_OUTPUT_VALID;
     AES_STATUS_INPUT_READY := expr.literal AES_STATUS_INPUT_READY;
     AES_NUM_REGS_KEY := expr.literal AES_NUM_REGS_KEY;
     AES_NUM_REGS_IV := expr.literal AES_NUM_REGS_IV;
     AES_NUM_REGS_DATA := expr.literal AES_NUM_REGS_DATA;
     kAesEnc := expr.literal kAesEnc;
     kAesDec := expr.literal kAesDec;
     kAesEcb := expr.literal kAesEcb;
     kAesCbc := expr.literal kAesCbc;
     kAesCtr := expr.literal kAesCtr;
     kAes128 := expr.literal kAes128;
     kAes192 := expr.literal kAes192;
     kAes256 := expr.literal kAes256;
  |}.

(* The record
{|
  AES_KEY0 := expr.var "AES_KEY0";
  AES_IV0 := expr.var "AES_IV0";
  etc...
|}
Note: does not generate "AES_KEY(0)" for AES_KEY0, but just "AES_KEY0".
*)
Definition constant_names_try0 : aes_constants string.
  instantiate_record_with_fieldname_vars.
Defined.

(* This instance provide the string name for each constant *)
Definition constant_names : aes_constants string :=
  {| AES_KEY0 := "AES_KEY0(0)";
     AES_IV0 := "AES_IV0(0)";
     AES_DATA_IN0 := "AES_DATA_IN0(0)";
     AES_DATA_OUT0 := "AES_DATA_OUT0(0)";
     AES_CTRL := "AES_CTRL(0)";
     AES_CTRL_OPERATION := "AES_CTRL_OPERATION";
     AES_CTRL_MODE_MASK := "AES_CTRL_MODE_MASK";
     AES_CTRL_MODE_OFFSET := "AES_CTRL_MODE_OFFSET";
     AES_CTRL_KEY_LEN_MASK := "AES_CTRL_KEY_LEN_MASK";
     AES_CTRL_KEY_LEN_OFFSET := "AES_CTRL_KEY_LEN_OFFSET";
     AES_CTRL_MANUAL_OPERATION := "AES_CTRL_MANUAL_OPERATION";
     AES_STATUS := "AES_STATUS(0)";
     AES_STATUS_IDLE := "AES_STATUS_IDLE";
     AES_STATUS_STALL := "AES_STATUS_STALL";
     AES_STATUS_OUTPUT_VALID := "AES_STATUS_OUTPUT_VALID";
     AES_STATUS_INPUT_READY := "AES_STATUS_INPUT_READY";
     AES_NUM_REGS_KEY := "AES_NUM_REGS_KEY";
     AES_NUM_REGS_IV := "AES_NUM_REGS_IV";
     AES_NUM_REGS_DATA := "AES_NUM_REGS_DATA";
     kAesEnc := "kAesEnc";
     kAesDec := "kAesDec";
     kAesEcb := "kAesEcb";
     kAesCbc := "kAesCbc";
     kAesCtr := "kAesCtr";
     kAes128 := "kAes128";
     kAes192 := "kAes192";
     kAes256 := "kAes256";
  |}.

Ltac app_to_string_list a :=
  match a with
  | ?f ?x => match type of x with
             | string => let r := app_to_string_list f in constr:(x :: r)
             end
  | _ => constr:(@nil string)
  end.

Definition aes_globals: list string.
  let a := eval unfold constant_names in constant_names in
  let r := app_to_string_list a in exact r.
Defined.

(* All register addresses for the AES block *)
Definition aes_reg_addrs {width} {word : word.word width}
           {global_values : aes_constants Z}
  : list word :=
  word.of_Z AES_CTRL :: word.of_Z AES_STATUS ::
         (list_reg_addrs (word.of_Z AES_KEY0) (Z.to_nat AES_NUM_REGS_KEY) 4)
      ++ (list_reg_addrs (word.of_Z AES_IV0) (Z.to_nat AES_NUM_REGS_IV) 4)
      ++ (list_reg_addrs (word.of_Z AES_DATA_IN0) (Z.to_nat AES_NUM_REGS_DATA) 4)
      ++ (list_reg_addrs (word.of_Z AES_DATA_OUT0) (Z.to_nat AES_NUM_REGS_DATA) 4).

(* see https://github.com/mit-plv/bedrock2/pull/180 *)
#[export] Hint Mode word.word - : typeclass_instances.

(* This class includes all the properties the AES constants must satisfy *)
Class aes_constants_ok
      {width} {word : word width} {word_ok : word.ok word}
      (global_values : aes_constants Z) :=
  { addrs_unique : NoDup aes_reg_addrs;
    addrs_aligned : Forall (fun addr => word.unsigned addr mod 4 = 0) aes_reg_addrs;
    addrs_small : Forall (fun addr => word.unsigned addr + 4 <= 2 ^ width) aes_reg_addrs;

    status_flags_unique_and_nonzero :
      NoDup
        ((word.of_Z 0)
           :: (map (fun flag_position => word.slu (word.of_Z 1) (word.of_Z flag_position))
                  [AES_STATUS_IDLE
                   ; AES_STATUS_STALL
                   ; AES_STATUS_OUTPUT_VALID
                   ; AES_STATUS_INPUT_READY]));

    status_flags_inbounds :
      Forall (fun flag => 0 <= flag < 32)
             [AES_STATUS_IDLE
              ; AES_STATUS_STALL
              ; AES_STATUS_OUTPUT_VALID
              ; AES_STATUS_INPUT_READY];

    (* control register needs to be properly formatted *)
    op_size := 1;
    mode_offset_ok :
      op_size <= AES_CTRL_MODE_OFFSET;
    mode_size : Z;
    key_len_offset_ok :
      AES_CTRL_MODE_OFFSET + mode_size <= AES_CTRL_KEY_LEN_OFFSET;
    key_len_size : Z;
    manual_operation_ok :
      AES_CTRL_KEY_LEN_OFFSET + key_len_size <= AES_CTRL_MANUAL_OPERATION < width;

    (* Some constants are required to have certain values *)
    nregs_key_eq : AES_NUM_REGS_KEY = 8;
    nregs_iv_eq : AES_NUM_REGS_IV = 4;
    nregs_data_eq : AES_NUM_REGS_DATA = 4;
    kAesEnc_eq : kAesEnc = 0;
    kAesDec_eq : kAesDec = 1;
    operation_eq : AES_CTRL_OPERATION = 0;
    mode_mask_eq :
      AES_CTRL_MODE_MASK = Z.ones mode_size;
    key_len_mask_eq :
      AES_CTRL_KEY_LEN_MASK = Z.ones key_len_size;

    (* Enum definitions *)
    aes_op : enum (List.map word.of_Z [kAesEnc; kAesDec]) op_size;
    aes_mode : enum (List.map word.of_Z [kAesEcb; kAesCbc; kAesCtr]) mode_size;
    aes_key_len : enum (List.map word.of_Z [kAes128; kAes192; kAes256]) key_len_size;
  }.
