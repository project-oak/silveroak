Require Import Coq.Lists.List.
Require Import Coq.Strings.String.
Require Import Coq.ZArith.ZArith.
Require Import Coq.Lists.List.
Require Import bedrock2.Semantics.
Require Import bedrock2.Syntax.
Require Import coqutil.Word.Interface.
Require Import Bedrock2Experiments.Word.
Require Import Bedrock2Experiments.ConstantFields.

Import ListNotations.
Local Open Scope string_scope.
Local Open Scope list_scope.

(**** This file defines global constants for the AES firmware, such as register
      addresses and enum values. ****)

(* Core class : defines all the constants*)
Class aes_constants T :=
  { (* Constants from autogenerated aes_regs.h *)
  AES_KEY00 : T; (* first key register address *)
  AES_IV00 : T; (* first initialization vector register address *)
  AES_DATA_IN00 : T; (* first input data register address *)
  AES_DATA_OUT00 : T; (* first output data register address *)
  AES_CTRL0 : T; (* control register address *)
  AES_CTRL_OPERATION : T; (* control flag position *)
  AES_CTRL_MODE_MASK : T; (* mask for control mode *)
  AES_CTRL_MODE_OFFSET : T; (* offset for control mode *)
  AES_CTRL_KEY_LEN_MASK : T; (* mask for control key length *)
  AES_CTRL_KEY_LEN_OFFSET : T; (* offset for control key length *)
  AES_CTRL_MANUAL_OPERATION :T; (* control flag position *)
  AES_STATUS0 : T; (* status register address *)
  AES_STATUS_IDLE : T; (* status flag position *)
  AES_STATUS_STALL : T; (* status flag position *)
  AES_STATUS_OUTPUT_VALID : T; (* status flag position *)
  AES_STATUS_INPUT_READY : T; (* status flag position *)

  (* Constants defined in aes.c *)
  AES_NUM_REGS_KEY : T; (* number of key registers *)
  AES_NUM_REGS_IV : T; (* number of initialization vector registers *)
  AES_NUM_REGS_DATA : T; (* number of in/out data registers *)

  (* Enum option definitions from aes.h *)
  kAesEnc : T; (* aes_op enum value *)
  kAesDec : T; (* aes_op enum value *)
  kAesEcb : T; (* aes_mode enum value *)
  kAesCbc : T; (* aes_mode enum value *)
  kAesCtr : T; (* aes_mode enum value *)
  kAes128 : T; (* aes_key_len enum value *)
  kAes192 : T; (* aes_key_len enum value *)
  kAes256 : T; (* aes_key_len enum value *)
  }.

(* Given the string names of all the constants, coerce them to bedrock2
   expressions with expr.var *)
Definition constant_vars {names : aes_constants string} : aes_constants expr :=
  ltac:(map_record_fields expr.var).

(* Given the Z values of all the constants, coerce them to bedrock2
   expressions with expr.literal *)
Definition constant_literals {vals : aes_constants Z} : aes_constants expr :=
  ltac:(map_record_fields expr.literal).

(* maps each field name to its name as a Coq string, replacing trailing `0` by `(0)` *)
Definition constant_names : aes_constants string :=
  ltac:(instantiate_record_with_fieldname_vars).

Ltac app_to_string_list a :=
  match a with
  | ?f ?x => match type of x with
             | string => let r := app_to_string_list f in constr:(x :: r)
             end
  | _ => constr:(@nil string)
  end.

Definition aes_globals: list string.
  let a := eval unfold constant_names in constant_names in
  let r := app_to_string_list a in exact r.
Defined.

(* All register addresses for the AES block *)
Definition aes_reg_addrs {width} {word : word.word width}
           {global_values : aes_constants Z}
  : list word :=
  word.of_Z AES_CTRL0 :: word.of_Z AES_STATUS0 ::
         (list_reg_addrs (word.of_Z AES_KEY00) (Z.to_nat AES_NUM_REGS_KEY) 4)
      ++ (list_reg_addrs (word.of_Z AES_IV00) (Z.to_nat AES_NUM_REGS_IV) 4)
      ++ (list_reg_addrs (word.of_Z AES_DATA_IN00) (Z.to_nat AES_NUM_REGS_DATA) 4)
      ++ (list_reg_addrs (word.of_Z AES_DATA_OUT00) (Z.to_nat AES_NUM_REGS_DATA) 4).

(* see https://github.com/mit-plv/bedrock2/pull/180 *)
#[export] Hint Mode word.word - : typeclass_instances.

(* This class includes all the properties the AES constants must satisfy *)
Class aes_constants_ok
      {width} {word : word width} {word_ok : word.ok word}
      (global_values : aes_constants Z) :=
  { addrs_unique : NoDup aes_reg_addrs;
    addrs_aligned : Forall (fun addr => word.unsigned addr mod 4 = 0) aes_reg_addrs;
    addrs_small : Forall (fun addr => word.unsigned addr + 4 <= 2 ^ width) aes_reg_addrs;

    status_flags_unique_and_nonzero :
      NoDup
        ((word.of_Z 0)
           :: (map (fun flag_position => word.slu (word.of_Z 1) (word.of_Z flag_position))
                  [AES_STATUS_IDLE
                   ; AES_STATUS_STALL
                   ; AES_STATUS_OUTPUT_VALID
                   ; AES_STATUS_INPUT_READY]));

    status_flags_inbounds :
      Forall (fun flag => 0 <= flag < 32)
             [AES_STATUS_IDLE
              ; AES_STATUS_STALL
              ; AES_STATUS_OUTPUT_VALID
              ; AES_STATUS_INPUT_READY];

    (* control register needs to be properly formatted *)
    op_size := 1;
    mode_offset_ok :
      op_size <= AES_CTRL_MODE_OFFSET;
    mode_size : Z;
    key_len_offset_ok :
      AES_CTRL_MODE_OFFSET + mode_size <= AES_CTRL_KEY_LEN_OFFSET;
    key_len_size : Z;
    manual_operation_ok :
      AES_CTRL_KEY_LEN_OFFSET + key_len_size <= AES_CTRL_MANUAL_OPERATION < width;

    (* Some constants are required to have certain values *)
    nregs_key_eq : AES_NUM_REGS_KEY = 8;
    nregs_iv_eq : AES_NUM_REGS_IV = 4;
    nregs_data_eq : AES_NUM_REGS_DATA = 4;
    kAesEnc_eq : kAesEnc = 0;
    kAesDec_eq : kAesDec = 1;
    operation_eq : AES_CTRL_OPERATION = 0;
    mode_mask_eq :
      AES_CTRL_MODE_MASK = Z.ones mode_size;
    key_len_mask_eq :
      AES_CTRL_KEY_LEN_MASK = Z.ones key_len_size;

    (* Enum definitions *)
    aes_op : enum (List.map word.of_Z [kAesEnc; kAesDec]) op_size;
    aes_mode : enum (List.map word.of_Z [kAesEcb; kAesCbc; kAesCtr]) mode_size;
    aes_key_len : enum (List.map word.of_Z [kAes128; kAes192; kAes256]) key_len_size;
  }.
