Require Import Coq.Lists.List.
Require Import Coq.Strings.String.
Require Import Coq.ZArith.ZArith.
Require Import bedrock2.Syntax.
Require Import bedrock2.ToCString.
Require Import bedrock2.Variables.
Require Import coqutil.Z.HexNotation.
Require Import Bedrock2Experiments.LibBase.MMIOLabels.
Require Import Bedrock2Experiments.Aes.AesSemantics.
Require Import Bedrock2Experiments.Aes.Aes.
Require Import Bedrock2Experiments.Aes.Constants.
Import ListNotations.
Local Open Scope string_scope.
Local Open Scope Z_scope.

Existing Instances constant_names constant_vars.

(* Note: There's a bug in ProofGeneral that replaces newlines in strings by spaces
   https://github.com/ProofGeneral/PG/issues/428.
   To get correct C output, rely on the output created using `make` and `coqc`. *)
Definition aes_c_template_top : string := "// Autogenerated from Coq based on LowRISC implementation

// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

#include ""sw/device/lib/aes.h""

#include ""sw/device/lib/common.h""
#include ""sw/device/lib/base/memory.h"" // for bedrock2
#include ""sw/device/lib/base/freestanding/stdint.h"" // for bedrock2

#include ""aes_regs.h""  // Generated.
#include ""hw/top_earlgrey/sw/autogen/top_earlgrey.h""

#define AES0_BASE_ADDR TOP_EARLGREY_AES_BASE_ADDR
#define AES_NUM_REGS_KEY 8
#define AES_NUM_REGS_IV 4
#define AES_NUM_REGS_DATA 4

// bedrock2 memory-access functions
static inline uintptr_t _br2_load(uintptr_t a, size_t sz) {
  uintptr_t r = 0;
  memcpy(&r, (void*)a, sz);
  return r;
}

static inline void _br2_store(uintptr_t a, uintptr_t v, size_t sz) {
  memcpy((void*)a, &v, sz);
}

// bedrock2 MMIO aliases
void " ++ MMIOLabels.WRITE32 ++ "(uintptr_t addr, uintptr_t value) {
  REG32(addr) = value;
}
uintptr_t " ++ MMIOLabels.READ32 ++ "(uintptr_t addr) {
  return REG32(addr);
}

".

Definition aes_c_template_bottom : string := "
void aes_init(aes_cfg_t aes_cfg) {
  b2_aes_init ((uintptr_t) aes_cfg.operation, (uintptr_t) aes_cfg.mode, (uintptr_t) aes_cfg.key_len, (uintptr_t) aes_cfg.manual_operation);
};

void aes_key_put(const void *key, aes_key_len_t key_len) {
  b2_key_put((uintptr_t) key, (uintptr_t) key_len);
}

void aes_iv_put(const void *iv) {
  b2_iv_put((uintptr_t) iv);
}

void aes_data_put_wait(const void *data) {
  b2_data_put_wait((uintptr_t) data);
}

void aes_data_put(const void *data) {
  b2_data_put((uintptr_t) data);
}

void aes_data_get_wait(void *data) {
  b2_data_get_wait((uintptr_t) data);
}

void aes_data_get(void *data) {
  b2_data_get((uintptr_t) data);
}

bool aes_data_ready(void) {
  return (bool) b2_data_ready();
}

bool aes_data_valid(void) {
  return (bool) b2_data_valid();
}

bool aes_idle(void) {
  return (bool) b2_idle();
}

void aes_clear(void) {
  // Wait for AES unit to be idle.
  while (!aes_idle()) {
  }

  // Disable autostart
  REG32(AES_CTRL(0)) = 0x1u << AES_CTRL_MANUAL_OPERATION;

  // Clear internal key and output registers
  REG32(AES_TRIGGER(0)) = (0x1u << AES_TRIGGER_KEY_CLEAR) |
                          (0x1u << AES_TRIGGER_IV_CLEAR) |
                          (0x1u << AES_TRIGGER_DATA_IN_CLEAR) |
                          (0x1u << AES_TRIGGER_DATA_OUT_CLEAR);

  // Wait for output not valid, and input ready
  while (!(!aes_data_valid() && aes_data_ready())) {
  }
}".

Definition funcs := [aes_init
                     ; aes_key_put
                     ; aes_iv_put
                     ; aes_data_put
                     ; aes_data_get
                     ; aes_data_ready
                     ; aes_data_valid
                     ; aes_idle
                     ; aes_data_put_wait
                     ; aes_data_get_wait].

Definition make_aes_c :=
  aes_c_template_top ++
  concat LF (map (fun f => "static " ++ c_func_with_globals aes_globals f) funcs) ++
  aes_c_template_bottom.

Require Import bedrock2.Bytedump.
Local Open Scope bytedump_scope.
Goal True.
  (* Note: run using make/coqc to avoid IDE bugs causing missing newlines or spurious <infomsg>*)
  Redirect "aes.c" let c_code := eval compute in (byte_list_of_string make_aes_c) in idtac c_code.
Abort.
