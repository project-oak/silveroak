Require Import Coq.Lists.List.
Require Import Coq.Strings.String.
Require Import Coq.ZArith.ZArith.
Require Import bedrock2.Syntax.
Require Import bedrock2.ToCString.
Require Import bedrock2.Variables.
Require Import coqutil.Z.HexNotation.
Require Import Bedrock2Experiments.Aes.AesSemantics.
Require Import Bedrock2Experiments.Aes.Aes.
Require Import Bedrock2Experiments.Aes.Constants.
Import ListNotations.
Local Open Scope string_scope.
Local Open Scope Z_scope.

Existing Instances constant_names constant_vars.

Require Import coqutil.Datatypes.ListSet.

(* TODO move to bedrock2/bedrock2 or compiler.ExprImp *)
Fixpoint modVars_as_list(c : cmd): list string :=
  match c with
  | cmd.set v _ | cmd.unset v => [v]
  | cmd.stackalloc x _ body =>
      list_union String.eqb [x] (modVars_as_list body)
  | cmd.cond _ s1 s2 | cmd.seq s1 s2 =>
      list_union String.eqb (modVars_as_list s1) (modVars_as_list s2)
  | cmd.while _ body => modVars_as_list body
  | cmd.call binds _ _ | cmd.interact binds _ _ => binds
  | cmd.skip | cmd.store _ _ _ => []
  end.

(* Redefinition from bedrock2's ToCString; the only difference is that globals
   are passed in as an extra argument and removed from the list of local decls,
   and it is checked that they don't clash with local names *)
Definition c_func globals '(name, (args, rets, body)) :=
  let name_clashes := list_intersect String.eqb
    globals (name :: args ++ rets ++ modVars_as_list body) in
  match name_clashes with
  | _ :: _ => "ERROR: In " ++ name ++ ", locals clash with globals (" ++
              String.concat ", " name_clashes ++ ")" ++ LF
  | _ =>
  let decl_retvar_retrenames : string * option String.string * list (String.string * String.string) :=
  match rets with
  | nil => (fmt_c_decl "void" args name nil, None, nil)
  | cons r0 _ =>
    let r0 := List.last rets r0 in
    let rets' := List.removelast rets in
    let retrenames := fst (rename_outs rets' (cmd.vars body)) in
    (fmt_c_decl "uintptr_t" args name (List.map snd retrenames), Some r0, retrenames)
  end in
  let decl := fst (fst decl_retvar_retrenames) in
  let retvar := snd (fst decl_retvar_retrenames) in
  let retrenames := snd decl_retvar_retrenames in
  let localvars : list String.string := List_uniq String.eqb (
      let allvars := (List.app (match retvar with None => nil | Some v => cons v nil end) (cmd.vars body)) in
      (List_minus String.eqb allvars (List.app args globals))) in
  decl ++ " {" ++ LF ++
    let indent := "  " in
    (match localvars with nil => "" | _ => indent ++ "uintptr_t " ++ concat ", " (List.map c_var localvars) ++ ";" ++ LF end) ++
    c_cmd indent body ++
    concat "" (List.map (fun '(o, optr) => indent ++ "*" ++ c_var optr ++ " = " ++ c_var o ++ ";" ++ LF) retrenames) ++
    indent ++ "return" ++ (match retvar with None => "" | Some rv => " "++c_var rv end) ++ ";" ++ LF ++
    "}" ++ LF
  end.


(* TODO: How does bedrock2 do ToCString.prelude with real newlines? *)
Definition dquote : string := String (Ascii.ascii_of_nat 34) EmptyString.
Definition aes_c_template_top : list string :=
  [ "// Autogenerated from Coq based on LowRISC implementation"
    ; ""
    ; "// Copyright lowRISC contributors."
    ; "// Licensed under the Apache License, Version 2.0, see LICENSE for details."
    ; "// SPDX-License-Identifier: Apache-2.0"
    ; ""
    ; "#include " ++ dquote ++ "sw/device/lib/aes.h" ++ dquote
    ; ""
    ; "#include " ++ dquote ++ "sw/device/lib/common.h" ++ dquote
    ; "#include " ++ dquote ++ "sw/device/lib/base/memory.h" ++ dquote ++ " // for bedrock2"
    ; "#include " ++ dquote ++ "sw/device/lib/base/freestanding/stdint.h" ++ dquote ++ " // for bedrock2"
    ; ""
    ; "#include " ++ dquote ++ "aes_regs.h" ++ dquote ++ "  // Generated."
    ; "#include " ++ dquote ++ "hw/top_earlgrey/sw/autogen/top_earlgrey.h" ++ dquote
    ; ""
    ; "#define AES0_BASE_ADDR TOP_EARLGREY_AES_BASE_ADDR"
    ; "#define AES_NUM_REGS_KEY 8"
    ; "#define AES_NUM_REGS_IV 4"
    ; "#define AES_NUM_REGS_DATA 4"
    ; ""
    ; "// bedrock2 memory-access functions"
    ; "static inline uintptr_t _br2_load(uintptr_t a, size_t sz) {"
    ; "  uintptr_t r = 0;"
    ; "  memcpy(&r, (void*)a, sz);"
    ; "  return r;"
    ; "}"
    ; ""
    ; "static inline void _br2_store(uintptr_t a, uintptr_t v, size_t sz) {"
    ; "  memcpy((void*)a, &v, sz);"
    ; "}"
    ; ""
    ; "// bedrock2 MMIO aliases"
    ; "void MMIOWRITE(uintptr_t addr, uintptr_t value) {"
    ; "  REG32(addr) = value;"
    ; "}"
    ; "uintptr_t MMIOREAD(uintptr_t addr) {"
    ; "  return REG32(addr);"
    ; "}"
    ; ""].

Definition aes_c_template_bottom : list string :=
  [ "void aes_init(aes_cfg_t aes_cfg) {"
    ; "  b2_aes_init ((uintptr_t) aes_cfg.operation, (uintptr_t) aes_cfg.mode, (uintptr_t) aes_cfg.key_len, (uintptr_t) aes_cfg.manual_operation);"
    ; "};"
    ; ""
    ; "void aes_key_put(const void *key, aes_key_len_t key_len) {"
    ; "  b2_key_put((uintptr_t) key, (uintptr_t) key_len);"
    ; "}"
    ; ""
    ; "void aes_iv_put(const void *iv) {"
    ; "  b2_iv_put((uintptr_t) iv);"
    ; "}"
    ; ""
    ; "void aes_data_put_wait(const void *data) {"
    ; "  b2_data_put_wait((uintptr_t) data);"
    ; "}"
    ; ""
    ; "void aes_data_put(const void *data) {"
    ; "  b2_data_put((uintptr_t) data);"
    ; "}"
    ; ""
    ; "void aes_data_get_wait(void *data) {"
    ; "  b2_data_get_wait((uintptr_t) data);"
    ; "}"
    ; ""
    ; "void aes_data_get(void *data) {"
    ; "  b2_data_get((uintptr_t) data);"
    ; "}"
    ; ""
    ; "bool aes_data_ready(void) {"
    ; "  return (bool) b2_data_ready();"
    ; "}"
    ; ""
    ; "bool aes_data_valid(void) {"
    ; "  return (bool) b2_data_valid();"
    ; "}"
    ; ""
    ; "bool aes_idle(void) {"
    ; "  return (bool) b2_idle();"
    ; "}"
    ; ""
    ; "void aes_clear(void) {"
    ; "  // Wait for AES unit to be idle."
    ; "  while (!aes_idle()) {"
    ; "  }"
    ; ""
    ; "  // Disable autostart"
    ; "  REG32(AES_CTRL(0)) = 0x1u << AES_CTRL_MANUAL_OPERATION;"
    ; ""
    ; "  // Clear internal key and output registers"
    ; "  REG32(AES_TRIGGER(0)) = (0x1u << AES_TRIGGER_KEY_CLEAR) |"
    ; "                          (0x1u << AES_TRIGGER_IV_CLEAR) |"
    ; "                          (0x1u << AES_TRIGGER_DATA_IN_CLEAR) |"
    ; "                          (0x1u << AES_TRIGGER_DATA_OUT_CLEAR);"
    ; ""
    ; "  // Wait for output not valid, and input ready"
    ; "  while (!(!aes_data_valid() && aes_data_ready())) {"
    ; "  }"
    ; "}"
  ].

Definition funcs := [aes_init
                     ; aes_key_put
                     ; aes_iv_put
                     ; aes_data_put
                     ; aes_data_get
                     ; aes_data_ready
                     ; aes_data_valid
                     ; aes_idle
                     ; aes_data_put_wait
                     ; aes_data_get_wait].

Definition make_aes_c :=
  concat LF (aes_c_template_top
               ++ map (fun f => "static " ++ c_func aes_globals f) funcs
               ++ aes_c_template_bottom).

Redirect "aes.c" Compute make_aes_c.
