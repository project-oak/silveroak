Require Import Coq.ZArith.ZArith.
Require Import Coq.Lists.List.
Require Import Coq.Numbers.DecimalString.
Require Import bedrock2.Syntax bedrock2.Semantics.
Require coqutil.Datatypes.String coqutil.Map.SortedList.
Require coqutil.Map.SortedListString coqutil.Map.SortedListWord.
Require Import coqutil.Map.Interface.
Require Import coqutil.Word.Interface.
Require Import coqutil.Z.HexNotation.
Require Import coqutil.Decidable.

Import String List.ListNotations.
Local Open Scope string_scope. Local Open Scope Z_scope. Local Open Scope list_scope.

(* Loosely based on bedrock2/FE310CSemantics.v *)

Definition unique_words
           {width} {word: word.word width} {word_ok:word.ok word}
           (l : list word.rep) : Prop :=
  List.dedup word.eqb l = l.

(* Compute sequential 32-bit register addresses given a start address and a
   number of registers *)
Definition list_reg_addrs {word : word.word 32}
           (start : word.rep) (nregs : nat)
  : list word.rep :=
  map (fun i => word.add start (word.of_Z (Z.of_nat i * 4)))
      (seq 0 nregs).

Definition option_bind {A B} (x : option A) (f : A -> option B) : option B :=
  match x with
  | Some a => f a
  | None => None
  end.
Local Notation "y <- x ;; f" := (option_bind x (fun y => f))
                                  (at level 61, right associativity).

Module constants.
  Class constants T :=
    { (* Constants from autogenerated aes_regs.h *)
      AES_KEY0 : T; (* first key register address *)
      AES_IV0 : T; (* first initialization vector register address *)
      AES_DATA_IN0 : T; (* first input data register address *)
      AES_DATA_OUT0 : T; (* first output data register address *)
      AES_CTRL : T; (* control register address *)
      AES_CTRL_OPERATION : T; (* control flag position *)
      AES_CTRL_MODE_MASK : T; (* mask for control mode *)
      AES_CTRL_MODE_OFFSET : T; (* offset for control mode *)
      AES_CTRL_KEY_LEN_MASK : T; (* mask for control key length *)
      AES_CTRL_KEY_LEN_OFFSET : T; (* offset for control key length *)
      AES_CTRL_MANUAL_OPERATION :T; (* control flag position *)
      AES_STATUS : T; (* status register address *)
      AES_STATUS_IDLE : T; (* status flag position *)
      AES_STATUS_STALL : T; (* status flag position *)
      AES_STATUS_OUTPUT_VALID : T; (* status flag position *)
      AES_STATUS_INPUT_READY : T; (* status flag position *)

      (* Constants defined in aes.c *)
      AES_NUM_REGS_KEY : T; (* number of key registers *)
      AES_NUM_REGS_IV : T; (* number of initialization vector registers *)
      AES_NUM_REGS_DATA : T; (* number of in/out data registers *)
    }.

  Definition constant_vars
           {names : constants string}
    : constants expr :=
    {| AES_KEY0 := expr.var AES_KEY0;
       AES_IV0 := expr.var AES_IV0;
       AES_DATA_IN0 := expr.var AES_DATA_IN0;
       AES_DATA_OUT0 := expr.var AES_DATA_OUT0;
       AES_CTRL := expr.var AES_CTRL;
       AES_CTRL_OPERATION := expr.var AES_CTRL_OPERATION;
       AES_CTRL_MODE_MASK := expr.var AES_CTRL_MODE_MASK;
       AES_CTRL_MODE_OFFSET := expr.var AES_CTRL_MODE_OFFSET;
       AES_CTRL_KEY_LEN_MASK := expr.var AES_CTRL_KEY_LEN_MASK;
       AES_CTRL_KEY_LEN_OFFSET := expr.var AES_CTRL_KEY_LEN_OFFSET;
       AES_CTRL_MANUAL_OPERATION := expr.var AES_CTRL_MANUAL_OPERATION;
       AES_STATUS := expr.var AES_STATUS;
       AES_STATUS_IDLE := expr.var AES_STATUS_IDLE;
       AES_STATUS_STALL := expr.var AES_STATUS_STALL;
       AES_STATUS_OUTPUT_VALID := expr.var AES_STATUS_OUTPUT_VALID;
       AES_STATUS_INPUT_READY := expr.var AES_STATUS_INPUT_READY;
       AES_NUM_REGS_KEY := expr.var AES_NUM_REGS_KEY;
       AES_NUM_REGS_IV := expr.var AES_NUM_REGS_IV;
       AES_NUM_REGS_DATA := expr.var AES_NUM_REGS_DATA;
    |}.

  Definition constant_names : constants string :=
    {| AES_KEY0 := "AES_KEY0";
       AES_IV0 := "AES_IV0";
       AES_DATA_IN0 := "AES_DATA_IN0";
       AES_DATA_OUT0 := "AES_DATA_OUT0";
       AES_CTRL := "AES_CTRL";
       AES_CTRL_OPERATION := "AES_CTRL_OPERATION";
       AES_CTRL_MODE_MASK := "AES_CTRL_MODE_MASK";
       AES_CTRL_MODE_OFFSET := "AES_CTRL_MODE_OFFSET";
       AES_CTRL_KEY_LEN_MASK := "AES_CTRL_KEY_LEN_MASK";
       AES_CTRL_KEY_LEN_OFFSET := "AES_CTRL_KEY_LEN_OFFSET";
       AES_CTRL_MANUAL_OPERATION := "AES_CTRL_MANUAL_OPERATION";
       AES_STATUS := "AES_STATUS";
       AES_STATUS_IDLE := "AES_STATUS_IDLE";
       AES_STATUS_STALL := "AES_STATUS_STALL";
       AES_STATUS_OUTPUT_VALID := "AES_STATUS_OUTPUT_VALID";
       AES_STATUS_INPUT_READY := "AES_STATUS_INPUT_READY";
       AES_NUM_REGS_KEY := "AES_NUM_REGS_KEY";
       AES_NUM_REGS_IV := "AES_NUM_REGS_IV";
       AES_NUM_REGS_DATA := "AES_NUM_REGS_DATA";
    |}.

  Definition globals {T} {consts : constants T} : list T :=
    [ AES_KEY0
      ; AES_IV0
      ; AES_DATA_IN0
      ; AES_DATA_OUT0
      ; AES_CTRL
      ; AES_CTRL_OPERATION
      ; AES_CTRL_MODE_MASK
      ; AES_CTRL_MODE_OFFSET
      ; AES_CTRL_KEY_LEN_MASK
      ; AES_CTRL_KEY_LEN_OFFSET
      ; AES_CTRL_MANUAL_OPERATION
      ; AES_STATUS
      ; AES_STATUS_IDLE
      ; AES_STATUS_STALL
      ; AES_STATUS_OUTPUT_VALID
      ; AES_STATUS_INPUT_READY
      ; AES_NUM_REGS_KEY
      ; AES_NUM_REGS_IV
      ; AES_NUM_REGS_DATA
    ].

  Definition all_reg_addrs {word : word.word 32}
             {global_values : constants word.rep}
    : list word.rep :=
    AES_CTRL :: AES_STATUS ::
    (list_reg_addrs AES_KEY0 (Z.to_nat (word.unsigned AES_NUM_REGS_KEY)))
      ++ (list_reg_addrs AES_IV0 (Z.to_nat (word.unsigned AES_NUM_REGS_IV)))
      ++ (list_reg_addrs AES_DATA_IN0 (Z.to_nat (word.unsigned AES_NUM_REGS_DATA)))
      ++ (list_reg_addrs AES_DATA_OUT0 (Z.to_nat (word.unsigned AES_NUM_REGS_DATA))).

  Class ok
        {word : word.word 32} {word_ok : word.ok word}
        (global_values : constants word.rep) :=
    { addrs_unique : unique_words all_reg_addrs;
      nregs_key_eq : word.unsigned AES_NUM_REGS_KEY = 8;
      nregs_iv_eq : word.unsigned AES_NUM_REGS_IV = 4;
      nregs_data_eq : word.unsigned AES_NUM_REGS_DATA = 4;
      status_flags_unique_and_nonzero :
        unique_words
          ((word.of_Z 0)
             :: (map (fun flag_position => word.slu (word.of_Z 1) flag_position)
                    [AES_STATUS_IDLE
                     ; AES_STATUS_STALL
                     ; AES_STATUS_OUTPUT_VALID
                     ; AES_STATUS_INPUT_READY]));
    }.
End constants.
Notation constants := constants.constants.

(* Circuit timing properties *)
Module timing.
  Class timing :=
    { ndelays_core : nat; (* number of delays on AES core datapath *)
    }.
End timing.
Notation timing := timing.timing.

Module parameters.
  Class parameters :=
    { word :> Interface.word.word 32;
      mem :> Interface.map.map word.rep Byte.byte;
      regs :> Interface.map.map word.rep word.rep; (* register values *)
    }.

  Class ok (p : parameters) :=
    { word_ok :> word.ok word; (* for impl of mem below *)
      mem_ok :> Interface.map.ok mem; (* for impl of mem below *)
      regs_ok :> Interface.map.ok regs;
    }.
End parameters.
Notation parameters := parameters.parameters.

Definition READ := "REG32_GET".
Definition WRITE := "REG32_SET".

Section WithParameters.
  Import constants parameters.
  Context {p : parameters} {p_ok : parameters.ok p}.
  Context {consts : constants word.rep} {timing : timing}.
  (* TODO: mode is currently ignored *)
  Context (aes_spec :
             forall (key : word * word * word * word * word * word * word * word)
               (iv data : word * word * word * word),
               word * word * word * word).

  Local Notation bedrock2_event := (mem * string * list word * (mem * list word))%type.
  Local Notation bedrock2_trace := (list bedrock2_event).

  Inductive Register : Set :=
  | CTRL
  | STATUS
  | KEY0
  | KEY1
  | KEY2
  | KEY3
  | KEY4
  | KEY5
  | KEY6
  | KEY7
  | IV0
  | IV1
  | IV2
  | IV3
  | DATA_IN0
  | DATA_IN1
  | DATA_IN2
  | DATA_IN3
  | DATA_OUT0
  | DATA_OUT1
  | DATA_OUT2
  | DATA_OUT3
  .

  (* define reg_addr : Register -> word

     for reg_lookup : rs[reg_addr]

     in step : forall addr r, reg_addr r = addr
     in proofs: reg_addr ?r = <some addr expression>

     prove a proof for each reg and add them as hints to reg_addrs (or even step)


 *)
  Definition reg_addr (r : Register) : word :=
    match r with
    | CTRL => AES_CTRL
    | STATUS => AES_STATUS
    | KEY0 => AES_KEY0
    | KEY1 => word.add AES_KEY0 (word.of_Z 4)
    | KEY2 => word.add AES_KEY0 (word.of_Z 8)
    | KEY3 => word.add AES_KEY0 (word.of_Z 12)
    | KEY4 => word.add AES_KEY0 (word.of_Z 16)
    | KEY5 => word.add AES_KEY0 (word.of_Z 20)
    | KEY6 => word.add AES_KEY0 (word.of_Z 24)
    | KEY7 => word.add AES_KEY0 (word.of_Z 28)
    | IV0 => AES_IV0
    | IV1 => word.add AES_IV0 (word.of_Z 4)
    | IV2 => word.add AES_IV0 (word.of_Z 8)
    | IV3 => word.add AES_IV0 (word.of_Z 12)
    | DATA_IN0 => AES_DATA_IN0
    | DATA_IN1 => word.add AES_DATA_IN0 (word.of_Z 4)
    | DATA_IN2 => word.add AES_DATA_IN0 (word.of_Z 8)
    | DATA_IN3 => word.add AES_DATA_IN0 (word.of_Z 12)
    | DATA_OUT0 => AES_DATA_OUT0
    | DATA_OUT1 => word.add AES_DATA_OUT0 (word.of_Z 4)
    | DATA_OUT2 => word.add AES_DATA_OUT0 (word.of_Z 8)
    | DATA_OUT3 => word.add AES_DATA_OUT0 (word.of_Z 12)
    end.

  Definition known_register_state : Type := map.rep (map:=regs).

  Definition reg_lookup (rs : known_register_state) (r : Register) : option word :=
    map.get rs (reg_addr r).
  (*
  Record aes_input {T} :=
    { key0 : T;
      key1 : T;
      key2 : T;
      key3 : T;
      key4 : T;
      key5 : T;
      key6 : T;
      key7 : T;
      iv0 : T;
      iv1 : T;
      iv2 : T;
      iv3 : T;
      data_in0 : T;
      data_in1 : T;
      data_in2 : T;
      data_in3 : T; }.
  Global Arguments aes_input : clear implicits.

*)
  Record aes_output :=
    { data_out0 : word;
      data_out1 : word;
      data_out2 : word;
      data_out3 : word; }.

  (* state *from the perspective of the software* *)
  Inductive state : Type :=
  | UNINITIALIZED (* CTRL register not yet written *)
  | IDLE (rs : known_register_state)
  | BUSY (exp_output : aes_output)
         (max_cycles_until_done : nat)
  | DONE (rs : known_register_state)
  (* TODO: add CLEAR state for aes_clear *)
  .

  (* the flag is set if ((val & (1 << flag)) != 0) *)
  Definition is_flag_set (val : word) (flag : word) : bool :=
    word.eqb (word.and val (word.slu (word.of_Z 1) flag)) (word.of_Z 0).

  (* Flags: IDLE, STALL, OUTPUT_VALID, INPUT_READY *)
  Definition status_matches_state (s : state) (status : word) : bool :=
    match s with
    | UNINITIALIZED =>
      (is_flag_set status AES_STATUS_IDLE
       && negb (is_flag_set status AES_STATUS_STALL)
       && negb (is_flag_set status AES_STATUS_OUTPUT_VALID)
       && negb (is_flag_set status AES_STATUS_INPUT_READY))
    | IDLE _ =>
      (is_flag_set status AES_STATUS_IDLE
       && negb (is_flag_set status AES_STATUS_STALL)
       && negb (is_flag_set status AES_STATUS_OUTPUT_VALID)
       && is_flag_set status AES_STATUS_INPUT_READY)
    | BUSY _ _ =>
      (negb (is_flag_set status AES_STATUS_IDLE)
       && negb (is_flag_set status AES_STATUS_STALL)
       && negb (is_flag_set status AES_STATUS_OUTPUT_VALID)
       && negb (is_flag_set status AES_STATUS_INPUT_READY))
    | DONE _ =>
      (* STALL can be either true or false here *)
      (negb (is_flag_set status AES_STATUS_IDLE)
       && is_flag_set status AES_STATUS_OUTPUT_VALID
       && negb (is_flag_set status AES_STATUS_INPUT_READY))
    end.

  Definition aes_expected_output (rs : known_register_state) : option aes_output :=
    key0 <- reg_lookup rs KEY0 ;;
    key1 <- reg_lookup rs KEY1 ;;
    key2 <- reg_lookup rs KEY2 ;;
    key3 <- reg_lookup rs KEY3 ;;
    key4 <- reg_lookup rs KEY4 ;;
    key5 <- reg_lookup rs KEY5 ;;
    key6 <- reg_lookup rs KEY6 ;;
    key7 <- reg_lookup rs KEY7 ;;
    iv0 <- reg_lookup rs IV0 ;;
    iv1 <- reg_lookup rs IV1 ;;
    iv2 <- reg_lookup rs IV2 ;;
    iv3 <- reg_lookup rs IV3 ;;
    data_in0 <- reg_lookup rs DATA_IN0 ;;
    data_in1 <- reg_lookup rs DATA_IN1 ;;
    data_in2 <- reg_lookup rs DATA_IN2 ;;
    data_in3 <- reg_lookup rs DATA_IN3 ;;
    let '(out0, out1, out2, out3) :=
        aes_spec (key0, key1, key2, key3, key4, key5, key6, key7)
                 (iv0, iv1, iv2, iv3)
                 (data_in0, data_in1, data_in2, data_in3) in
    Some {| data_out0 := out0 ;
            data_out1 := out1 ;
            data_out2 := out2 ;
            data_out3 := out3 ; |}.

  Definition is_busy (s : state) : bool :=
    match s with
    | BUSY _ _ => true
    | _ => false
    end.

  Definition is_output_reg (r : Register) : bool :=
    match r with
    | DATA_OUT0 => true
    | DATA_OUT1 => true
    | DATA_OUT2 => true
    | DATA_OUT3 => true
    | _ => false
    end.

  Definition out_regs_empty (rs : known_register_state) : Prop :=
    reg_lookup rs DATA_OUT0 = None
    /\ reg_lookup rs DATA_OUT1 = None
    /\ reg_lookup rs DATA_OUT2 = None
    /\ reg_lookup rs DATA_OUT3 = None.

  Definition set_out_regs
             (rs : known_register_state) (out : aes_output) : known_register_state :=
    let rs := map.put rs (reg_addr DATA_OUT0) out.(data_out0) in
    let rs := map.put rs (reg_addr DATA_OUT1) out.(data_out1) in
    let rs := map.put rs (reg_addr DATA_OUT2) out.(data_out2) in
    map.put rs (reg_addr DATA_OUT3) out.(data_out3).

  Inductive read_step : state -> Register -> word -> state -> Prop :=
  | ReadStatusNoChange :
      forall s val,
        is_busy s = false ->
        status_matches_state s val = true ->
        read_step s STATUS val s
  | ReadStatusStillBusy :
      forall out n val,
        status_matches_state (BUSY out n) val = true ->
        (* max #cycles until done decreases once every read *)
        read_step (BUSY out (S n)) STATUS val (BUSY out n)
  | ReadStatusFinish :
      forall rs out val n,
        status_matches_state (DONE rs) val = true ->
        rs = set_out_regs map.empty out ->
        read_step (BUSY out n) STATUS val (DONE rs)
  | ReadOutputReg :
      forall rs rs' r val,
        is_output_reg r = true ->
        reg_lookup rs r = Some val ->
        rs' = map.remove rs (reg_addr r) ->
        not (out_regs_empty rs') -> (* still not done reading output *)
        read_step (DONE rs) r val (DONE rs')
  | ReadLastOutputReg :
      forall rs rs' r val,
        is_output_reg r = true ->
        reg_lookup rs r = Some val ->
        rs' = map.remove rs (reg_addr r) ->
        out_regs_empty rs' -> (* done reading output *)
        read_step (DONE rs) r val (IDLE rs')
  .

  Definition is_input_reg (r : Register) : bool :=
    match r with
    | KEY0 => true
    | KEY1 => true
    | KEY2 => true
    | KEY3 => true
    | KEY4 => true
    | KEY5 => true
    | KEY6 => true
    | KEY7 => true
    | IV0 => true
    | IV1 => true
    | IV2 => true
    | IV3 => true
    | DATA_IN0 => true
    | DATA_IN1 => true
    | DATA_IN2 => true
    | DATA_IN3 => true
    | _ => false
    end.

  Inductive write_step : state -> Register -> word -> state -> Prop :=
  | WriteCtrl :
      forall val,
        write_step UNINITIALIZED CTRL val
                   (IDLE (map.put map.empty AES_CTRL val))
  | WriteInput :
      forall rs rs' r val,
        is_input_reg r = true ->
        reg_lookup rs r = None ->
        rs' = map.put rs (reg_addr r) val ->
        aes_expected_output rs' = None ->
        write_step (IDLE rs) r val
                   (IDLE (map.put rs (reg_addr r) val))
  (* TODO: add the below rules?
  | WriteChangeCtrl :
      forall rs val,
        write_step (IDLE rs) CTRL val
                   (IDLE (map.put rs AES_CTRL val))
  | WriteChangeInput :
      forall rs r old_val val n,
        is_input_reg rs r ->
        reg_lookup rs r = Some old_val ->
        write_step (IDLE rs n) r val (IDLE (map.put rs r val) n) *)
  | WriteLastInput :
      forall rs r val out,
        is_input_reg r = true ->
        reg_lookup rs r = None ->
        let rs' := map.put rs (reg_addr r) val in
        aes_expected_output rs' = Some out ->
        write_step (IDLE rs) r val
                   (BUSY out timing.ndelays_core)
  .

  Inductive step : string -> state -> list word -> list word -> state -> Prop :=
  | ReadStep :
      forall s s' r addr val,
        reg_addr r = addr ->
        read_step s r val s' ->
        step READ s [addr] [val] s'
  | WriteStep :
      forall s s' r addr val,
        reg_addr r = addr ->
        write_step s r val s' ->
        step WRITE s [addr;val] [] s'
  .

  (* Computes the Prop that must hold for this state to be accurate after the
     trace *)
  Fixpoint execution (t : bedrock2_trace) (s : state) : Prop :=
    match t with
    | [] => s = UNINITIALIZED
    | (_,action,args,(_,rets)) :: t =>
      exists prev_state,
      execution t prev_state
      /\ step action prev_state args rets s
    end.

  Definition ext_spec (t : bedrock2_trace)
             (mGive : mem)
             (action : string)
             (args: list word)
             (post: mem -> list word -> Prop) :=
    (* no memory ever given away *)
    mGive = Interface.map.empty
    /\ forall st rets,
      execution ((map.empty,action,args,(map.empty,rets)) :: t) st ->
      post Interface.map.empty rets.

  Global Instance semantics_parameters  : Semantics.parameters :=
    {|
    Semantics.width := 32;
    Semantics.word := parameters.word;
    Semantics.mem := parameters.mem;
    Semantics.locals := SortedListString.map _;
    Semantics.env := SortedListString.map _;
    Semantics.ext_spec := ext_spec;
  |}.

  Global Instance ext_spec_ok : ext_spec.ok _.
  Proof.
    constructor.
    all:cbv [ext_spec Semantics.ext_spec semantics_parameters].
    all:cbv [Morphisms.pointwise_relation Basics.impl].
    all:cbn [execution].
    all:repeat intro.
    all:repeat lazymatch goal with
               | H: _ /\ _ |- _ => destruct H
               | H: exists _, _ |- _ => destruct H
               | |- map.same_domain ?x ?x => apply Properties.map.same_domain_refl
               |  |- ?x = ?x /\ _ => split; [ reflexivity | ]
               | _ => progress subst
               end.
    all:eauto.
  Qed.

  Global Instance ok : Semantics.parameters_ok semantics_parameters.
  Proof.
    split; cbv [env locals mem semantics_parameters]; try exact _.
    { cbv; auto. }
    { exact (SortedListString.ok _). }
    { exact (SortedListString.ok _). }
  Qed.

  (* COPY-PASTE this *)
  Add Ring wring : (Properties.word.ring_theory (word := Semantics.word))
        (preprocess [autorewrite with rew_word_morphism],
         morphism (Properties.word.ring_morph (word := Semantics.word)),
         constants [Properties.word_cst]).
End WithParameters.
