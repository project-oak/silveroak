Require Import Coq.ZArith.ZArith.
Require Import Coq.Lists.List.
Require Import Coq.Numbers.DecimalString.
Require Import bedrock2.Syntax bedrock2.Semantics.
Require coqutil.Datatypes.String coqutil.Map.SortedList.
Require coqutil.Map.SortedListString coqutil.Map.SortedListWord.
Require Import coqutil.Map.Interface.
Require Import coqutil.Word.Interface.
Require Import coqutil.Z.HexNotation.
Require Import coqutil.Decidable.

Import String List.ListNotations.
Local Open Scope string_scope. Local Open Scope Z_scope. Local Open Scope list_scope.

(* Loosely based on bedrock2/FE310CSemantics.v *)

Section WithWord.
  Context {width} {word : word.word width} {word_ok : word.ok word}.

  Definition unique_words (l : list word.rep) : Prop :=
    List.dedup word.eqb l = l.

  (* Compute sequential register addresses given a start address and a number of
   registers *)
  Definition list_reg_addrs (start : word.rep) (nregs size_in_bytes : nat)
    : list word.rep :=
    map (fun i => word.add start (word.of_Z (Z.of_nat i * Z.of_nat size_in_bytes)))
        (seq 0 nregs).

  Definition select_bits (w : word) (offset mask : word) : word :=
    word.and (word.sru w offset) mask.

  (* the flag is set if ((val & (1 << flag)) != 0) *)
  Definition is_flag_set (val : word) (flag : word) : bool :=
    word.eqb (word.and val (word.slu (word.of_Z 1) flag)) (word.of_Z 0).

  Definition has_size w (n : Z) : Prop :=
    0 <= word.unsigned w < 2 ^ n.
End WithWord.

Definition option_bind {A B} (x : option A) (f : A -> option B) : option B :=
  match x with
  | Some a => f a
  | None => None
  end.
Local Notation "y <- x ;; f" := (option_bind x (fun y => f))
                                  (at level 61, right associativity).

Section Enum.
  Context {width} {word : word.word width} {ok : word.ok word}.

  Record enum {elts : list word} {size : Z} :=
    { enum_size_ok :
        Forall (fun w => has_size w size) elts;
      enum_unique : unique_words elts;
      enum_member (w : word) := In w elts;
    }.
  Global Arguments enum : clear implicits.
End Enum.

Module constants.
  Class constants T :=
    { (* Constants from autogenerated aes_regs.h *)
      AES_KEY0 : T; (* first key register address *)
      AES_IV0 : T; (* first initialization vector register address *)
      AES_DATA_IN0 : T; (* first input data register address *)
      AES_DATA_OUT0 : T; (* first output data register address *)
      AES_CTRL : T; (* control register address *)
      AES_CTRL_OPERATION : T; (* control flag position *)
      AES_CTRL_MODE_MASK : T; (* mask for control mode *)
      AES_CTRL_MODE_OFFSET : T; (* offset for control mode *)
      AES_CTRL_KEY_LEN_MASK : T; (* mask for control key length *)
      AES_CTRL_KEY_LEN_OFFSET : T; (* offset for control key length *)
      AES_CTRL_MANUAL_OPERATION :T; (* control flag position *)
      AES_STATUS : T; (* status register address *)
      AES_STATUS_IDLE : T; (* status flag position *)
      AES_STATUS_STALL : T; (* status flag position *)
      AES_STATUS_OUTPUT_VALID : T; (* status flag position *)
      AES_STATUS_INPUT_READY : T; (* status flag position *)

      (* Constants defined in aes.c *)
      AES_NUM_REGS_KEY : T; (* number of key registers *)
      AES_NUM_REGS_IV : T; (* number of initialization vector registers *)
      AES_NUM_REGS_DATA : T; (* number of in/out data registers *)

      (* Enum option definitions from aes.h *)
      kAesEnc : T;
      kAesDec : T;
      kAesEcb : T;
      kAesCbc : T;
      kAesCtr : T;
      kAes128 : T;
      kAes192 : T;
      kAes256 : T;
    }.

  Definition constant_vars
           {names : constants string}
    : constants expr :=
    {| AES_KEY0 := expr.var AES_KEY0;
       AES_IV0 := expr.var AES_IV0;
       AES_DATA_IN0 := expr.var AES_DATA_IN0;
       AES_DATA_OUT0 := expr.var AES_DATA_OUT0;
       AES_CTRL := expr.var AES_CTRL;
       AES_CTRL_OPERATION := expr.var AES_CTRL_OPERATION;
       AES_CTRL_MODE_MASK := expr.var AES_CTRL_MODE_MASK;
       AES_CTRL_MODE_OFFSET := expr.var AES_CTRL_MODE_OFFSET;
       AES_CTRL_KEY_LEN_MASK := expr.var AES_CTRL_KEY_LEN_MASK;
       AES_CTRL_KEY_LEN_OFFSET := expr.var AES_CTRL_KEY_LEN_OFFSET;
       AES_CTRL_MANUAL_OPERATION := expr.var AES_CTRL_MANUAL_OPERATION;
       AES_STATUS := expr.var AES_STATUS;
       AES_STATUS_IDLE := expr.var AES_STATUS_IDLE;
       AES_STATUS_STALL := expr.var AES_STATUS_STALL;
       AES_STATUS_OUTPUT_VALID := expr.var AES_STATUS_OUTPUT_VALID;
       AES_STATUS_INPUT_READY := expr.var AES_STATUS_INPUT_READY;
       AES_NUM_REGS_KEY := expr.var AES_NUM_REGS_KEY;
       AES_NUM_REGS_IV := expr.var AES_NUM_REGS_IV;
       AES_NUM_REGS_DATA := expr.var AES_NUM_REGS_DATA;
       kAesEnc := expr.var kAesEnc;
       kAesDec := expr.var kAesDec;
       kAesEcb := expr.var kAesEcb;
       kAesCbc := expr.var kAesCbc;
       kAesCtr := expr.var kAesCtr;
       kAes128 := expr.var kAes128;
       kAes192 := expr.var kAes192;
       kAes256 := expr.var kAes256;
    |}.

  Definition constant_words
           {width} {word : word width} {word_ok : word.ok word}
           {vals : constants Z}
    : constants word :=
    {| AES_KEY0 := word.of_Z AES_KEY0;
       AES_IV0 := word.of_Z AES_IV0;
       AES_DATA_IN0 := word.of_Z AES_DATA_IN0;
       AES_DATA_OUT0 := word.of_Z AES_DATA_OUT0;
       AES_CTRL := word.of_Z AES_CTRL;
       AES_CTRL_OPERATION := word.of_Z AES_CTRL_OPERATION;
       AES_CTRL_MODE_MASK := word.of_Z AES_CTRL_MODE_MASK;
       AES_CTRL_MODE_OFFSET := word.of_Z AES_CTRL_MODE_OFFSET;
       AES_CTRL_KEY_LEN_MASK := word.of_Z AES_CTRL_KEY_LEN_MASK;
       AES_CTRL_KEY_LEN_OFFSET := word.of_Z AES_CTRL_KEY_LEN_OFFSET;
       AES_CTRL_MANUAL_OPERATION := word.of_Z AES_CTRL_MANUAL_OPERATION;
       AES_STATUS := word.of_Z AES_STATUS;
       AES_STATUS_IDLE := word.of_Z AES_STATUS_IDLE;
       AES_STATUS_STALL := word.of_Z AES_STATUS_STALL;
       AES_STATUS_OUTPUT_VALID := word.of_Z AES_STATUS_OUTPUT_VALID;
       AES_STATUS_INPUT_READY := word.of_Z AES_STATUS_INPUT_READY;
       AES_NUM_REGS_KEY := word.of_Z AES_NUM_REGS_KEY;
       AES_NUM_REGS_IV := word.of_Z AES_NUM_REGS_IV;
       AES_NUM_REGS_DATA := word.of_Z AES_NUM_REGS_DATA;
       kAesEnc := word.of_Z kAesEnc;
       kAesDec := word.of_Z kAesDec;
       kAesEcb := word.of_Z kAesEcb;
       kAesCbc := word.of_Z kAesCbc;
       kAesCtr := word.of_Z kAesCtr;
       kAes128 := word.of_Z kAes128;
       kAes192 := word.of_Z kAes192;
       kAes256 := word.of_Z kAes256;
    |}.

  Definition constant_names : constants string :=
    {| AES_KEY0 := "AES_KEY0";
       AES_IV0 := "AES_IV0";
       AES_DATA_IN0 := "AES_DATA_IN0";
       AES_DATA_OUT0 := "AES_DATA_OUT0";
       AES_CTRL := "AES_CTRL";
       AES_CTRL_OPERATION := "AES_CTRL_OPERATION";
       AES_CTRL_MODE_MASK := "AES_CTRL_MODE_MASK";
       AES_CTRL_MODE_OFFSET := "AES_CTRL_MODE_OFFSET";
       AES_CTRL_KEY_LEN_MASK := "AES_CTRL_KEY_LEN_MASK";
       AES_CTRL_KEY_LEN_OFFSET := "AES_CTRL_KEY_LEN_OFFSET";
       AES_CTRL_MANUAL_OPERATION := "AES_CTRL_MANUAL_OPERATION";
       AES_STATUS := "AES_STATUS";
       AES_STATUS_IDLE := "AES_STATUS_IDLE";
       AES_STATUS_STALL := "AES_STATUS_STALL";
       AES_STATUS_OUTPUT_VALID := "AES_STATUS_OUTPUT_VALID";
       AES_STATUS_INPUT_READY := "AES_STATUS_INPUT_READY";
       AES_NUM_REGS_KEY := "AES_NUM_REGS_KEY";
       AES_NUM_REGS_IV := "AES_NUM_REGS_IV";
       AES_NUM_REGS_DATA := "AES_NUM_REGS_DATA";
       kAesEnc := "kAesEnc";
       kAesDec := "kAesDec";
       kAesEcb := "kAesEcb";
       kAesCbc := "kAesCbc";
       kAesCtr := "kAesCtr";
       kAes128 := "kAes128";
       kAes192 := "kAes192";
       kAes256 := "kAes256";
    |}.

  Definition globals {T} {consts : constants T} : list T :=
    [ AES_KEY0
      ; AES_IV0
      ; AES_DATA_IN0
      ; AES_DATA_OUT0
      ; AES_CTRL
      ; AES_CTRL_OPERATION
      ; AES_CTRL_MODE_MASK
      ; AES_CTRL_MODE_OFFSET
      ; AES_CTRL_KEY_LEN_MASK
      ; AES_CTRL_KEY_LEN_OFFSET
      ; AES_CTRL_MANUAL_OPERATION
      ; AES_STATUS
      ; AES_STATUS_IDLE
      ; AES_STATUS_STALL
      ; AES_STATUS_OUTPUT_VALID
      ; AES_STATUS_INPUT_READY
      ; AES_NUM_REGS_KEY
      ; AES_NUM_REGS_IV
      ; AES_NUM_REGS_DATA
      ; kAesEnc
      ; kAesDec
      ; kAesEcb
      ; kAesCbc
      ; kAesCtr
      ; kAes128
      ; kAes192
      ; kAes256
    ].

  Definition all_reg_addrs {width} {word : word.word width}
             {global_values : constants word.rep}
    : list word.rep :=
    AES_CTRL :: AES_STATUS ::
    (list_reg_addrs AES_KEY0 (Z.to_nat (word.unsigned AES_NUM_REGS_KEY)) 4)
      ++ (list_reg_addrs AES_IV0 (Z.to_nat (word.unsigned AES_NUM_REGS_IV)) 4)
      ++ (list_reg_addrs AES_DATA_IN0 (Z.to_nat (word.unsigned AES_NUM_REGS_DATA)) 4)
      ++ (list_reg_addrs AES_DATA_OUT0 (Z.to_nat (word.unsigned AES_NUM_REGS_DATA)) 4).

  Class ok
        {p : Semantics.parameters} {p_ok : Semantics.parameters_ok p}
        (global_values : constants Semantics.word) :=
    { addrs_unique : unique_words all_reg_addrs;
      status_flags_unique_and_nonzero :
        unique_words
          ((word.of_Z 0)
             :: (map (fun flag_position => word.slu (word.of_Z 1) flag_position)
                    [AES_STATUS_IDLE
                     ; AES_STATUS_STALL
                     ; AES_STATUS_OUTPUT_VALID
                     ; AES_STATUS_INPUT_READY]));

      (* control register needs to be properly formatted *)
      op_size := 1;
      mode_offset_ok :
        op_size <= word.unsigned AES_CTRL_MODE_OFFSET;
      mode_size : Z;
      key_len_offset_ok :
        word.unsigned AES_CTRL_MODE_OFFSET + mode_size
        <= word.unsigned AES_CTRL_KEY_LEN_OFFSET;
      key_len_size : Z;
      manual_operation_ok :
        word.unsigned AES_CTRL_KEY_LEN_OFFSET + key_len_size
        <= word.unsigned AES_CTRL_MANUAL_OPERATION < width;

      (* Some constants are required to have certain values *)
      nregs_key_eq : word.unsigned AES_NUM_REGS_KEY = 8;
      nregs_iv_eq : word.unsigned AES_NUM_REGS_IV = 4;
      nregs_data_eq : word.unsigned AES_NUM_REGS_DATA = 4;
      kAesEnc_eq : word.unsigned kAesEnc = 0;
      kAesDec_eq : word.unsigned kAesDec = 1;
      operation_eq : word.unsigned AES_CTRL_OPERATION = 0;
      mode_mask_eq :
        word.unsigned AES_CTRL_MODE_MASK = Z.ones mode_size;
      key_len_mask_eq :
        word.unsigned AES_CTRL_KEY_LEN_MASK = Z.ones key_len_size;

      (* Enum definitions *)
      aes_op : enum [kAesEnc; kAesDec] op_size;
      aes_mode : enum [kAesEcb; kAesCbc; kAesCtr] mode_size;
      aes_key_len : enum [kAes128; kAes192; kAes256] key_len_size;
    }.
End constants.
Notation constants := constants.constants.

(* Circuit timing properties *)
Module timing.
  Class timing :=
    { ndelays_core : nat; (* number of delays on AES core datapath *)
    }.
End timing.
Notation timing := timing.timing.

Module parameters.
  Class parameters :=
    { word :> Interface.word.word 32;
      mem :> Interface.map.map word.rep Byte.byte;
      regs :> Interface.map.map word.rep word.rep; (* register values *)
      (* TODO: mode is currently ignored *)
      aes_spec :
        forall (is_decrypt : bool)
          (key : word * word * word * word * word * word * word * word)
          (iv data : word * word * word * word),
          word * word * word * word
    }.

  Class ok (p : parameters) :=
    { word_ok : word.ok word; (* for impl of mem below *)
      mem_ok : Interface.map.ok mem; (* for impl of mem below *)
      regs_ok : Interface.map.ok regs;
    }.
End parameters.
Notation parameters := parameters.parameters.

Definition READ := "REG32_GET".
Definition WRITE := "REG32_SET".

Section WithParameters.
  Import constants parameters.
  Context {p : parameters} {p_ok : parameters.ok p}.
  Context {consts : constants Z} {timing : timing}.
  Existing Instances word_ok.
  Existing Instance constant_words.

  Local Notation bedrock2_event := (mem * string * list word * (mem * list word))%type.
  Local Notation bedrock2_trace := (list bedrock2_event).

  Inductive Register : Set :=
  | CTRL
  | STATUS
  | KEY0
  | KEY1
  | KEY2
  | KEY3
  | KEY4
  | KEY5
  | KEY6
  | KEY7
  | IV0
  | IV1
  | IV2
  | IV3
  | DATA_IN0
  | DATA_IN1
  | DATA_IN2
  | DATA_IN3
  | DATA_OUT0
  | DATA_OUT1
  | DATA_OUT2
  | DATA_OUT3
  .

  Definition reg_addr (r : Register) : word :=
    match r with
    | CTRL => AES_CTRL
    | STATUS => AES_STATUS
    | KEY0 => AES_KEY0
    | KEY1 => word.add AES_KEY0 (word.of_Z 4)
    | KEY2 => word.add AES_KEY0 (word.of_Z 8)
    | KEY3 => word.add AES_KEY0 (word.of_Z 12)
    | KEY4 => word.add AES_KEY0 (word.of_Z 16)
    | KEY5 => word.add AES_KEY0 (word.of_Z 20)
    | KEY6 => word.add AES_KEY0 (word.of_Z 24)
    | KEY7 => word.add AES_KEY0 (word.of_Z 28)
    | IV0 => AES_IV0
    | IV1 => word.add AES_IV0 (word.of_Z 4)
    | IV2 => word.add AES_IV0 (word.of_Z 8)
    | IV3 => word.add AES_IV0 (word.of_Z 12)
    | DATA_IN0 => AES_DATA_IN0
    | DATA_IN1 => word.add AES_DATA_IN0 (word.of_Z 4)
    | DATA_IN2 => word.add AES_DATA_IN0 (word.of_Z 8)
    | DATA_IN3 => word.add AES_DATA_IN0 (word.of_Z 12)
    | DATA_OUT0 => AES_DATA_OUT0
    | DATA_OUT1 => word.add AES_DATA_OUT0 (word.of_Z 4)
    | DATA_OUT2 => word.add AES_DATA_OUT0 (word.of_Z 8)
    | DATA_OUT3 => word.add AES_DATA_OUT0 (word.of_Z 12)
    end.

  Definition known_register_state : Type := map.rep (map:=regs).

  Definition reg_lookup (rs : known_register_state) (r : Register) : option word :=
    map.get rs (reg_addr r).

  Record aes_output :=
    { data_out0 : word;
      data_out1 : word;
      data_out2 : word;
      data_out3 : word; }.

  (* state *from the perspective of the software* *)
  Inductive state : Type :=
  | UNINITIALIZED (* CTRL register not yet written *)
  | IDLE (rs : known_register_state)
  | BUSY (rs : known_register_state)
         (exp_output : aes_output)
         (max_cycles_until_done : nat)
  | DONE (rs : known_register_state)
  (* TODO: add CLEAR state for aes_clear *)
  .

  (* Flags: IDLE, STALL, OUTPUT_VALID, INPUT_READY *)
  Definition status_matches_state (s : state) (status : word) : bool :=
    match s with
    | UNINITIALIZED =>
      (is_flag_set status AES_STATUS_IDLE
       && negb (is_flag_set status AES_STATUS_STALL)
       && negb (is_flag_set status AES_STATUS_OUTPUT_VALID)
       && negb (is_flag_set status AES_STATUS_INPUT_READY))
    | IDLE _ =>
      (is_flag_set status AES_STATUS_IDLE
       && negb (is_flag_set status AES_STATUS_STALL)
       && negb (is_flag_set status AES_STATUS_OUTPUT_VALID)
       && is_flag_set status AES_STATUS_INPUT_READY)
    | BUSY _ _ _ =>
      (negb (is_flag_set status AES_STATUS_IDLE)
       && negb (is_flag_set status AES_STATUS_STALL)
       && negb (is_flag_set status AES_STATUS_OUTPUT_VALID)
       && negb (is_flag_set status AES_STATUS_INPUT_READY))
    | DONE _ =>
      (* STALL can be either true or false here *)
      (negb (is_flag_set status AES_STATUS_IDLE)
       && is_flag_set status AES_STATUS_OUTPUT_VALID
       && negb (is_flag_set status AES_STATUS_INPUT_READY))
    end.

  Definition aes_expected_output (rs : known_register_state) : option aes_output :=
    ctrl <- reg_lookup rs CTRL ;;
    key0 <- reg_lookup rs KEY0 ;;
    key1 <- reg_lookup rs KEY1 ;;
    key2 <- reg_lookup rs KEY2 ;;
    key3 <- reg_lookup rs KEY3 ;;
    key4 <- reg_lookup rs KEY4 ;;
    key5 <- reg_lookup rs KEY5 ;;
    key6 <- reg_lookup rs KEY6 ;;
    key7 <- reg_lookup rs KEY7 ;;
    iv0 <- reg_lookup rs IV0 ;;
    iv1 <- reg_lookup rs IV1 ;;
    iv2 <- reg_lookup rs IV2 ;;
    iv3 <- reg_lookup rs IV3 ;;
    data_in0 <- reg_lookup rs DATA_IN0 ;;
    data_in1 <- reg_lookup rs DATA_IN1 ;;
    data_in2 <- reg_lookup rs DATA_IN2 ;;
    data_in3 <- reg_lookup rs DATA_IN3 ;;
    let is_decrypt := is_flag_set ctrl AES_CTRL_OPERATION in
    let '(out0, out1, out2, out3) :=
        aes_spec is_decrypt
                 (key0, key1, key2, key3, key4, key5, key6, key7)
                 (iv0, iv1, iv2, iv3)
                 (data_in0, data_in1, data_in2, data_in3) in
    Some {| data_out0 := out0 ;
            data_out1 := out1 ;
            data_out2 := out2 ;
            data_out3 := out3 ; |}.

  Definition is_busy (s : state) : bool :=
    match s with
    | BUSY _ _ _ => true
    | _ => false
    end.

  Definition is_output_reg (r : Register) : bool :=
    match r with
    | DATA_OUT0 => true
    | DATA_OUT1 => true
    | DATA_OUT2 => true
    | DATA_OUT3 => true
    | _ => false
    end.

  Definition out_regs_empty (rs : known_register_state) : Prop :=
    reg_lookup rs DATA_OUT0 = None
    /\ reg_lookup rs DATA_OUT1 = None
    /\ reg_lookup rs DATA_OUT2 = None
    /\ reg_lookup rs DATA_OUT3 = None.

  Definition set_out_regs
             (rs : known_register_state) (out : aes_output) : known_register_state :=
    let rs := map.put rs (reg_addr DATA_OUT0) out.(data_out0) in
    let rs := map.put rs (reg_addr DATA_OUT1) out.(data_out1) in
    let rs := map.put rs (reg_addr DATA_OUT2) out.(data_out2) in
    map.put rs (reg_addr DATA_OUT3) out.(data_out3).

  Definition unset_inp_regs
             (rs : known_register_state) : known_register_state :=
    let rs := map.remove rs (reg_addr KEY0) in
    let rs := map.remove rs (reg_addr KEY1) in
    let rs := map.remove rs (reg_addr KEY2) in
    let rs := map.remove rs (reg_addr KEY3) in
    let rs := map.remove rs (reg_addr KEY4) in
    let rs := map.remove rs (reg_addr KEY5) in
    let rs := map.remove rs (reg_addr KEY6) in
    let rs := map.remove rs (reg_addr KEY7) in
    let rs := map.remove rs (reg_addr IV0) in
    let rs := map.remove rs (reg_addr IV1) in
    let rs := map.remove rs (reg_addr IV2) in
    let rs := map.remove rs (reg_addr IV3) in
    let rs := map.remove rs (reg_addr DATA_IN0) in
    let rs := map.remove rs (reg_addr DATA_IN1) in
    let rs := map.remove rs (reg_addr DATA_IN2) in
    let rs := map.remove rs (reg_addr DATA_IN3) in
    rs.

  Inductive read_step : state -> Register -> word -> state -> Prop :=
  | ReadStatusNoChange :
      forall s val,
        is_busy s = false ->
        status_matches_state s val = true ->
        read_step s STATUS val s
  | ReadStatusStillBusy :
      forall rs out n val,
        status_matches_state (BUSY rs out n) val = true ->
        (* max #cycles until done decreases once every read *)
        read_step (BUSY rs out (S n)) STATUS val (BUSY rs out n)
  | ReadStatusFinish :
      forall rs rs' out val n,
        status_matches_state (DONE rs) val = true ->
        rs' = set_out_regs rs out ->
        read_step (BUSY rs out n) STATUS val (DONE rs')
  | ReadOutputReg :
      forall rs rs' r val,
        is_output_reg r = true ->
        reg_lookup rs r = Some val ->
        rs' = map.remove rs (reg_addr r) ->
        not (out_regs_empty rs') -> (* still not done reading output *)
        read_step (DONE rs) r val (DONE rs')
  | ReadLastOutputReg :
      forall rs rs' r val,
        is_output_reg r = true ->
        reg_lookup rs r = Some val ->
        rs' = map.remove rs (reg_addr r) ->
        out_regs_empty rs' -> (* done reading output *)
        read_step (DONE rs) r val (IDLE rs')
  .

  Definition is_input_reg (r : Register) : bool :=
    match r with
    | KEY0 => true
    | KEY1 => true
    | KEY2 => true
    | KEY3 => true
    | KEY4 => true
    | KEY5 => true
    | KEY6 => true
    | KEY7 => true
    | IV0 => true
    | IV1 => true
    | IV2 => true
    | IV3 => true
    | DATA_IN0 => true
    | DATA_IN1 => true
    | DATA_IN2 => true
    | DATA_IN3 => true
    | _ => false
    end.

  Inductive write_step : state -> Register -> word -> state -> Prop :=
  | WriteCtrl :
      forall rs val,
        rs = map.put map.empty AES_CTRL val ->
        write_step UNINITIALIZED CTRL val (IDLE rs)
  | WriteChangeCtrl :
      forall rs val,
        write_step (IDLE rs) CTRL val
                   (IDLE (map.put rs AES_CTRL val))
  | WriteInput :
      forall rs rs' r val,
        is_input_reg r = true ->
        reg_lookup rs r = None ->
        rs' = map.put rs (reg_addr r) val ->
        aes_expected_output rs' = None ->
        write_step (IDLE rs) r val (IDLE rs')
  (* TODO: add the below rules?
  | WriteChangeInput :
      forall rs r old_val val n,
        is_input_reg rs r ->
        reg_lookup rs r = Some old_val ->
        write_step (IDLE rs n) r val (IDLE (map.put rs r val) n) *)
  | WriteLastInput :
      forall rs rs' r val out,
        is_input_reg r = true ->
        reg_lookup rs r = None ->
        aes_expected_output (map.put rs (reg_addr r) val) = Some out ->
        rs' = unset_inp_regs rs ->
        write_step (IDLE rs) r val
                   (BUSY rs' out timing.ndelays_core)
  .

  Inductive step : string -> state -> list word -> list word -> state -> Prop :=
  | ReadStep :
      forall s s' r addr val,
        reg_addr r = addr ->
        read_step s r val s' ->
        step READ s [addr] [val] s'
  | WriteStep :
      forall s s' r addr val,
        reg_addr r = addr ->
        write_step s r val s' ->
        step WRITE s [addr;val] [] s'
  .

  (* Computes the Prop that must hold for this state to be accurate after the
     trace *)
  Fixpoint execution (t : bedrock2_trace) (s : state) : Prop :=
    match t with
    | [] => s = UNINITIALIZED
    | (_,action,args,(_,rets)) :: t =>
      exists prev_state,
      execution t prev_state
      /\ step action prev_state args rets s
    end.

  Definition ext_spec (t : bedrock2_trace)
             (mGive : mem)
             (action : string)
             (args: list word)
             (post: mem -> list word -> Prop) :=
    (* no memory ever given away *)
    mGive = Interface.map.empty
    /\ forall st rets,
      execution ((map.empty,action,args,(map.empty,rets)) :: t) st ->
      post Interface.map.empty rets.

  Global Instance semantics_parameters  : Semantics.parameters :=
    {|
    Semantics.width := 32;
    Semantics.word := parameters.word;
    Semantics.mem := parameters.mem;
    Semantics.locals := SortedListString.map _;
    Semantics.env := SortedListString.map _;
    Semantics.ext_spec := ext_spec;
  |}.

  Global Instance ext_spec_ok : ext_spec.ok _.
  Proof.
    constructor.
    all:cbv [ext_spec Semantics.ext_spec semantics_parameters].
    all:cbv [Morphisms.pointwise_relation Basics.impl].
    all:cbn [execution].
    all:repeat intro.
    all:repeat lazymatch goal with
               | H: _ /\ _ |- _ => destruct H
               | H: exists _, _ |- _ => destruct H
               | |- map.same_domain ?x ?x => apply Properties.map.same_domain_refl
               |  |- ?x = ?x /\ _ => split; [ reflexivity | ]
               | _ => progress subst
               end.
    all:eauto.
  Qed.

  Global Instance ok : Semantics.parameters_ok semantics_parameters.
  Proof.
    split; cbv [env locals mem semantics_parameters]; try exact _.
    { cbv; auto. }
    { exact mem_ok. }
    { exact (SortedListString.ok _). }
    { exact (SortedListString.ok _). }
  Qed.

  (* COPY-PASTE this *)
  Add Ring wring : (Properties.word.ring_theory (word := Semantics.word))
        (preprocess [autorewrite with rew_word_morphism],
         morphism (Properties.word.ring_morph (word := Semantics.word)),
         constants [Properties.word_cst]).
End WithParameters.
