Require Import Coq.ZArith.ZArith.
Require Import Coq.Lists.List.
Require Import Coq.Numbers.DecimalString.
Require Import bedrock2.Syntax bedrock2.Semantics.
Require coqutil.Datatypes.String coqutil.Map.SortedList.
Require coqutil.Map.SortedListString coqutil.Map.SortedListWord.
Require Import coqutil.Map.Interface.
Require Import coqutil.Word.Interface.
Require Import coqutil.Z.HexNotation.
Require Import coqutil.Decidable.

Import String List.ListNotations.
Local Open Scope string_scope. Local Open Scope Z_scope. Local Open Scope list_scope.

(* Loosely based on bedrock2/FE310CSemantics.v *)

Definition unique_words
           {width} {word: word.word width} {word_ok:word.ok word}
           (l : list word.rep) : Prop :=
  List.dedup word.eqb l = l.

(* Compute sequential 32-bit register addresses given a start address and a
   number of registers *)
Definition list_reg_addrs {word : word.word 32}
           (start : word.rep) (nregs : nat)
  : list word.rep :=
  map (fun i => word.add start (word.of_Z (Z.of_nat i * 4)))
      (seq 0 nregs).

Module constants.
  Class constants T :=
    { (* Constants from autogenerated aes_regs.h *)
      AES_KEY0 : T; (* first key register address *)
      AES_IV0 : T; (* first initialization vector register address *)
      AES_DATA_IN0 : T; (* first input data register address *)
      AES_DATA_OUT0 : T; (* first output data register address *)
      AES_CTRL : T; (* control register address *)
      AES_CTRL_OPERATION : T; (* control flag position *)
      AES_CTRL_MODE_MASK : T; (* mask for control mode *)
      AES_CTRL_MODE_OFFSET : T; (* offset for control mode *)
      AES_CTRL_KEY_LEN_MASK : T; (* mask for control key length *)
      AES_CTRL_KEY_LEN_OFFSET : T; (* offset for control key length *)
      AES_CTRL_MANUAL_OPERATION :T; (* control flag position *)
      AES_STATUS : T; (* status register address *)
      AES_STATUS_IDLE : T; (* status flag position *)
      AES_STATUS_STALL : T; (* status flag position *)
      AES_STATUS_OUTPUT_VALID : T; (* status flag position *)
      AES_STATUS_INPUT_READY : T; (* status flag position *)

      (* Constants defined in aes.c *)
      AES_NUM_REGS_KEY : T; (* number of key registers *)
      AES_NUM_REGS_IV : T; (* number of initialization vector registers *)
      AES_NUM_REGS_DATA : T; (* number of in/out data registers *)
    }.

  Definition constant_vars
           {names : constants string}
    : constants expr :=
    {| AES_KEY0 := expr.var AES_KEY0;
       AES_IV0 := expr.var AES_IV0;
       AES_DATA_IN0 := expr.var AES_DATA_IN0;
       AES_DATA_OUT0 := expr.var AES_DATA_OUT0;
       AES_CTRL := expr.var AES_CTRL;
       AES_CTRL_OPERATION := expr.var AES_CTRL_OPERATION;
       AES_CTRL_MODE_MASK := expr.var AES_CTRL_MODE_MASK;
       AES_CTRL_MODE_OFFSET := expr.var AES_CTRL_MODE_OFFSET;
       AES_CTRL_KEY_LEN_MASK := expr.var AES_CTRL_KEY_LEN_MASK;
       AES_CTRL_KEY_LEN_OFFSET := expr.var AES_CTRL_KEY_LEN_OFFSET;
       AES_CTRL_MANUAL_OPERATION := expr.var AES_CTRL_MANUAL_OPERATION;
       AES_STATUS := expr.var AES_STATUS;
       AES_STATUS_IDLE := expr.var AES_STATUS_IDLE;
       AES_STATUS_STALL := expr.var AES_STATUS_STALL;
       AES_STATUS_OUTPUT_VALID := expr.var AES_STATUS_OUTPUT_VALID;
       AES_STATUS_INPUT_READY := expr.var AES_STATUS_INPUT_READY;
       AES_NUM_REGS_KEY := expr.var AES_NUM_REGS_KEY;
       AES_NUM_REGS_IV := expr.var AES_NUM_REGS_IV;
       AES_NUM_REGS_DATA := expr.var AES_NUM_REGS_DATA;
    |}.

  Definition constant_names : constants string :=
    {| AES_KEY0 := "AES_KEY0";
       AES_IV0 := "AES_IV0";
       AES_DATA_IN0 := "AES_DATA_IN0";
       AES_DATA_OUT0 := "AES_DATA_OUT0";
       AES_CTRL := "AES_CTRL";
       AES_CTRL_OPERATION := "AES_CTRL_OPERATION";
       AES_CTRL_MODE_MASK := "AES_CTRL_MODE_MASK";
       AES_CTRL_MODE_OFFSET := "AES_CTRL_MODE_OFFSET";
       AES_CTRL_KEY_LEN_MASK := "AES_CTRL_KEY_LEN_MASK";
       AES_CTRL_KEY_LEN_OFFSET := "AES_CTRL_KEY_LEN_OFFSET";
       AES_CTRL_MANUAL_OPERATION := "AES_CTRL_MANUAL_OPERATION";
       AES_STATUS := "AES_STATUS";
       AES_STATUS_IDLE := "AES_STATUS_IDLE";
       AES_STATUS_STALL := "AES_STATUS_STALL";
       AES_STATUS_OUTPUT_VALID := "AES_STATUS_OUTPUT_VALID";
       AES_STATUS_INPUT_READY := "AES_STATUS_INPUT_READY";
       AES_NUM_REGS_KEY := "AES_NUM_REGS_KEY";
       AES_NUM_REGS_IV := "AES_NUM_REGS_IV";
       AES_NUM_REGS_DATA := "AES_NUM_REGS_DATA";
    |}.

  Definition globals {T} {consts : constants T} : list T :=
    [ AES_KEY0
      ; AES_IV0
      ; AES_DATA_IN0
      ; AES_DATA_OUT0
      ; AES_CTRL
      ; AES_CTRL_OPERATION
      ; AES_CTRL_MODE_MASK
      ; AES_CTRL_MODE_OFFSET
      ; AES_CTRL_KEY_LEN_MASK
      ; AES_CTRL_KEY_LEN_OFFSET
      ; AES_CTRL_MANUAL_OPERATION
      ; AES_STATUS
      ; AES_STATUS_IDLE
      ; AES_STATUS_STALL
      ; AES_STATUS_OUTPUT_VALID
      ; AES_STATUS_INPUT_READY
      ; AES_NUM_REGS_KEY
      ; AES_NUM_REGS_IV
      ; AES_NUM_REGS_DATA
    ].

  Definition all_reg_addrs {word : word.word 32}
             {global_values : constants word.rep}
    : list word.rep :=
    AES_CTRL :: AES_STATUS ::
    (list_reg_addrs AES_KEY0 (Z.to_nat (word.unsigned AES_NUM_REGS_KEY)))
      ++ (list_reg_addrs AES_IV0 (Z.to_nat (word.unsigned AES_NUM_REGS_IV)))
      ++ (list_reg_addrs AES_DATA_IN0 (Z.to_nat (word.unsigned AES_NUM_REGS_DATA)))
      ++ (list_reg_addrs AES_DATA_OUT0 (Z.to_nat (word.unsigned AES_NUM_REGS_DATA))).

  Class ok
        {word : word.word 32} {word_ok : word.ok word}
        (global_values : constants word.rep) :=
    { addrs_unique : unique_words all_reg_addrs;
      nregs_key_eq : word.unsigned AES_NUM_REGS_KEY = 8;
      nregs_iv_eq : word.unsigned AES_NUM_REGS_IV = 4;
      nregs_data_eq : word.unsigned AES_NUM_REGS_DATA = 4;
      status_flags_unique_and_nonzero :
        unique_words
          ((word.of_Z 0)
             :: (map (fun flag_position => word.slu (word.of_Z 1) flag_position)
                    [AES_STATUS_IDLE
                     ; AES_STATUS_STALL
                     ; AES_STATUS_OUTPUT_VALID
                     ; AES_STATUS_INPUT_READY]));
    }.
End constants.
Notation constants := constants.constants.

(* Circuit timing properties *)
Module timing.
  Class timing :=
    { ndelays_core : nat; (* number of delays on AES core datapath *)
      ndelays_clear : nat; (* max number of cycles to clear post-processing *)
    }.
End timing.
Notation timing := timing.timing.

Module parameters.
  Class parameters :=
    { word :> Interface.word.word 32;
      mem :> Interface.map.map word.rep Byte.byte;
      regs :> Interface.map.map word.rep word.rep; (* register values *)
    }.

  Class ok (p : parameters) :=
    { word_ok :> word.ok word; (* for impl of mem below *)
      mem_ok :> Interface.map.ok mem; (* for impl of mem below *)
      regs_ok :> Interface.map.ok regs;
    }.
End parameters.
Notation parameters := parameters.parameters.

Definition READ := "REG32_GET".
Definition WRITE := "REG32_SET".

Section WithParameters.
  Import constants parameters.
  Context {p : parameters} {p_ok : parameters.ok p}.
  Context {consts : constants word.rep} {timing : timing}.
  (* TODO: mode is currently ignored *)
  Context (aes_spec :
             forall (key : word * word * word * word * word * word * word * word)
               (iv data : word * word * word * word),
               word * word * word * word).

  Local Notation bedrock2_event := (mem * string * list word * (mem * list word))%type.
  Local Notation bedrock2_trace := (list bedrock2_event).

  Inductive Register : Set :=
  | CTRL
  | STATUS
  | KEY0
  | KEY1
  | KEY2
  | KEY3
  | KEY4
  | KEY5
  | KEY6
  | KEY7
  | IV0
  | IV1
  | IV2
  | IV3
  | DATA_IN0
  | DATA_IN1
  | DATA_IN2
  | DATA_IN3
  | DATA_OUT0
  | DATA_OUT1
  | DATA_OUT2
  | DATA_OUT3
  .

  Inductive reg_addr : Register -> word -> Prop :=
  | CTRL_addr : reg_addr CTRL AES_CTRL
  | STATUS_addr : reg_addr STATUS AES_STATUS
  | KEY0_addr : reg_addr KEY0 AES_KEY0
  | KEY1_addr : reg_addr KEY1 (word.add AES_KEY0 (word.of_Z 4))
  | KEY2_addr : reg_addr KEY2 (word.add AES_KEY0 (word.of_Z 8))
  | KEY3_addr : reg_addr KEY3 (word.add AES_KEY0 (word.of_Z 12))
  | KEY4_addr : reg_addr KEY4 (word.add AES_KEY0 (word.of_Z 16))
  | KEY5_addr : reg_addr KEY5 (word.add AES_KEY0 (word.of_Z 20))
  | KEY6_addr : reg_addr KEY6 (word.add AES_KEY0 (word.of_Z 24))
  | KEY7_addr : reg_addr KEY7 (word.add AES_KEY0 (word.of_Z 28))
  | IV0_addr : reg_addr IV0 AES_IV0
  | IV1_addr : reg_addr IV1 (word.add AES_IV0 (word.of_Z 4))
  | IV2_addr : reg_addr IV2 (word.add AES_IV0 (word.of_Z 8))
  | IV3_addr : reg_addr IV3 (word.add AES_IV0 (word.of_Z 12))
  | DATA_IN0_addr : reg_addr DATA_IN0 AES_DATA_IN0
  | DATA_IN1_addr : reg_addr DATA_IN1 (word.add AES_DATA_IN0 (word.of_Z 4))
  | DATA_IN2_addr : reg_addr DATA_IN2 (word.add AES_DATA_IN0 (word.of_Z 8))
  | DATA_IN3_addr : reg_addr DATA_IN3 (word.add AES_DATA_IN0 (word.of_Z 12))
  | DATA_OUT0_addr : reg_addr DATA_OUT0 AES_DATA_OUT0
  | DATA_OUT1_addr : reg_addr DATA_OUT1 (word.add AES_DATA_OUT0 (word.of_Z 4))
  | DATA_OUT2_addr : reg_addr DATA_OUT2 (word.add AES_DATA_OUT0 (word.of_Z 8))
  | DATA_OUT3_addr : reg_addr DATA_OUT3 (word.add AES_DATA_OUT0 (word.of_Z 12))
  .

  Definition register_state : Type := map.rep (map:=regs).
  (*
  Record aes_input {T} :=
    { key0 : T;
      key1 : T;
      key2 : T;
      key3 : T;
      key4 : T;
      key5 : T;
      key6 : T;
      key7 : T;
      iv0 : T;
      iv1 : T;
      iv2 : T;
      iv3 : T;
      data_in0 : T;
      data_in1 : T;
      data_in2 : T;
      data_in3 : T; }.
  Global Arguments aes_input : clear implicits.

  Record aes_output {T} :=
    { data_out0 : T;
      data_out1 : T;
      data_out2 : T;
      data_out3 : T; }.
  Global Arguments aes_output : clear implicits.
*)
  (* state *from the perspective of the software* *)
  Inductive state :=
  | UNINITIALIZED (* CTRL register not yet written *)
  | IDLE (rs : register_state)
  | BUSY (rs : register_state)
      (ctrl : word)
      (input : aes_input word)
      (max_cycles_until_done : nat)
  | DONE
      (ctrl : word)
      (answer : aes_output (option word))
  | CLEAR
      (ctrl : word)
      (max_cycles_until_done : nat)
  .

  (* the flag is set if ((val & (1 << flag)) != 0) *)
  Definition is_flag_set (val : word) (flag : word) : bool :=
    word.eqb (word.and val (word.slu (word.of_Z 1) flag)) (word.of_Z 0).

  (* Flags: IDLE, STALL, OUTPUT_VALID, INPUT_READY *)
  Definition status_matches_state (s : state) (status : word) : bool :=
    match s with
    | UNINITIALIZED =>
      (is_flag_set status AES_STATUS_IDLE
       && negb (is_flag_set status AES_STATUS_STALL)
       && negb (is_flag_set status AES_STATUS_OUTPUT_VALID)
       && negb (is_flag_set status AES_STATUS_INPUT_READY))
    | IDLE _ =>
      (is_flag_set status AES_STATUS_IDLE
       && negb (is_flag_set status AES_STATUS_STALL)
       && negb (is_flag_set status AES_STATUS_OUTPUT_VALID)
       && is_flag_set status AES_STATUS_INPUT_READY)
    | PARTIAL_DATA _ _ =>
      (is_flag_set status AES_STATUS_IDLE
       && negb (is_flag_set status AES_STATUS_STALL)
       && negb (is_flag_set status AES_STATUS_OUTPUT_VALID)
       && is_flag_set status AES_STATUS_INPUT_READY)
    | BUSY _ _ _ =>
      (negb (is_flag_set status AES_STATUS_IDLE)
       && negb (is_flag_set status AES_STATUS_STALL)
       && negb (is_flag_set status AES_STATUS_OUTPUT_VALID)
       && negb (is_flag_set status AES_STATUS_INPUT_READY))
    | DONE _ _ =>
      (* STALL can be either true or false here *)
      (negb (is_flag_set status AES_STATUS_IDLE)
       && is_flag_set status AES_STATUS_OUTPUT_VALID
       && negb (is_flag_set status AES_STATUS_INPUT_READY))
    | CLEAR _ _ =>
      (negb (is_flag_set status AES_STATUS_IDLE)
       && negb (is_flag_set status AES_STATUS_STALL)
       && negb (is_flag_set status AES_STATUS_OUTPUT_VALID)
       && negb (is_flag_set status AES_STATUS_INPUT_READY))
    end.

  Definition aes_expected_output (input : aes_input word) : aes_output (option word) :=
    let '(out0, out1, out2, out3) :=
        aes_spec (input.(key0), input.(key1), input.(key2), input.(key3),
                  input.(key4), input.(key5), input.(key6), input.(key7))
                 (input.(iv0), input.(iv1), input.(iv2), input.(iv3))
                 (input.(data_in0), input.(data_in1), input.(data_in2), input.(data_in3)) in
    {| data_out0 := Some out0 ;
       data_out1 := Some out1 ;
       data_out2 := Some out2 ;
       data_out3 := Some out3 ;
    |}.

  Definition is_busy (s : state) : bool :=
    match s with
    | BUSY _ _ _ => true
    | _ => false
    end.

  Definition is_clear (s : state) : bool :=
    match s with
    | CLEAR _ _ => true
    | _ => false
    end.

  Definition read_output (outvals : aes_output (option word))
    : option (aes_output (option word) * word) :=
    match r with
    | DATA_OUT0 =>
      match outvals.(out0) with
      | Some v => v
    | DATA_OUT1 => true
    | DATA_OUT2 => true
    | DATA_OUT3 => true
    | _ => false
    end.
  Definition is_output_reg (r : Register) : bool :=
    match r with
    | DATA_OUT0 => true
    | DATA_OUT1 => true
    | DATA_OUT2 => true
    | DATA_OUT3 => true
    | _ => false
    end.

  Inductive read_step : state -> Register -> word -> state -> Prop :=
  | ReadStatusNoChange :
      forall s val,
        is_busy s = false ->
        is_clear s = false ->
        status_matches_state s val = true ->
        read_step s STATUS val s
  | ReadStatusStillBusy :
      forall ctrl input n val,
        status_matches_state (BUSY ctrl input n) val = true ->
        (* max #cycles until done decreases once every read *)
        read_step (BUSY ctrl input (S n)) STATUS val (BUSY ctrl input n)
  | ReadStatusStillClear :
      forall ctrl n val,
        status_matches_state (CLEAR ctrl n) val = true ->
        (* max #cycles until done decreases once every read *)
        read_step (CLEAR ctrl (S n)) STATUS val (CLEAR ctrl n)
  | ReadStatusFinish :
      forall ctrl input val n answer,
        status_matches_state (DONE ctrl answer) val = true ->
        answer = aes_expected_output input ->
        read_step (BUSY ctrl input n) STATUS val (DONE ctrl answer)
  | ReadOutputReg :
      forall val,
        is_output_reg r
        read_step (DONE val) VALUE val IDLE
  .

  Inductive write_step : state -> Register -> word -> state -> Prop :=
  | WriteInput :
      forall val,
        write_step IDLE VALUE val (BUSY val timing.ncycles_processing)
  .

  Inductive step : string -> state -> list word -> list word -> state -> Prop :=
  | ReadStep :
      forall s s' r addr val,
        reg_addr r addr ->
        read_step s r val s' ->
        step READ s [addr] [val] s'
  | WriteStep :
      forall s s' r addr val,
        reg_addr r addr ->
        write_step s r val s' ->
        step WRITE s [addr;val] [] s'
  .

  (* Computes the Prop that must hold for this state to be accurate after the
     trace *)
  Fixpoint execution (t : bedrock2_trace) (s : state) : Prop :=
    match t with
    | [] => s = IDLE
    | (_,action,args,(_,rets)) :: t =>
      exists prev_state,
      execution t prev_state
      /\ step action prev_state args rets s
    end.

  Definition ext_spec (t : bedrock2_trace)
             (mGive : mem)
             (action : string)
             (args: list word)
             (post: mem -> list word -> Prop) :=
    (* no memory ever given away *)
    mGive = Interface.map.empty
    /\ forall st rets,
      execution ((map.empty,action,args,(map.empty,rets)) :: t) st ->
      post Interface.map.empty rets.

  Global Instance semantics_parameters  : Semantics.parameters :=
    {|
    Semantics.width := 32;
    Semantics.word := parameters.word;
    Semantics.mem := parameters.mem;
    Semantics.locals := SortedListString.map _;
    Semantics.env := SortedListString.map _;
    Semantics.ext_spec := ext_spec;
  |}.

  Global Instance ext_spec_ok : ext_spec.ok _.
  Proof.
    constructor.
    all:cbv [ext_spec Semantics.ext_spec semantics_parameters].
    all:cbv [Morphisms.pointwise_relation Basics.impl].
    all:cbn [execution].
    all:repeat intro.
    all:repeat lazymatch goal with
               | H: _ /\ _ |- _ => destruct H
               | H: exists _, _ |- _ => destruct H
               | |- map.same_domain ?x ?x => apply Properties.map.same_domain_refl
               |  |- ?x = ?x /\ _ => split; [ reflexivity | ]
               | _ => progress subst
               end.
    all:eauto.
  Qed.

  Global Instance ok : Semantics.parameters_ok semantics_parameters.
  Proof.
    split; cbv [env locals mem semantics_parameters]; try exact _.
    { cbv; auto. }
    { exact (SortedListString.ok _). }
    { exact (SortedListString.ok _). }
  Qed.

  (* COPY-PASTE this *)
  Add Ring wring : (Properties.word.ring_theory (word := Semantics.word))
        (preprocess [autorewrite with rew_word_morphism],
         morphism (Properties.word.ring_morph (word := Semantics.word)),
         constants [Properties.word_cst]).
End WithParameters.
