# Coq Style Guide

TODO: intro blurb

## Quick example

```coq
(****************************************************************************)
(* Copyright 2020 The Project Foo Authors                                   *)
(*                                                                          *)
(* <License blurb..................................>                        *)
(* <...............................................>                        *)
(****************************************************************************)


Require Import Coq.Lists.List.
Require Import Coq.micromega.Lia.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Local Open Scope Z_scope.


(* Helper proofs about standard library integers (Z) go within [Module Z] so
   that they match standard-library Z lemmas when used. *)
Module Z.
  Lemma pow_3_r x : x ^ 3 = x * x * x.
  Proof. lia. Qed. (* very short proofs can go all on one line *)

  Lemma pow_4_r x : x ^ 4 = x * x * x * x.
  Proof.
    change 4 with (Z.succ (Z.succ (Z.succ (Z.succ 0)))).
    repeat match goal with
           | _ => rewrite Z.pow_1_r
           | _ => rewrite Z.pow_succ_r by lia
           | |- context [x * (?a * ?b)] =>
             replace (x * (a * b)) with (a * b * x) by lia
           | _ => reflexivity
           end.
  Qed.
End Z.
(* Now we can access the lemmas above as Z.pow_3_r and Z.pow_4_r, as if they
   were in the ZArith library! *)

Definition bar (x y : Z) := x ^ (y + 1).

(* example with a very manual proof to show case formatting *)
Lemma bar_upper_bound :
  forall x y a,
    0 <= x <= a -> 0 <= y ->
    0 <= bar x y <= a ^ (y + 1).
Proof.
  intros x y a Hx Hy. revert y Hy x a Hx. (* avoid referencing implicit names *)
  (* explicitly indicate # subgoals with [ | ... | ] if > 1 *)
  cbv [bar]; refine (natlike_ind _ _ _); [ | ].
  { (* y = 0 *)
    intros; lia. }
  { (* y = Z.succ _ *)
    intros.
    rewrite Z.add_succ_l, Z.pow_succ_r by lia.
    split.
    { (* 0 <= bar x y *)
      apply Z.mul_nonneg_nonneg; [ lia | ].
      apply Z.pow_nonneg; lia. }
    { (* bar x y < a ^ y *)
      rewrite Z.pow_succ_r by lia.
      apply Z.mul_le_mono_nonneg; try lia;
        [ apply Z.pow_nonneg; lia | ].
      (* For more flexible proofs, use match statements to find hypotheses
         rather than referring to them by autogenerated names like H0. In this
         case, we'll take any hypothesis that applies to and then solves the
         goal. *)
      match goal with H : _ |- _ => apply H; solve [auto] end. } }
Qed.

(* Put notations in a separate module or file so that importers can
   decide whether or not to use them. *)
Module BarNotations.
  Infix "#" := bar (at level 40) : Z_scope.
  Notation "x '##'" := (bar x x) (at level 40) : Z_scope.
End BarNotations.
```

## Code organization

- copyright banner
- require imports all at the top
- standard library require imports first, same-project last
- within-project, alphabetical order
- fully qualified names
- Local Open Scope
- notations in separate modules or files

## Formatting

- line length
- indentation
  * match
  * function application
  * lemma/theorem statements
  * forall/exists quantifiers
  * fun
  * Inductive
- no trailing whitespace
- newline at end of file

## Proofs

- Proof to open proof-mode
- curly braces for subgoals
- no multiple-subgoals-in-context tactics
- indication of # subgoals if > 1

## Naming

- modules:
  * capital-letter names
  * proofs about Z should be in a Z module
- capital-letter names for inductives and their constructors
