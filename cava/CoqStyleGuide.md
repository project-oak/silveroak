# Coq Style Guide

This guide outlines code style for Coq code in this repository. There are
certainly other valid strategies and opinions on Coq code style; this is laid
out purely in the name of consistency.

## Quick example

```coq
(****************************************************************************)
(* Copyright 2020 The Project Foo Authors                                   *)
(*                                                                          *)
(* <License blurb..................................>                        *)
(* <...............................................>                        *)
(****************************************************************************)

Require Import Coq.Lists.List.
Require Import Coq.micromega.Lia.
Require Import Coq.ZArith.ZArith.
Import ListNotations.
Local Open Scope Z_scope.

(* Helper proofs about standard library integers (Z) go within [Module Z] so
   that they match standard-library Z lemmas when used. *)
Module Z.
  Lemma pow_3_r x : x ^ 3 = x * x * x.
  Proof. lia. Qed. (* very short proofs can go all on one line *)

  Lemma pow_4_r x : x ^ 4 = x * x * x * x.
  Proof.
    change 4 with (Z.succ (Z.succ (Z.succ (Z.succ 0)))).
    repeat match goal with
           | _ => rewrite Z.pow_1_r
           | _ => rewrite Z.pow_succ_r by lia
           | |- context [x * (?a * ?b)] =>
             replace (x * (a * b)) with (a * b * x) by lia
           | _ => reflexivity
           end.
  Qed.
End Z.
(* Now we can access the lemmas above as Z.pow_3_r and Z.pow_4_r, as if they
   were in the ZArith library! *)

Definition bar (x y : Z) := x ^ (y + 1).

(* example with a painfully manual proof to show case formatting *)
Lemma bar_upper_bound :
  forall x y a,
    0 <= x <= a -> 0 <= y ->
    0 <= bar x y <= a ^ (y + 1).
Proof.
  intros x y a Hx Hy. revert y Hy x a Hx. (* avoid referencing implicit names *)
  (* explicitly indicate # subgoals with [ | ... | ] if > 1 *)
  cbv [bar]; refine (natlike_ind _ _ _); [ | ].
  { (* y = 0 *)
    intros; lia. }
  { (* y = Z.succ _ *)
    intros.
    rewrite Z.add_succ_l, Z.pow_succ_r by lia.
    split.
    { (* 0 <= bar x y *)
      apply Z.mul_nonneg_nonneg; [ lia | ].
      apply Z.pow_nonneg; lia. }
    { (* bar x y < a ^ y *)
      rewrite Z.pow_succ_r by lia.
      apply Z.mul_le_mono_nonneg; try lia;
        [ apply Z.pow_nonneg; lia | ].
      (* For more flexible proofs, use match statements to find hypotheses
         rather than referring to them by autogenerated names like H0. In this
         case, we'll take any hypothesis that applies to and then solves the
         goal. *)
      match goal with H : _ |- _ => apply H; solve [auto] end. } }
Qed.

(* Put notations in a separate module or file so that importers can
   decide whether or not to use them. *)
Module BarNotations.
  Infix "#" := bar (at level 40) : Z_scope.
  Notation "x '##'" := (bar x x) (at level 40) : Z_scope.
End BarNotations.
```

## Code organization

### Legal banner

- Files should begin with a copyright/license banner, as shown in the example
  above.

### Import statements

- `Require Import` statements should all go at the top of the file, followed by
  file-wide `Import` statements.
  * `Import`s often contain notations or typeclass instances that might
     override notations or instances from another library, so it's nice to
     highlight them separately.
- One `Require Import` statement per line; it's easier to scan that way.
- `Require Import` statements should use "fully-qualified" names (e.g. `Require Import Coq.ZArith.ZArith` instead of `Require Import ZArith`).
  * Use the `Locate` command to find the fully-qualified name!
- `Require Import`s should go in the following order:
   1. Standard library dependencies (start with `Coq.`)
   2. External dependencies (anything outside the current project)
   3. Same-project dependencies
   `Require Import`s with the same root library (the name before the first `.`)
should be grouped together. Within each root-library group, they should be in
alphabetical order (so `Coq.Lists.List` before `Coq.ZArith.ZArith`).

### Notations and scopes

- Any file-wide `Local Open Scope`s should come immediately after the `Import`s
  (see example).
  * Always use `Local Open Scope`; just `Open Scope` will sneakily
open the scope for those who import your file.
- Put notations in their own separate modules or files, so that those who import your file can choose whether or not they want the notations.
  * Conflicting notations can cause a lot of headache, so it comes in very handy to leave this flexibility!

## Formatting

### Line length

- Maximum line length 80 characters.
  * Many Coq IDE setups divide the screen in half vertically and use only half
    to display source code, so more than 80 characters can be genuinely hard to
    read on a laptop.

### Whitespace and indentation

- No trailing whitespace.
- Spaces, not tabs.
- Files should end with a newline.
  * Many editors do this automatically on save.
- Default indentation should be 2 spaces
  * This prevents complex proofs from being indented ridiculously far, and
    matches IDE defaults).
- TODO: show indentation for
  * match
  * function application
  * lemma/theorem statements
  * forall/exists quantifiers
  * fun
  * Inductive

## Proofs

- Proof to open proof-mode
- curly braces for subgoals
- no multiple-subgoals-in-context tactics
- indication of # subgoals if > 1

## Naming

- modules:
  * capital-letter names
  * proofs about Z should be in a Z module
- capital-letter names for inductives and their constructors
