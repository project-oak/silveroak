Require Import Coq.Lists.List.
Require Import Coq.Strings.String.
Require Import Coq.ZArith.ZArith.
Require Import bedrock2.Semantics.
Require Import bedrock2.Syntax.
Require Import bedrock2.NotationsInConstr.
Require Import bedrock2.NotationsCustomEntry.
Require Import bedrock2.ToCString.
Require Import coqutil.Word.Interface.
Import Syntax.Coercions List.ListNotations.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope list_scope.

(* Very simplistic encoding of structs. This implementation will let
   any field read from any struct based on the offset and size. *)
Section Structs.
  Record struct_field := { offset : Z; size : access_size.access_size }.
  Definition lookup (struct_ptr : expr) (f : struct_field) : expr :=
    expr.load f.(size) (expr.op bopname.add struct_ptr (expr.literal f.(offset))).
End Structs.
Local Notation "p .! f" := (lookup p f) (at level 40).

Definition const := string.

(* Imports from autogenerated file aes_regs.h *)
Class aes_regs_h :=
  { AES_CTRL_SHADOWED_0 : const;
    AES_CTRL_SHADOWED_OPERATION : const;
    AES_CTRL_SHADOWED_MODE_MASK : const;
    AES_CTRL_SHADOWED_MODE_OFFSET : const;
    AES_CTRL_SHADOWED_KEY_LEN_MASK : const;
    AES_CTRL_SHADOWED_KEY_LEN_OFFSET: const;
  }.

(* Imports from lib/common.h *)
Class common_h := {
  REG32_SET : string;
}.

(* Imports from aes.h *)
Class aes_h :=
  { mode : struct_field;
    operation : struct_field;
    key_len : struct_field;
    manual_operation : struct_field;
  }.

Section Impl.
  Context {semantics : Semantics.parameters}.
  (* aes_cfg_t struct fields *)
  Context {aes_regs : aes_regs_h} {common : common_h} {aes : aes_h}.

  (**** aes.c
    void aes_init(aes_cfg_t aes_cfg) {
      uint32_t cfg_val =
          (aes_cfg.operation << AES_CTRL_SHADOWED_OPERATION) |
          ((aes_cfg.mode & AES_CTRL_SHADOWED_MODE_MASK)
           << AES_CTRL_SHADOWED_MODE_OFFSET) |
          ((aes_cfg.key_len & AES_CTRL_SHADOWED_KEY_LEN_MASK)
           << AES_CTRL_SHADOWED_KEY_LEN_OFFSET) |
          (aes_cfg.manual_operation << AES_CTRL_SHADOWED_MANUAL_OPERATION);
      REG32(AES_CTRL_SHADOWED(0)) = cfg_val;
      REG32(AES_CTRL_SHADOWED(0)) = cfg_val;
  };
   ***)
  Definition aes_init_struct : func :=
    let aes_cfg := "aes_cfg" in
    let cfg_val := "cfg_val" in
    ("b2_aes_init_struct",
     ([aes_cfg], [], bedrock_func_body:(
      stackalloc 4 as cfg_val {
      cfg_val = ((constr:(aes_cfg.!operation) << AES_CTRL_SHADOWED_OPERATION) |
                 ((constr:(aes_cfg.!mode) & AES_CTRL_SHADOWED_MODE_MASK)
                    << AES_CTRL_SHADOWED_MODE_OFFSET) |
                 ((constr:(aes_cfg.!key_len) & AES_CTRL_SHADOWED_KEY_LEN_MASK)
                    << AES_CTRL_SHADOWED_KEY_LEN_OFFSET)) ;
      output! REG32_SET ( AES_CTRL_SHADOWED_0, cfg_val ) ;
      output! REG32_SET ( AES_CTRL_SHADOWED_0, cfg_val )
    }))).

  Definition aes_init : func :=
    let aes_cfg_operation := "aes_cfg_operation" in
    let aes_cfg_mode := "aes_cfg_mode" in
    let aes_cfg_key_len := "aes_cfg_key_len" in
    let cfg_val := "cfg_val" in
    ("b2_aes_init",
     ([aes_cfg_operation; aes_cfg_mode; aes_cfg_key_len;
      AES_CTRL_SHADOWED_0; AES_CTRL_SHADOWED_OPERATION;
      AES_CTRL_SHADOWED_MODE_MASK; AES_CTRL_SHADOWED_MODE_OFFSET;
      AES_CTRL_SHADOWED_KEY_LEN_MASK; AES_CTRL_SHADOWED_KEY_LEN_OFFSET],
      [], bedrock_func_body:(
      cfg_val = ((aes_cfg_operation << AES_CTRL_SHADOWED_OPERATION) |
                 ((aes_cfg_mode & AES_CTRL_SHADOWED_MODE_MASK)
                    << AES_CTRL_SHADOWED_MODE_OFFSET) |
                 ((aes_cfg_key_len & AES_CTRL_SHADOWED_KEY_LEN_MASK)
                   << AES_CTRL_SHADOWED_KEY_LEN_OFFSET)) ;
      output! REG32_SET ( AES_CTRL_SHADOWED_0, cfg_val ) ;
      output! REG32_SET ( AES_CTRL_SHADOWED_0, cfg_val )
    ))).
End Impl.

Global Instance aes_h_impl : aes_h :=
  { operation := {| offset := 0; size := access_size.one |};
    mode := {| offset := 1; size := access_size.one |};
    key_len := {| offset := 2; size := access_size.one |};
    manual_operation := {| offset := 3; size := access_size.one |}
  }.
Global Instance common_h_impl : common_h :=
  { REG32_SET := "MMIOWRITE" }. (* FIXME: this is for compatibility with fe310csemantics *)
Global Instance aes_regs_h_impl : aes_regs_h :=
  { AES_CTRL_SHADOWED_0 := "AES_CTRL_SHADOWED_0";
    AES_CTRL_SHADOWED_OPERATION := "operation";
    AES_CTRL_SHADOWED_MODE_MASK := "mode_mask";
    AES_CTRL_SHADOWED_MODE_OFFSET := "mode_offset";
    AES_CTRL_SHADOWED_KEY_LEN_MASK := "key_len_mask";
    AES_CTRL_SHADOWED_KEY_LEN_OFFSET := "key_len_offset";
  }.

Compute c_module [aes_init].
Compute c_module [aes_init_struct].
Redirect "aes_init.c" Compute c_module [aes_init; aes_init_struct].
